(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{496:function(e,t,n){"use strict";n.r(t);var a=n(28),o=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h3",{attrs:{id:"_01-commit-概念"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_01-commit-概念"}},[e._v("#")]),e._v(" 01. commit 概念")]),e._v(" "),n("p",[e._v("commitRoot 是commit 阶段的起点， fiberRootNode 作为参数")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("commitRoot(root);\n")])])]),n("p",[e._v("在rootFiber.firstEffect上保存了一条需要执行副作用的Fiber节点的单向链表effectList，这些Fiber节点的updateQueue中保存了变化的props。\n这些副作用对应的DOM操作都是在Commit 阶段中进行的。")]),e._v(" "),n("h5",{attrs:{id:"commit阶段的主要工作-即renderer的工作流程-分为三部分"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#commit阶段的主要工作-即renderer的工作流程-分为三部分"}},[e._v("#")]),e._v(" commit阶段的主要工作（即Renderer的工作流程）分为三部分：")]),e._v(" "),n("ol",[n("li",[e._v("before mutation阶段（执行DOM操作前）")]),e._v(" "),n("li",[e._v("mutation阶段（执行DOM操作）")]),e._v(" "),n("li",[e._v("layout阶段（执行DOM操作后）")])]),e._v(" "),n("h3",{attrs:{id:"_02-before-mutation阶段"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_02-before-mutation阶段"}},[e._v("#")]),e._v(" 02.  before mutation阶段")]),e._v(" "),n("p",[e._v("commitBeforeMutationEffects(finishedWork); 主题函数")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 保存之前的优先级，以同步优先级执行，执行完毕后恢复之前优先级\nconst previousLanePriority = getCurrentUpdateLanePriority();\nsetCurrentUpdateLanePriority(SyncLanePriority);\n\n// 将当前上下文标记为CommitContext，作为commit阶段的标志\nconst prevExecutionContext = executionContext;\nexecutionContext |= CommitContext;\n\n// 处理focus状态\nfocusedInstanceHandle = prepareForCommit(root.containerInfo);\nshouldFireAfterActiveInstanceBlur = false;\n\n// beforeMutation阶段的主函数\ncommitBeforeMutationEffects(finishedWork);\n\nfocusedInstanceHandle = null;\n")])])]),n("h4",{attrs:{id:"commitbeforemutationeffects主要用途"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#commitbeforemutationeffects主要用途"}},[e._v("#")]),e._v(" commitBeforeMutationEffects主要用途")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function commitBeforeMutationEffects() {\n  while (nextEffect !== null) {\n    const current = nextEffect.alternate;\n\n    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {\n      // ...focus blur相关\n    }\n\n    const effectTag = nextEffect.effectTag;\n\n    // 调用getSnapshotBeforeUpdate\n    if ((effectTag & Snapshot) !== NoEffect) {\n      commitBeforeMutationEffectOnFiber(current, nextEffect);\n    }\n\n    // 调度useEffect\n    if ((effectTag & Passive) !== NoEffect) {\n      if (!rootDoesHavePassiveEffects) {\n        rootDoesHavePassiveEffects = true;\n        scheduleCallback(NormalSchedulerPriority, () => {\n          flushPassiveEffects();\n          return null;\n        });\n      }\n    }\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n")])])]),n("p",[e._v("整体分为三部分：")]),e._v(" "),n("ul",[n("li",[e._v("处理DOM节点渲染/删除后的 autoFocus、blur 逻辑。")]),e._v(" "),n("li",[e._v("调用getSnapshotBeforeUpdate生命周期钩子。")]),e._v(" "),n("li",[e._v("调度useEffect。")])]),e._v(" "),n("h4",{attrs:{id:"调用getsnapshotbeforeupdate"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#调用getsnapshotbeforeupdate"}},[e._v("#")]),e._v(" 调用getSnapshotBeforeUpdate")]),e._v(" "),n("p",[e._v("Stack Reconciler重构为Fiber Reconciler后，render阶段的任务可能中断/重新开始，对应的组件在render阶段的生命周期钩子（即componentWillXXX）可能触发多次。\nReact提供了替代的生命周期钩子getSnapshotBeforeUpdate。")]),e._v(" "),n("p",[e._v("getSnapshotBeforeUpdate是在commit阶段内的before mutation阶段调用的，由于commit阶段是同步的，所以不会遇到多次调用的问题。")]),e._v(" "),n("p",[e._v("scheduleCallback 由scheduler模块提供，用于以某个优先级异步调度一个回调函数")]),e._v(" "),n("h4",{attrs:{id:"调度useeffect"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#调度useeffect"}},[e._v("#")]),e._v(" 调度useEffect")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 调度useEffect\nif ((effectTag & Passive) !== NoEffect) {\n  if (!rootDoesHavePassiveEffects) {\n    rootDoesHavePassiveEffects = true;\n    scheduleCallback(NormalSchedulerPriority, () => {\n      // 触发useEffect\n      flushPassiveEffects();\n      return null;\n    });\n  }\n}\n")])])]),n("p",[e._v("被异步调度的回调函数就是触发useEffect的方法flushPassiveEffects。")]),e._v(" "),n("p",[e._v("在flushPassiveEffects方法内部会从全局变量rootWithPendingPassiveEffects获取effectList。")]),e._v(" "),n("h3",{attrs:{id:"_03-mutation阶段"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_03-mutation阶段"}},[e._v("#")]),e._v(" 03. mutation阶段")]),e._v(" "),n("p",[e._v("mutation阶段 也是遍历effectList，执行函数commitMutationEffects。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("nextEffect = firstEffect;\ndo {\n  try {\n      commitMutationEffects(root, renderPriorityLevel);\n    } catch (error) {\n      invariant(nextEffect !== null, 'Should be working on an effect.');\n      captureCommitPhaseError(nextEffect, error);\n      nextEffect = nextEffect.nextEffect;\n    }\n} while (nextEffect !== null);\n")])])]),n("h4",{attrs:{id:"commitmutationeffects主要用途"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#commitmutationeffects主要用途"}},[e._v("#")]),e._v(" commitMutationEffects主要用途")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function commitMutationEffects(root: FiberRoot, renderPriorityLevel) {\n  // 遍历effectList\n  while (nextEffect !== null) {\n\n    const effectTag = nextEffect.effectTag;\n\n    // 根据 ContentReset effectTag重置文字节点\n    if (effectTag & ContentReset) {\n      commitResetTextContent(nextEffect);\n    }\n\n    // 更新ref\n    if (effectTag & Ref) {\n      const current = nextEffect.alternate;\n      if (current !== null) {\n        commitDetachRef(current);\n      }\n    }\n\n    // 根据 effectTag 分别处理\n    const primaryEffectTag =\n      effectTag & (Placement | Update | Deletion | Hydrating);\n    switch (primaryEffectTag) {\n      // 插入DOM\n      case Placement: {\n        commitPlacement(nextEffect);\n        nextEffect.effectTag &= ~Placement;\n        break;\n      }\n      // 插入DOM 并 更新DOM\n      case PlacementAndUpdate: {\n        // 插入\n        commitPlacement(nextEffect);\n\n        nextEffect.effectTag &= ~Placement;\n\n        // 更新\n        const current = nextEffect.alternate;\n        commitWork(current, nextEffect);\n        break;\n      }\n      // SSR\n      case Hydrating: {\n        nextEffect.effectTag &= ~Hydrating;\n        break;\n      }\n      // SSR\n      case HydratingAndUpdate: {\n        nextEffect.effectTag &= ~Hydrating;\n\n        const current = nextEffect.alternate;\n        commitWork(current, nextEffect);\n        break;\n      }\n      // 更新DOM\n      case Update: {\n        const current = nextEffect.alternate;\n        commitWork(current, nextEffect);\n        break;\n      }\n      // 删除DOM\n      case Deletion: {\n        commitDeletion(root, nextEffect, renderPriorityLevel);\n        break;\n      }\n    }\n\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n")])])]),n("p",[e._v("commitMutationEffects 会先遍历effectList，对每个fiber节点 执行如下操作：")]),e._v(" "),n("ol",[n("li",[e._v("根据ContentReset effectTag 重置文本节点")]),e._v(" "),n("li",[e._v("更新ref")]),e._v(" "),n("li",[e._v("根据 effectTag 分别处理 增删改")])]),e._v(" "),n("h4",{attrs:{id:"placement-effect"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#placement-effect"}},[e._v("#")]),e._v(" Placement effect")]),e._v(" "),n("p",[e._v("该Fiber节点对应的DOM节点需要插入到页面中，调用的方法是：commitPlacement")]),e._v(" "),n("ol",[n("li",[e._v("获取父级DOM节点。其中finishedWork为传入的Fiber节点")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const parentFiber = getHostParentFiber(finishedWork);\nconst parentStateNode = parentFiber.stateNode; // 父级DOM节点\n")])])]),n("ol",{attrs:{start:"2"}},[n("li",[e._v("获取Fiber节点的DOM兄弟节点")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const before = getHostSibling(finishedWork);\n")])])]),n("ol",{attrs:{start:"3"}},[n("li",[e._v("根据DOM兄弟节点是否存在决定调用parentNode.insertBefore或parentNode.appendChild执行DOM插入操作。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// parentStateNode是否是rootFiber\nif (isContainer) {\n  insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);\n} else {\n  insertOrAppendPlacementNode(finishedWork, before, parent);\n}\n")])])]),n("h4",{attrs:{id:"update-effect"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#update-effect"}},[e._v("#")]),e._v(" Update effect")]),e._v(" "),n("p",[e._v("当Fiber节点含有Update effectTag，意味着该Fiber节点需要更新。调用的方法为commitWork，他会根据Fiber.tag分别处理。")]),e._v(" "),n("h5",{attrs:{id:"functioncomponent-mutation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#functioncomponent-mutation"}},[e._v("#")]),e._v(" FunctionComponent mutation")]),e._v(" "),n("p",[e._v("当fiber.tag为FunctionComponent，会调用commitHookEffectListUnmount。该方法会遍历effectList，执行所有useLayoutEffect hook的销毁函数。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("useLayoutEffect(() => {\n  // ...一些副作用逻辑\n\n  return () => {\n    // ...这就是销毁函数\n  }\n")])])]),n("h5",{attrs:{id:"hostcomponent-mutation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hostcomponent-mutation"}},[e._v("#")]),e._v(" HostComponent mutation")]),e._v(" "),n("p",[e._v("当fiber.tag为HostComponent，会调用commitUpdate函数。最终会在updateDOMProperties中将render阶段 completeWork中为Fiber节点赋值的updateQueue对应的内容渲染在页面上。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("for (let i = 0; i < updatePayload.length; i += 2) {\n  const propKey = updatePayload[i];\n  const propValue = updatePayload[i + 1];\n\n  // 处理 style\n  if (propKey === STYLE) {\n    setValueForStyles(domElement, propValue);\n  // 处理 DANGEROUSLY_SET_INNER_HTML\n  } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n    setInnerHTML(domElement, propValue);\n  // 处理 children\n  } else if (propKey === CHILDREN) {\n    setTextContent(domElement, propValue);\n  } else {\n  // 处理剩余 props\n    setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);\n  }\n}\n")])])]),n("h4",{attrs:{id:"deletion-effect"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#deletion-effect"}},[e._v("#")]),e._v(" Deletion effect")]),e._v(" "),n("p",[e._v("fiber节点对应的DOM 节点需要从页面中移除，使用方法： commitDeletion")]),e._v(" "),n("ol",[n("li",[e._v("递归调用Fiber节及其子孙fiber节点中fiber.tag 为ClassComponent的componentWillUnmount生命周期钩子，从页面移除DOM节点")]),e._v(" "),n("li",[e._v("解绑ref")]),e._v(" "),n("li",[e._v("调度useEffect的销毁函数")])]),e._v(" "),n("h3",{attrs:{id:"_04-layout阶段"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_04-layout阶段"}},[e._v("#")]),e._v(" 04. layout阶段")]),e._v(" "),n("p",[e._v("执行时机： 在DOM渲染完成（mutation阶段完成）后执行的，所以该阶段触发的生命周期钩子和hook 可以直接访问到已经改变后的DOM。")]),e._v(" "),n("p",[e._v("具体执行的是commitLayoutEffects函数")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('root.current = finishedWork;\n\nnextEffect = firstEffect;\ndo {\n  try {\n    commitLayoutEffects(root, lanes);\n  } catch (error) {\n    invariant(nextEffect !== null, "Should be working on an effect.");\n    captureCommitPhaseError(nextEffect, error);\n    nextEffect = nextEffect.nextEffect;\n  }\n} while (nextEffect !== null);\n\nnextEffect = null;\n')])])]),n("h4",{attrs:{id:"commitlayouteffects"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#commitlayouteffects"}},[e._v("#")]),e._v(" commitLayoutEffects")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function commitLayoutEffects(root: FiberRoot, committedLanes: Lanes) {\n  while (nextEffect !== null) {\n    const effectTag = nextEffect.effectTag;\n\n    // 调用生命周期钩子和hook\n    if (effectTag & (Update | Callback)) {\n      const current = nextEffect.alternate;\n      commitLayoutEffectOnFiber(root, current, nextEffect, committedLanes);\n    }\n\n    // 赋值ref\n    if (effectTag & Ref) {\n      commitAttachRef(nextEffect);\n    }\n\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n")])])]),n("p",[e._v("用途：")]),e._v(" "),n("ul",[n("li",[e._v("commitLayoutEffectOnFiber： 调用生命周期钩子和hook相关操作")]),e._v(" "),n("li",[e._v("commitAttachRef： 赋值 ref")])]),e._v(" "),n("h5",{attrs:{id:"commitlayouteffectonfiber"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#commitlayouteffectonfiber"}},[e._v("#")]),e._v(" commitLayoutEffectOnFiber")]),e._v(" "),n("ol",[n("li",[e._v("触发状态更新的this.setState 回调函数在此刻更新")]),e._v(" "),n("li",[e._v("对于functionComponent 以相关类型（特殊处理后的FunctionComponent，比如ForwardRef、React.memo包裹的FunctionComponent）会调用useLayoutEffect hook 的回调函数，调度useEffect的回调与销毁函数。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" switch (finishedWork.tag) {\n    // 以下都是FunctionComponent及相关类型\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n    case Block: {\n      // 执行useLayoutEffect的回调函数\n      commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);\n      // 调度useEffect的销毁函数与回调函数\n      schedulePassiveEffects(finishedWork);\n      return;\n }\n")])])]),n("p",[e._v("useLayoutEffect hook从上一次更新的销毁函数调用到本次更新的回调函数调用是同步执行的。\n而useEffect则需要先调度，在Layout阶段完成后再异步执行。\nHostRoot（rootFiber） 的第三个参数回调函数，也是此刻调用。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('ReactDOM.render(<App />, document.querySelector("#root"), function() {\n  console.log("i am mount~");\n});\n')])])]),n("h5",{attrs:{id:"commitattachref"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#commitattachref"}},[e._v("#")]),e._v(" commitAttachRef")]),e._v(" "),n("p",[e._v("获取DOM实例，更新ref")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('function commitAttachRef(finishedWork: Fiber) {\n  const ref = finishedWork.ref;\n  if (ref !== null) {\n    const instance = finishedWork.stateNode;\n\n    // 获取DOM实例\n    let instanceToUse;\n    switch (finishedWork.tag) {\n      case HostComponent:\n        instanceToUse = getPublicInstance(instance);\n        break;\n      default:\n        instanceToUse = instance;\n    }\n\n    if (typeof ref === "function") {\n      // 如果ref是函数形式，调用回调函数\n      ref(instanceToUse);\n    } else {\n      // 如果ref是ref实例形式，赋值ref.current\n      ref.current = instanceToUse;\n    }\n  }\n}\n')])])])])}),[],!1,null,null,null);t.default=o.exports}}]);