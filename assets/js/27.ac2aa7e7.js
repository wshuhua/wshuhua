(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{480:function(e,n,t){"use strict";t.r(n);var a=t(28),r=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("有异步I/O，必有异步编程。")]),e._v(" "),t("h3",{attrs:{id:"函数式编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数式编程"}},[e._v("#")]),e._v(" 函数式编程")]),e._v(" "),t("h4",{attrs:{id:"高阶函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#高阶函数"}},[e._v("#")]),e._v(" 高阶函数")]),e._v(" "),t("p",[e._v("高阶函数可以将函数作为参数或者将函数作为返回值的函数。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function foo(x) {\n  return function () {\n    return x;\n  };\n} \n")])])]),t("p",[e._v("通过改动sort()方法的参数，可以决定不同的排序方式。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var points = [40, 100, 1, 5, 25, 10];\npoints.sort(function(a, b) {\n return a - b;\n});\n// [ 1, 5, 10, 25, 40, 100 ] \n")])])]),t("p",[e._v("在Node中，事件的处理方式是基于高阶函数的特效来完成的。在自定义事件实例中，通过为相同事件注册不同的回调函数，可以很灵活的处理业务逻辑。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var emitter = new events.EventEmitter();\nemitter.on('event_foo', function () {\n // TODO\n}); \n")])])]),t("h4",{attrs:{id:"偏函数用法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#偏函数用法"}},[e._v("#")]),e._v(" 偏函数用法")]),e._v(" "),t("p",[e._v("偏函数用法是指创建一个调用另外一个部分-参数或变量已经预置的函数。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var toString = Object.prototype.toString;\n\nvar isString = function (obj) {\n return toString.call(obj) == '[object String]';\n};\nvar isFunction = function (obj) {\n return toString.call(obj) == '[object Function]';\n};\n")])])]),t("p",[e._v("在JavaScript中进行类型判断时，通过类似与上述代码的方法定义。里面需要我们重复去定义一些类似的函数。为了解决重复定义的问题，我们引入了一个新函数，这个新函数可以像工厂一样批量创建一些类似的函数。\n例如：通过isType()预先指定type的值，然后返回新的函数。这种通过指定部分参数来产生一个新的定制函数的形式就是 "),t("code",[e._v("偏函数")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var isType = function (type) {\n return function (obj) {\n return toString.call(obj) == '[object ' + type + ']';\n };\n};\nvar isString = isType('String');\nvar isFunction = isType('Function'); \n")])])]),t("h3",{attrs:{id:"异步编程的优势与难点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异步编程的优势与难点"}},[e._v("#")]),e._v(" 异步编程的优势与难点")]),e._v(" "),t("p",[e._v("Node利用JavaScript以及内部异步库，将异步直接提升到业务层面。")]),e._v(" "),t("h4",{attrs:{id:"优势"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优势"}},[e._v("#")]),e._v(" 优势")]),e._v(" "),t("p",[e._v("Node带来的最大特性：基于事件驱动的非阻塞I/O模型。非阻塞I/O使CPU与I/O互不依赖等待，让资源可以得到更好的利用。")]),e._v(" "),t("p",[e._v("异步I/O调用：")]),e._v(" "),t("p",[t("img",{attrs:{src:"/images/node/%E5%BC%82%E6%AD%A5IO%E8%B0%83%E7%94%A8.png",alt:""}})]),e._v(" "),t("p",[e._v("传统同步I/O模型：\n"),t("img",{attrs:{src:"/images/node/%E5%90%8C%E6%AD%A5IO%E7%A4%BA%E6%84%8F.png",alt:""}})]),e._v(" "),t("p",[e._v("Node实现异步I/O原理：利用事件循环的方式，JavaScript线程像一个分配任务和处理结果的大管家，I/O线程池里面的各个I/O线程都是小二。负责完成分配来的任务，小二与管理互不关联，所以可以保持整体的高效率。")]),e._v(" "),t("p",[e._v("由于事件循环模型需要应对海量请求，海量请求同时作用在单线程上，就需要防止任何一个计算耗费过多的CPU时间片。至于是计算密集型还是I/O\n密集型，只要不计算异步I/O的调度，就构不成问题。建议对CPU得耗用不要超过10ms，或者将大量的计算分解成诸多的小量计算。通过setImmediate()进行调度。")]),e._v(" "),t("h4",{attrs:{id:"难点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#难点"}},[e._v("#")]),e._v(" 难点")]),e._v(" "),t("ul",[t("li",[e._v("难点1: 异常处理\n过去，我们处理异常，通过使用类java的try/catch/final语句块进行一场捕获。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("try {\n JSON.parse(json);\n} catch (e) {\n // TODO\n} \n")])])]),t("p",[e._v("但是这对于异步编程不一定适用。异步I/O的实现主要包括两个阶段："),t("code",[e._v("提交请求和处理结果")]),e._v("。这两个阶段中间有事件循环的调度，两者彼此不关联，异步方法通常在第一个阶段提交请求后立即返回，因为异常不一定发生在这个阶段。try/catch的功效在此处不会发生任何作用")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var async = function (callback) {\n process.nextTick(callback);\n}; \n")])])]),t("p",[e._v("调用async()方法后，callback被存储起来，直到下一个事件循环Tick才会取出来执行。对异步方法进行try/catch操作只能捕获当前事件循环内的异常，对callback执行时抛出来的异常无能为力。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("try {\n async(callback);\n} catch (e) {\n // TODO\n} \n")])])]),t("p",[e._v("Node在处理异常上形成了一种约定，将异常作为回调函数的第一个实参传回，如果为空值，表明异常调用没有异常抛出。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("async(function (err, results) {\n // TODO\n});\n")])])]),t("p",[e._v("在我们自行编写的异步方法上，需要遵循这样的原则：")]),e._v(" "),t("ol",[t("li",[e._v("必须执行调用者传入的回调函数")]),e._v(" "),t("li",[e._v("正确传递异常供调用者判断")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var async = function (callback) {\n process.nextTick(function() {\n var results = something;\n if (error) {\n return callback(error);\n }\n callback(null, results);\n });\n};\n")])])]),t("p",[e._v("在异步方法的编写中，另外一个常犯的错误是对用户传递的回调函数进行异常捕获。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("try {\n req.body = JSON.parse(buf, options.reviver);\n callback();\n} catch (err){\n err.body = buf;\n err.status = 400;\n callback(err);\n} \n")])])]),t("p",[e._v("上述代码的意图是捕获JSON.parse()中可能出现的异常，但是却不小心包含了用户传递的回调函数。这意味着如果回调函数中有异常抛出，将会进入catch()代码块中执行，于是回调函数会被执行两次。\n正确的捕获：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("try {\n  req.body = JSON.parse(buf, options.reviver);\n} catch (err){\n  err.body = buf; \n  err.status = 400;\n  return callback(err);\n}\ncallback(); \n")])])]),t("p",[e._v("在编写异步方法时，只要将异常正确的传递给用户的回调方法即可。无须过多处理。")]),e._v(" "),t("ul",[t("li",[e._v("难点2: 函数嵌套过深\n在Node中，事务中存在多个异常调用的场景：比如一个遍历目录的操作：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("fs.readdir(path.join(__dirname, '..'), function (err, files) {\n  files.forEach(function (filename, index) {\n  fs.readFile(filename, 'utf8', function (err, file) {\n   // TODO\n  });\n });\n}); \n")])])]),t("p",[e._v("对于上述场景，由于两次操作存在依赖关系，函数嵌套的行为也许情有可原。在网页渲染过程中，通常需要数据，模版，资源文件，这三者互相不依赖，但是在最终渲染结果中，三者缺一不可。如果采用默认的异步方法调用，程序取下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("fs.readFile(template_path, 'utf8', function (err, template) {\n db.query(sql, function (err, data) {\n l10n.get(function (err, resources) {\n // TODO\n });\n });\n});\n")])])]),t("ul",[t("li",[e._v("难点3: 阻塞代码")])]),e._v(" "),t("p",[e._v("疑惑🤔为什么没有sleep()这样的线程沉睡功能，唯有用于延时的setInterval和setTimeout()这两个函数。这两个函数不能阻塞后续代码的持续执行。实现sleep(1000)的效果：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// TODO\nvar start = new Date();\nwhile (new Date() - start < 1000) {\n // TODO\n}\n// 需要阻塞的代码\n")])])]),t("p",[e._v("实际是这段代码会支持占用CPU进行判断，与真正的线程沉睡相去甚远，完全破坏了事件循环的调度。由于Node单线程的原因，CPU资源全都会用于这段代码服务，导致其余任何请求都会得不到响应。\n需要这样的需求时，在统一规划好业务逻辑后，调用setTimeout()的效果会更好。")]),e._v(" "),t("ul",[t("li",[e._v("难点4: 多线程编程\n我们在谈论JavaScript的时候，通常谈的是单一线程上执行的代码，这在浏览器中指的是JavaScript执行线程与UI渲染共用一个线程，在Node中，只是没有渲染UI的部分，模型基本相同。对于服务端而言，如果服务器是多核CPU，单个Node进程实质上没有充分利用多核CPU")])]),e._v(" "),t("p",[e._v("浏览器提出Web Workers,它通过将JavaScript执行与UI渲染分离，可以很好利用多核CPU为大量计算服务。同时前端Web Workers也是一个利用消息机制合理使用多核CPU的理想模型。")]),e._v(" "),t("p",[t("img",{attrs:{src:"/images/node/webWorkers%E5%B7%A5%E4%BD%9C%E7%A4%BA%E6%84%8F.png",alt:""}})]),e._v(" "),t("p",[e._v("遗憾在于前端浏览器存在对标准的滞后性，Web Workers没有广泛应用起来。Web Workers能解决利用CPU和减少阻塞UI渲染，但是不能解决UI渲染的效率问题。Node借鉴这个模式，child_process是其基础API，cluster模块是更深层次的应用。")]),e._v(" "),t("ul",[t("li",[e._v("难点5: 异步转同步\nNode提供了绝大部分的异步API和少量的同步API，偶尔出现的同步需求会因没有同步API让开发者无所适从。")])]),e._v(" "),t("h3",{attrs:{id:"异步编程解决方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异步编程解决方案"}},[e._v("#")]),e._v(" 异步编程解决方案")]),e._v(" "),t("p",[e._v("前面列举了因异步编程带来的一些问题，与异步编程提升的性能成功相比，编程过程看起来咩有想象中那么美好。\n目前异步编程的主要解决方案有三种。")]),e._v(" "),t("ol",[t("li",[e._v("事件发布/订阅模式")]),e._v(" "),t("li",[e._v("Primise/Deferred模式")]),e._v(" "),t("li",[e._v("流程控制库")])]),e._v(" "),t("h4",{attrs:{id:"事件发布-订阅模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件发布-订阅模式"}},[e._v("#")]),e._v(" 事件发布/订阅模式")]),e._v(" "),t("p",[e._v("事件监听器模式是一种广泛用于异步编程的模式，是回调函数的事件化，又称"),t("code",[e._v("发布/订阅模式")]),e._v("。\nNode自身提供的"),t("a",{attrs:{href:"https://nodejs.org/docs/latest/api/events.html",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("events")]),e._v("模块"),t("OutboundLink")],1),e._v("是发布/订阅模式的一个简单实现。Node中大部分模块都继承自它，这个模块比前端浏览器中大量DOM事件简单，不存在事件冒泡，也不存在preventDefault(),stopPropagation()和stopImmediatePropagation()\n()等控制事件传递的方法。它具有addListener/on(), once(), removeListener(), removeAllListener()和emit()等基本的事件监听模式的方法实现。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// 订阅\nemitter.on("event1", function (message) {\n console.log(message);\n});\n// 发布\nemitter.emit(\'event1\', "I am message!"); \n')])])]),t("p",[e._v("可以看到订阅事件是一个高阶函数的应用。事件发布/订阅模式可以实现一个事件与多个回调函数（事件侦听器）的关联。通过 "),t("code",[e._v("emit")]),e._v("发布事件后，消息会立即传递给当前节点事件的所有侦听器。侦听器可以灵活的添加和删除，使得事件与具体处理逻辑之间可以很轻松的关联与接耦。")]),e._v(" "),t("p",[e._v("事件发布/订阅模式自身并无同步与异步调用的问题，但是在Node中，emit()调用多半是伴随事件循环而异步触发的。所以我们说事件发布/订阅模式广泛应用于异步编程。")]),e._v(" "),t("p",[e._v("事件发布/订阅模式常常用来接耦业务逻辑，事件发布者无须关注订阅的侦听器如何实现业务逻辑，数据通过消息的方式可以很灵活的传递。")]),e._v(" "),t("p",[e._v("可以通过事件发布/订阅模式进行组件分装，将不变的部分分装在组件内部，将容易变化，需自定义的部分通过事件暴露给外部处理。这是一种典型的逻辑分离方式。")]),e._v(" "),t("p",[e._v("从另一个角度来看，事件侦听器模式也是一种钩子（hook）机制，利用钩子导出内部数据或状态给外部的调用者，Node中很多对象都具有黑盒子状态，功能点较少，如果不通过事件钩子的形式，很难获得对象在运行期间的中间值或内部状态。\nHttp请求就是典型的场景：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var options = {\n host: 'www.google.com',\n port: 80,\n path: '/upload',\n method: 'POST'\n};\nvar req = http.request(options, function (res) {\n console.log('STATUS: ' + res.statusCode);\n console.log('HEADERS: ' + JSON.stringify(res.headers));\n res.setEncoding('utf8');\n res.on('data', function (chunk) {\n console.log('BODY: ' + chunk);\n });\n res.on('end', function () {\n // TODO\n });\n});\nreq.on('error', function (e) {\n console.log('problem with request: ' + e.message);\n});\n// write data to request body\nreq.write('data\\n');\nreq.write('data\\n')\n")])])]),t("p",[e._v("在这段Http请求中，程序员只需要将视线放在error,data,end这些业务事件点上，至于内部的流程如何，无须关注。")]),e._v(" "),t("p",[e._v("Node对事件发布/订阅做了额外处理：")]),e._v(" "),t("ol",[t("li",[e._v("如果对一个事件添加了超过10个侦听器，将会得到一个警告。这一处设计与Node自身单线程运行有关，设计者认为侦听器太多可能会导致内存泄露。所以存在这样一个警告。调用"),t("code",[e._v("emitter.setMaxListeners(0)")]),e._v("可以将这个限制去掉。另外，由于事件发布会引起一系列侦听器执行，如果事件相关的侦听器过多，可能会存在过多占用CPU的场景。")]),e._v(" "),t("li",[e._v("为了处理异常，"),t("code",[e._v("EventEmitter")]),e._v("对象对error事件进行了特殊对待，如果运行期间的错误触发了error事件，"),t("code",[e._v("EventEmitter")]),e._v("会检查是否有多error事件添加过侦听器。如果添加了，这个错误将会交给侦听器处理，否则这个错误将会作为异常抛出。如果外部没有捕获这个异常，将会引起线程退出。")])]),e._v(" "),t("ul",[t("li",[e._v("继承events模块\n实现一个继承EventEmitter的类")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var events = require('events');\nfunction Stream() {\n events.EventEmitter.call(this);\n}\nutil.inherits(Stream, events.EventEmitter); \n")])])]),t("p",[e._v("Node在util模块中封装了继承的方法，所以此处可以很遍历的调用。开发者可以通过这样的方式轻松的继承"),t("code",[e._v("EventEmitter")]),e._v(",利用事件机制解决业务问题。在Node提供的核心模块中，有近半数都继承自"),t("code",[e._v("EventEmitter")])]),e._v(" "),t("ul",[t("li",[e._v("利用事件队列解决雪崩问题\n在事件订阅/发布模式中，通常有一个once()方法，通过它添加的侦听器只执行一次，在执行之后就会将它与事件的关联移除。\n如何采用once()解决雪崩问题\n在计算机中，缓存由于存放在内存中，访问速度十分快，常常用于加速数据访问，让绝大多数的请求不必重复去做一些低效率的数据读取。")])]),e._v(" "),t("p",[e._v("雪崩问题：就是在高访问量，大并发量的情况下缓存失效的情景此时大量的请求同时涌入数据库中，数据库无法同时承受如此大的查询请求，进而影响到网站整体的响应速度。\n数据库查询语句：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('var select = function (callback) {\n db.select("SQL", function (results) {\n callback(results);\n });\n}; \n')])])]),t("p",[e._v("如果站点刚好启动，这时缓存汇总是不存在数据的，如果访问量大，同一句sql会被发送到数据库中反复查询，会影响服务的整体性能，一种改进方案是添加一个状态锁。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('var status = "ready";\nvar select = function (callback) {\n if (status === "ready") {\n status = "pending";\n db.select("SQL", function (results) {\n status = "ready";\n callback(results);\n });\n }\n}; \n')])])]),t("p",[e._v("在这种场景下，连续多次的调用select()时，只有第一次调用时生效的，后续的select()是没有数据服务的，这个时候可以引入事件队列")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('var proxy = new events.EventEmitter();\nvar status = "ready";\nvar select = function (callback) {\n proxy.once("selected", callback);\n if (status === "ready") {\n status = "pending";\n db.select("SQL", function (results) {\n proxy.emit("selected", results);\n status = "ready";\n });\n }\n};\n')])])]),t("p",[e._v("这里我们利用once()方法，将所有的请求回调都压入到事件队列中，利用其执行一次就会将监视器移除的特点，保证每一个回调只会被执行一次。")]),e._v(" "),t("p",[e._v("此处可能因为存在侦听器过多引发的警告，需要调用setMaxListeners(0)移除掉警告，或者设更大的警告阀值。")]),e._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[e._v("多异步之间的协作方案\n事件发布/订阅有着它的优点，利用高阶函数的优势，侦听器作为回调函数可以随意添加和删除，它帮助开发者轻松处理随时可能添加的业务逻辑，也可以隔离业务逻辑，保持业务逻辑单元的职业单一。\n使用原生代码解决难点2（函数嵌套过深 在Node中，事务中存在多个异常调用的场景）")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('var count = 0;\nvar results = {};\nvar done = function (key, value) {\n results[key] = value;\n count++;\n if (count === 3) {\n // 渲染页面\n render(results);\n } \n };\nfs.readFile(template_path, "utf8", function (err, template) {\n done("template", template);\n});\ndb.query(sql, function (err, data) {\n done("data", data);\n});\nl10n.get(function (err, resources) {\n done("resources", resources);\n}); \n')])])]),t("p",[e._v("由于多个异步场景中回调函数的执行并不能保证顺序，且回调函数相互之间没有任何交集，所以需要借助一个第三方函数和第三方变量来处理异步协作的结果。\n通常，我们将这个用于检测次数的变量叫做"),t("code",[e._v("哨兵变量")]),e._v("。\n可以利用偏函数来处理哨兵变量与第三方函数的关系")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var after = function (times, callback) {\n var count = 0, results = {};\n return function (key, value) {\n results[key] = value;\n count++;\n if (count === times) {\n callback(results);\n }\n };\n};\nvar done = after(times, render); \n")])])]),t("p",[e._v("上述方案实现了多对一的目的。如果业务继续增长，我们依然可以利用发布/订阅的方式来完成多对多的方案")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('var emitter = new events.Emitter();\nvar done = after(times, render);\nemitter.on("done", done);\nemitter.on("done", other);\nfs.readFile(template_path, "utf8", function (err, template) {\n emitter.emit("done", "template", template);\n});\ndb.query(sql, function (err, data) {\n emitter.emit("done", "data", data);\n});\nl10n.get(function (err, resources) {\n emitter.emit("done", "resources", resources);\n});\n\n')])])]),t("p",[e._v("这个方案结合了前者用简单的偏函数完成多对一的收敛与事件订阅/发布模式中一对多的发散。\n这个缺点在于：调用者要去准备着done()函数，以及在回调函数中需要从结果中把数据一个一个提取出来，再进行维护。")]),e._v(" "),t("p",[e._v("另外一个方案：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('var proxy = new EventProxy();\nproxy.all("template", "data", "resources", function (template, data, resources) {\n // TODO\n});\nfs.readFile(template_path, "utf8", function (err, template) {\n proxy.emit("template", template);\n});\ndb.query(sql, function (err, data) {\n proxy.emit("data", data);\n});\nl10n.get(function (err, resources) {\n proxy.emit("resources", resources);\n});\n')])])]),t("p",[e._v("EventProxy提供了一个all()方法来订阅多个事件，当每个事件都被触发以后，侦听器才会执行。\n另外一个就是tail,他与all()方法的区别在于all()方法的侦听器在满足条件后只会执行一次，tail()方法的侦听器在满足条件时执行一次之后，如果组合事件的某个事件再次被触发，侦听器会用最新的数据继续执行。\nall(）方法的改进：在侦听器中返回数据的参数列表与订阅组合事件的事件列表时一致对应的。")]),e._v(" "),t("p",[e._v("在异步场景下，我们需要从一个接口多次读取数据，此时触发的事件名或许是相同的，EventProxy提供了after()方法来实现事件在执行多次后执行侦听器的单一事件组合订阅方式。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('var proxy = new EventProxy();\nproxy.after("data", 10, function (datas) {\n // TODO\n}); \n')])])]),t("p",[e._v("执行0次data事件后执行侦听器。这个侦听器的数据为10次按事件触发次序排序的数组。")]),e._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[e._v("EventProxy原理")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('  trigger: function (eventName) {\n    var list, calls, ev, callback, args;\n    var both = 2;\n    if (!(calls = this._callbacks)) return this;\n    while (both--) {\n      ev = both ? eventName : "all";\n      if ((list = calls[ev])) {\n        for (var i = 0, l = list.length; i < l; i++) {\n          if (!(callback = list[i])) {\n            list.splice(i, 1);\n            i--;\n            l--;\n          } else {\n            args = both ? Array.prototype.slice.call(arguments, 1) : arguments;\n            callback[0].apply(callback[1] || this, args);\n          }\n        }\n      }\n    }\n    return this;\n  },\n \n')])])]),t("p",[e._v("EventProxy是将all作为一个事件流的拦截层，在其中注入一些业务来处理单一事件无法解决的异步处理问题。类似的扩展还有all(), tail(), after(), not()和any()等。")]),e._v(" "),t("ol",{attrs:{start:"5"}},[t("li",[e._v("EventProxy异常处理")])]),e._v(" "),t("p",[e._v("通过额外添加error事件来进行异常统一处理。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("exports.getContent = function (callback) {\n    var ep = new EventProxy();\n    ep.all('tpl', 'data', function (tpl, data) {\n        // 成功回调\n        callback(null, {\n            template: tpl,\n            data: data\n        });\n    });\n    // 侦听error事件\n    ep.bind('error', function (err) {\n        // ႂ载ۖ໯有处理函数\n        ep.unbind();\n        // 异常回调\n        callback(err);\n    });\n    fs.readFile('template.tpl', 'utf-8', function (err, content) {\n        if (err) {\n            //一旦发生异常，一律交给error事件的处理函数处理\n            return ep.emit('error', err);\n        }\n        ep.emit('tpl', content);\n    });\n    db.get('some sql', function (err, result) {\n        if (err) {\n            // 一旦发生异常，一律交给error事件的处理函数处理\n            return ep.emit('error', err);\n        }\n        ep.emit('data', result);\n    }); \n}\n")])])]),t("p",[e._v("改进：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('exports.getContent = function (callback) {\n  var ep = new EventProxy();\n  ep.all("tpl", "data", function (tpl, data) {\n    // 成功回调\n    callback(null, {\n      template: tpl,\n      data: data,\n    });\n  });\n  //绑定错误处理函数\n  ep.fail(callback);\n  fs.readFile("template.tpl", "utf-8", ep.done("tpl"));\n  db.get("some sql", ep.done("data"));\n};\n')])])]),t("p",[e._v("在上述代码中EventProxy提供了fail和done两个实例方法来优化异常处理。使得开发者将精力关注在业务开发上，而不是异常捕获上。\nfail()的实现，参见一下变换：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("ep.fail(callback); \n")])])]),t("p",[e._v("等价于：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("ep.fail(function (err) {\n callback(err);\n}); \n")])])]),t("p",[e._v("又等价于：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("ep.bind('error', function (err) {\n // ႂ卸载掉所有有处理函数\n ep.unbind();\n // 异常回调\n callback(err);\n});\n")])])]),t("p",[e._v("done()的实现，参见一下变换：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("ep.done('tpl');\n")])])]),t("p",[e._v("等价于：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function (err, content) {\n if (err) {\n // 一旦发生异常，一律交给error事件处理函数处理\n return ep.emit('error', err);\n }\n ep.emit('tpl', content);\n} \n")])])]),t("p",[e._v("同时done()方法接受一个函数作为参数：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("ep.done(function (content) {\n // TODO\n // 无须关注异常\n ep.emit('tpl', content);\n}); \n")])])]),t("p",[e._v("这段代码等价于：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function (err, content) {\n if (err) {\n // 一旦发生异常，一律交给error事件的处理函数处理\n return ep.emit('error', err);\n }\n (function (content) {\n // TODO\n // 无须关注异常\n ep.emit('tpl', content);\n }(content));\n} \n")])])]),t("h4",{attrs:{id:"promise-deferred模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-deferred模式"}},[e._v("#")]),e._v(" Promise/Deferred模式")]),e._v(" "),t("p",[e._v("先执行异步调用，延迟传递处理。")]),e._v(" "),t("h4",{attrs:{id:"promises-a"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promises-a"}},[e._v("#")]),e._v(" Promises/A")]),e._v(" "),t("p",[e._v("Promise/Deferred模式其实只包含两个部分，即Promise和Deferred。")]),e._v(" "),t("p",[e._v("Promise的状态转化示意图：\n"),t("img",{attrs:{src:"/images/node/Promise%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8C%96%E7%A4%BA%E6%84%8F%E5%9B%BE.png",alt:""}})]),e._v(" "),t("p",[e._v("一个Promise对象只要具备了then() 方法即可。")]),e._v(" "),t("p",[e._v("then()方法定义如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("then(fulfilledHandler, errorHandler, progressHandler) \n")])])]),t("p",[e._v("通过Node的events模块来完成一个简单实现。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const events = require('events');\nvar EventEmitter = new events.EventEmitter();\nvar Promise = function () {\n    EventEmitter.call(this);\n};\nutil.inherits(Promise, EventEmitter);\nPromise.prototype.then = function (fulfilledHandler, errorHandler, progressHandler) {\n    if (typeof fulfilledHandler === 'function') {\n        // 利用once()方法，保证成功回调函数只执行一次。\n        this.once('success', fulfilledHandler);\n    }\n    if (typeof errorHandler === 'function') {\n        // 利用once()方法，保证异常回调函数只执行一次。\n        this.once('error', errorHandler);\n    }\n    if (typeof progressHandler === 'function') {\n        this.on('progress', progressHandler);\n    }\n    return this;\n};\n")])])]),t("p",[e._v("触发执行这些回调函数的地方，实现这些功能的对象通常被称为"),t("code",[e._v("Deferred")]),e._v(",即延迟对象。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('var Deferred = function () {\n  this.state = "unfulfilled";\n  this.promise = new Promise();\n};\nDeferred.prototype.resolve = function (obj) {\n  this.state = "fulfilled";\n  this.promise.emit("success", obj);\n};\nDeferred.prototype.reject = function (err) {\n  this.state = "failed";\n  this.promise.emit("error", err);\n};\nDeferred.prototype.progress = function (data) {\n  this.promise.emit("progress", data);\n};\n')])])]),t("p",[t("img",{attrs:{src:"/images/node/promise%E7%8A%B6%E6%80%81%E4%B8%8E%E6%96%B9%E6%B3%95%E4%B9%8B%E9%97%B4%E7%9A%84%E5%9B%9E%E8%B0%83.png",alt:""}})]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var promisify = function (res) { var deferred = new Deferred(); var result = '';\nres.on('data', function (chunk) {\n    result += chunk;\ndeferred.progress(chunk); });\nres.on('end', function () { deferred.resolve(result);\n});\nres.on('error', function (err) {\ndeferred.reject(err); });\nreturn deferred.promise; };\n")])])]),t("p",[e._v("如此就得到简单的结果。这里返回"),t("code",[e._v("deferred.promise")]),e._v("的目的是为了·不让外部程序调用resolve和reject(),更改内部状态的行为交给定义者处理。")]),e._v(" "),t("p",[e._v("示例：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('promisify(res).then(\n  function () {\n    // Done\n  },\n  function (err) {\n    // Error\n  },\n  function (chunk) {\n    // progress\n    console.log("BODY: " + chunk);\n  }\n);\n')])])]),t("p",[e._v("Promise和Deferred整体关系示意图:")]),e._v(" "),t("p",[t("img",{attrs:{src:"/images/node/Promise%E5%92%8CDeferred%E6%95%B4%E4%BD%93%E5%85%B3%E7%B3%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.png",alt:""}}),e._v("\n与事件发布/订阅模式相比，Promise和Deferred模式的API接口和抽象模型都十分简洁。从上面代码可以看出，将业务中不可变的部分封装在了Deferred中，将可变的部分交给了Promise。\nQ模块是Promise/A规范的一个实现。\n它对Node中常见回调函数的Promise实现如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("/**\n* Creates a Node-style callback that will resolve or reject the deferred\n* promise.\n* @returns a nodeback\n*/\ndefer.prototype.makeNodeResolver = function () {\n   var self = this;\n   return function (error, value) {\n       if (error) {\n           self.reject(error);\n       } else if (arguments.length > 2) {\n           self.resolve(array_slice(arguments, 1));\n       } else {\n           self.resolve(value);\n       }\n   };\n};\n")])])]),t("p",[t("code",[e._v("makeNodeResolver")]),e._v("返回一个Node风格的回调函数。\n对于fs.readFile()的调用，演化为如下形式：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('var readFile = function (file, encoding) {\n  var deferred = Q.defer();\n  fs.readFile(file, encoding, deferred.makeNodeResolver());\n  return deferred.promise;\n};\n// 定义之后的调用示例如下：\nreadFile("foo.txt", "utf-8").then(\n  function (data) {\n    // Success case\n  },\n  function (err) {\n    // Failed case\n  }\n);\n\n')])])]),t("ol",{attrs:{start:"2"}},[t("li",[e._v("Promise 中多异步协作\nPromise主要解决的是单个异步操作中存在的问题。当我们需要处理多个异步调用，该如何？")])]),e._v(" "),t("p",[e._v("类似于EventProxy，原型实现：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Deferred.prototype.all = function (promises) {\n  var count = promises.length;\n  var that = this;\n  var results = [];\n  promises.forEach(function (promise, i) {\n    promise.then(\n      function (data) {\n        count--;\n        results[i] = data;\n        if (count === 0) {\n          that.resolve(results);\n        }\n      },\n      function (err) {\n        that.reject(err);\n      }\n    );\n  });\n  return this.promise;\n};\n\n")])])]),t("p",[e._v("对于多次文件的读取场景，以下面的代码为例，all()方法将两个单独的Promise重新抽象组合成一个新的Promise：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('var promise1 = readFile("foo.txt", "utf-8");\nvar promise2 = readFile("bar.txt", "utf-8");\nvar deferred = new Deferred();\ndeferred.all([promise1, promise2]).then(function (results) {\n // TODO\n}, function (err) {\n // TODO\n}); \n')])])]),t("ol",{attrs:{start:"3"}},[t("li",[e._v("Promise的进阶知识。")])]),e._v(" "),t("p",[e._v("恶魔金字塔：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("obj.api1(function (value1) {\n  obj.api2(value1, function (value2) {\n    obj.api3(value2, function (value3) {\n      obj.api4(value3, function (value4) {\n        callback(value4);\n      });\n    });\n  });\n});\n")])])]),t("p",[e._v("拆分上述代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var handler1 = function (value1) {\n obj.api2(value1, handler2);\n};\nvar handler2 = function (value2) {\n obj.api3(value2, handler3);\n};\nvar handler3 = function (value3) {\n obj.api4(value3, hander4);\n};\nvar handler4 = function (value4) {\n callback(value4);\n});\nobj.api1(handler1); \n")])])]),t("p",[e._v("利用事件的开发者：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('var emitter = new event.Emitter();\nemitter.on("step1", function () {\n obj.api1(function (value1) {\n emitter.emit("step2", value1);\n });\n});\nemitter.on("step2", function (value1) {\n obj.api2(value1, function (value2) {\n emitter.emit("step3", value2);\n });\n});\nemitter.on("step3", function (value2) {\n obj.api3(value2, function (value3) {\n emitter.emit("step4", value3);\n });\n});\nemitter.on("step4", function (value3) {\n obj.api4(value3, function (value4) {\n callback(value4);\n });\n}); \nemitter.emit("step1"); \n')])])]),t("ul",[t("li",[e._v("支持序列执行的Promise\n链式调用：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("promise()\n .then(obj.api1)\n .then(obj.api2)\n .then(obj.api3)\n .then(obj.api4)\n .then(function (value4) {\n // Do something with value4\n }, function (error) {\n // Handle any error from step1 through step4\n })\n .done(); \n")])])]),t("p",[e._v("优化后：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('var Deferred = function () {\n  this.promise = new Promise();\n};\n// 完成态\nDeferred.prototype.resolve = function (obj) {\n  var promise = this.promise;\n  var handler;\n  while ((handler = promise.queue.shift())) {\n    if (handler && handler.fulfilled) {\n      var ret = handler.fulfilled(obj);\n      if (ret && ret.isPromise) {\n        ret.queue = promise.queue;\n        this.promise = ret;\n        return;\n      }\n    }\n  }\n};\n// 失败态\nDeferred.prototype.reject = function (err) {\n  var promise = this.promise;\n  var handler;\n  while ((handler = promise.queue.shift())) {\n    if (handler && handler.error) {\n      var ret = handler.error(err);\n      if (ret && ret.isPromise) {\n        ret.queue = promise.queue;\n        this.promise = ret;\n        return;\n      }\n    }\n  }\n};\n// 生成回调函数\nDeferred.prototype.callback = function () {\n  var that = this;\n  return function (err, file) {\n    if (err) {\n      return that.reject(err);\n    }\n    that.resolve(file);\n  };\n};\nvar Promise = function () {\n  // 队列用于存储执行的回调函数\n  this.queue = [];\n  this.isPromise = true;\n};\nPromise.prototype.then = function (\n  fulfilledHandler,\n  errorHandler,\n  progressHandler\n) {\n  var handler = {};\n  if (typeof fulfilledHandler === "function") {\n    handler.fulfilled = fulfilledHandler;\n  }\n  if (typeof errorHandler === "function") {\n    handler.error = errorHandler;\n  }\n  this.queue.push(handler);\n  return this;\n};\n\n')])])]),t("p",[e._v("这里我们以两次文件读取作为例子，以验证该设计的可行性。这里假设读取第二个文件是依\n赖于第一个文件中的内容的，相关代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var readFile1 = function (file, encoding) {\n var deferred = new Deferred();\n fs.readFile(file, encoding, deferred.callback());\n return deferred.promise;\n};\nvar readFile2 = function (file, encoding) {\n var deferred = new Deferred();\n fs.readFile(file, encoding, deferred.callback());\n return deferred.promise;\n};\nreadFile1('file1.txt', 'utf8').then(function (file1) {\n return readFile2(file1.trim(), 'utf8');\n}).then(function (file2) {\n console.log(file2);\n}); \n")])])]),t("h4",{attrs:{id:"流程控制库"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#流程控制库"}},[e._v("#")]),e._v(" 流程控制库")]),e._v(" "),t("p",[e._v("最为主流的模式——事件发布/订阅模式和Promise/Deferred模式，")]),e._v(" "),t("ol",[t("li",[e._v("尾触发与Next")])]),e._v(" "),t("p",[e._v("除了事件和Promise外，还有一类方法是需要手工调用才能持续执行后续调用的，我们将此类方法叫做"),t("code",[e._v("尾触发")]),e._v("，常见的关键词是"),t("code",[e._v("next")]),e._v("。事实上，尾触发目前应用最多的地方是Connect的中间件。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var app = connect();\n// Middleware\napp.use(connect.staticCache());\napp.use(connect.static(__dirname + '/public'));\napp.use(connect.cookieParser());\napp.use(connect.session());\napp.use(connect.query());\napp.use(connect.bodyParser());\napp.use(connect.csrf());\napp.listen(3001); \n")])])]),t("p",[e._v("在通过use()方法注册好一系列中间件后，监听端口上的请求。中间件利用了尾触发的机制，\n最简单的中间件如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function (req, res, next) {\n // 中间件\n} \n")])])]),t("p",[e._v("每个中间件传递请求对象、响应对象和尾触发函数，通过队列形成一个处理流\n"),t("img",{attrs:{src:"/images/node/%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%80%9A%E8%BF%87%E9%98%9F%E5%88%97%E5%BD%A2%E6%88%90%E4%B8%80%E4%B8%AA%E5%A4%84%E7%90%86%E6%B5%81.png",alt:""}})]),e._v(" "),t("p",[e._v("中间件机制使得在处理网络请求时，可以像面向切面编程一样进行过滤、验证、日志等功能，而不与具体业务逻辑产生关联，以致产生耦合。\nConnect的核心实现")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function createServer() {\n  // 创建了HTTP服务器的request事件处理函数：\n function app(req, res){ app.handle(req, res); }\n utils.merge(app, proto);\n utils.merge(app, EventEmitter.prototype);\n app.route = '/';\n // stack属性是这个服务器内部维护的中间件队列。通过调用use()方法我们可以将中间件放进队列中\n app.stack = [];\n for (var i = 0; i < arguments.length; ++i) {\n app.use(arguments[i]);\n }\n return app;\n};\n")])])]),t("p",[e._v("use()方法的重要部分")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("app.use = function(route, fn){\n // some code\n this.stack.push({ route: route, handle: fn });\n return this;\n")])])]),t("p",[e._v("监听函数的实现如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("app.listen = function(){\n var server = http.createServer(this);\n return server.listen.apply(server, arguments);\n};\n")])])]),t("p",[e._v("最终回到app.handle()方法，每一个监听到的网络请求都将从这里开始处理。该方法的代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("app.handle = function(req, res, out) {\n // some code\n next();\n}; \n")])])]),t("p",[e._v("原始的next()方法较为复杂，下面是简化后的内容，其原理十分简单，取出队列中的中间件并执行，同时传入当前方法以实现递归调用，达到持续触发的目的：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function next(err) {\n // some code\n // next callback\n layer = stack[index++];\n layer.handle(req, res, next);\n} \n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[e._v("流程控制模块async")])]),e._v(" "),t("ul",[t("li",[e._v("异步的串行执行\nasync是如何解决“恶魔金字塔”问题的。\nasync提供了series()方法来实现一组任务的串行执行，示例代码如下：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var fs = require('fs');\nvar async = require(\"async\");\nasync.series([\n function (callback) {\n fs.readFile('file1.txt', 'utf-8', callback);\n },\n function (callback) {\n fs.readFile('file2.txt', 'utf-8', callback);\n }\n], function (err, results) {\n // results => [file1.txt, file2.txt]\n}); \n")])])]),t("p",[e._v("这段代码等价于:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var fs = require('fs');\nvar async = require(\"async\");\nfs.readFile('file1.txt', 'utf-8', function (err, content) {\n if (err) {\n return callback(err);\n }\n fs.readFile('file2.txt ', 'utf-8', function (err, data) {\n if (err) {\n return callback(err);\n }\n callback(null, [content, data]);\n });\n}); \n")])])]),t("p",[e._v("series()方法中传入的函数callback()并非由使用者指定。事实上，此处的回调函数由async通过高阶函数的方式注入，这里隐含了特殊的逻辑。每个callback()执行时会将结果保存起来，然后执行下一个调用，直到结束所有调用。最终\n的回调函数执行时，队列里的异步调用保存的结果以数组的方式传入。这里的异常处理规则是一\n旦出现异常，就结束所有调用，并将异常传递给最终回调函数的第一个参数。")]),e._v(" "),t("ul",[t("li",[e._v("异步的并行执行\n当我们需要通过并行来提升性能时，async提供了parallel()方法，用以并行执行一些异步操作。以下为读取两个文件的并行版本：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("async.parallel([\n function (callback) {\n fs.readFile('file1.txt', 'utf-8', callback);\n },\n function (callback) {\n fs.readFile('file2.txt', 'utf-8', callback);\n }\n], function (err, results) {\n // results => [file1.txt, file2.txt]\n});\n")])])]),t("p",[e._v("等价于:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var counter = 2;\nvar results = [];\nvar done = function (index, value) {\n results[index] = value;\n counter--;\n if (counter === 0) {\n callback(null, results);\n }\n};\n// 只传递第一个异常\nvar hasErr = false;\nvar fail = function (err) {\n if (!hasErr) {\n hasErr = true;\n callback(err);\n }\n};\nfs.readFile('file1.txt', 'utf-8', function (err, content) {\n if (err) {\n return fail(err);\n }\n done(0, content);\n});\nfs.readFile('file2.txt', 'utf-8', function (err, data) {\n if (err) {\n return fail(err);\n }\n done(1, data);\n});\n")])])]),t("ul",[t("li",[e._v("异步调用的依赖处理\nseries()适合无依赖的异步串行执行，但当前一个的结果是后一个调用的输入时，series()方法就无法满足需求了。所幸，这种典型场景的需求，async提供了"),t("code",[e._v("waterfall()")]),e._v("方法来满足，相关代码如下：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("async.waterfall([\n function (callback) {\n fs.readFile('file1.txt', 'utf-8', function (err, content) {\n callback(err, content);\n });\n },\n function (arg1, callback) {\n // arg1 => file2.txt\n fs.readFile(arg1, 'utf-8', function (err, content) {\n callback(err, content);\n });\n },\n function(arg1, callback){\n // arg1 => file3.txt\n fs.readFile(arg1, 'utf-8', function (err, content) {\n callback(err, content);\n });\n }\n], function (err, result) {\n // result => file4.txt\n});\n")])])]),t("p",[e._v("等价于:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("fs.readFile('file1.txt', 'utf-8', function (err, data1) {\n if (err) {\n return callback(err);\n }\n fs.readFile(data1, 'utf-8', function (err, data2) {\n if (err) {\n return callback(err);\n }\n fs.readFile(data2, 'utf-8', function (err, data3) {\n if (err) {\n return callback(err);\n }\n callback(null, data3);\n });\n });\n}); \n")])])]),t("ul",[t("li",[e._v("自动依赖处理(auto)\nauto()方法能根据依赖关系自动分析，以最佳的顺序执行以上业务：\nasync.auto(deps);")])]),e._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[e._v("Step\nStep与前面介绍的事件模式、Promise甚至async都不同的一点在于Step用到了this关键字。事实上，它是Step内部的一个next()方法，将异步调用的结果传递给下一个任务作为参数，并调用执行。\n通过npm install step即可安装使用。示例代码如下")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Step(task1, task2, task3);\n")])])]),t("p",[e._v("Step接受任意数量的任务，所有的任务都将会串行依次执行。下面的示例代码将依次读取文件：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Step(\n function readFile1() {\n fs.readFile('file1.txt', 'utf-8', this);\n },\n function readFile2(err, content) {\n fs.readFile('file2.txt', 'utf-8', this);\n },\n function done(err, content) {\n console.log(content);\n }\n);\n")])])]),t("ul",[t("li",[e._v("并行任务执行\nStep如何实现多个异步任务并行执行呢？this具有一个parallel()方法，它告诉Step，需要等所有任务完成时才进行下一个任务，相关代码如下：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Step(\n function readFile1() {\n fs.readFile('file1.txt', 'utf-8', this.parallel());\n fs.readFile('file2.txt', 'utf-8', this.parallel());\n },\n function done(err, content1, content2) {\n // content1 => file1\n // content2 => file2\n console.log(arguments);\n }\n);\n")])])]),t("p",[e._v("使用parallel()的时候需要小心的是，如果异步方法的结果传回的是多个参数，Step将只会取前两个参数，相关代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var asyncCall = function (callback) {\n process.nextTick(function () {\n // 在调用parallel()时，result2将会被丢弃。\n callback(null, 'result1', 'result2');\n });\n};\n")])])]),t("p",[e._v("Step提供的另外一个方法是group()，它类似于parallel()的效果，但是在结果传递上略有不同。下面的代码用于读取一个目录，然后迭代其中文件的操作：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Step(\n function readDir() {\n fs.readdir(__dirname, this);\n },\n function readFiles(err, results) {\n if (err) throw err;\n // Create a new group\n var group = this.group();\n results.forEach(function (filename) {\n if (/\\.js$/.test(filename)) {\n fs.readFile(__dirname + \"/\" + filename, 'utf8', group());\n }\n });\n },\n function showAll(err, files) {\n if (err) throw err;\n console.dir(files);\n }\n); \n")])])]),t("p",[e._v("有两次group()的调用。第一次调用是告知Step要并行执行，第二次调用的结果将会生成一个回调函数，而回调函数接受的返回值将会按组存储。parallel()传递给下一个任务的结果是如下形式：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function (err, result1, result2, ...);\n")])])]),t("p",[e._v("group()传递的结果是：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function (err, results);\n")])])]),t("p",[e._v("这个函数返回的数据保存在数组中。")]),e._v(" "),t("h3",{attrs:{id:"异步并发控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异步并发控制"}},[e._v("#")]),e._v(" 异步并发控制")]),e._v(" "),t("p",[e._v("在Node中，我们可以十分方便地利用异步发起并行调用。使用下面的代码，我们可以轻松发起100次异步调用：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("for (var i = 0, i < 100; i++) {\n async();\n}\n")])])]),t("p",[e._v("但是如果并发量过大，我们的下层服务器将会吃不消。如果是对文件系统进行大量并发调用，操作系统的文件描述符数量将会被瞬间用光，抛出如下错误：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Error: EMFILE, too many open files\n")])])]),t("h4",{attrs:{id:"async的解决方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#async的解决方案"}},[e._v("#")]),e._v(" async的解决方案")]),e._v(" "),t("p",[e._v("async也提供了一个方法用于处理异步调用的限制：parallelLimit()。如下是async的示例代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("async.parallelLimit([\n function (callback) {\n fs.readFile('file1.txt', 'utf-8', callback);\n },\n function (callback) {\n fs.readFile('file2.txt', 'utf-8', callback);\n }\n], 1, function (err, results) {\n // TODO\n}); \n")])])]),t("p",[e._v("parallelLimit()与parallel()类似，但多了一个用于限制并发数量的参数，使得任务只能同时并发一定数量，而不是无限制并发。")])])}),[],!1,null,null,null);n.default=r.exports}}]);