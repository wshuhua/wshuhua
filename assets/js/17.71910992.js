(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{469:function(_,v,p){"use strict";p.r(v);var t=p(28),e=Object(t.a)({},(function(){var _=this,v=_.$createElement,p=_._self._c||v;return p("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[p("h3",{attrs:{id:"_1-cpu"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#_1-cpu"}},[_._v("#")]),_._v(" 1. CPU")]),_._v(" "),p("p",[_._v("cpu 每个核只有一个线程，也就是单控制流、单数据流。这样的架构导致 cpu 在一些场景下效率是不高的，比如 3d 渲染的场景。")]),_._v(" "),p("h3",{attrs:{id:"_2-3d-渲染流程"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#_2-3d-渲染流程"}},[_._v("#")]),_._v(" 2. 3d 渲染流程")]),_._v(" "),p("p",[_._v("3d 的渲染首先是建立 3d 的模型，它由一系列三维空间中的顶点构成，3 个顶点构成一个三角形，然后所有的顶点构成的三角形拼接起来就是 3d 模型。")]),_._v(" "),p("p",[_._v("顶点、三角形，这是 3d 的基础。3d 引擎首先要计算顶点数据，确定 3d 图形的形状。之后还要对每个面进行贴图，可以在每个三角形画上不同的纹理。")]),_._v(" "),p("p",[_._v("3d 渲染的流程是：")]),_._v(" "),p("ul",[p("li",[_._v("计算顶点数据，构成 3d 的图形")]),_._v(" "),p("li",[_._v("给每个三角形贴图，画上纹理")]),_._v(" "),p("li",[_._v("投影到二维的屏幕，计算每个像素的颜色（光栅化）")]),_._v(" "),p("li",[_._v("把一帧的数据写入显存的帧缓冲区")])]),_._v(" "),p("p",[_._v("顶点的数量是非常庞大的，而 "),p("code",[_._v("cpu")]),_._v(" 只能顺序的一个个计算，所以处理这种"),p("code",[_._v("3d")]),_._v("渲染会特别费劲，于是就出现了专门用于这种 3d 数据的并行计算的硬件，也就是 "),p("code",[_._v("GPU")]),_._v("。")]),_._v(" "),p("h3",{attrs:{id:"_3-gpu-的构成"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#_3-gpu-的构成"}},[_._v("#")]),_._v(" 3. GPU 的构成")]),_._v(" "),p("p",[_._v("和 cpu 的一个一个数据计算不同，gpu 是并行的，有成百上千个核心用于并行计算。")]),_._v(" "),p("p",[p("code",[_._v("gpu")]),_._v(" 是"),p("code",[_._v("单控制流多数据流")]),_._v("的，而 "),p("code",[_._v("cpu")]),_._v(" 是"),p("code",[_._v("单控制流单数据流")]),_._v("。")]),_._v(" "),p("p",[_._v("所以，对于 3d 渲染这种要计算成万个顶点数据和像素点的场景，GPU 会比 CPU 高效很多。")]),_._v(" "),p("h3",{attrs:{id:"_4-cpu-和-gpu-的区别"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#_4-cpu-和-gpu-的区别"}},[_._v("#")]),_._v(" 4. CPU 和 GPU 的区别")]),_._v(" "),p("p",[_._v("cpu 是通用的，能够执行各种逻辑和运算，而 gpu 则是主要是用于"),p("code",[_._v("并行计算大批量的重复任务")]),_._v("，"),p("code",[_._v("不能处理复杂逻辑")]),_._v("。")]),_._v(" "),p("p",[_._v("cpu 中控制器和缓存占据了很大一部分，而 gpu 中这两部分则很少，但是有更多的核心用于计算")]),_._v(" "),p("h3",{attrs:{id:"_5-opengl、webgl、css-硬件加速"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#_5-opengl、webgl、css-硬件加速"}},[_._v("#")]),_._v(" 5. opengl、webgl、css 硬件加速")]),_._v(" "),p("p",[_._v("显卡中集成了"),p("code",[_._v("gpu")]),_._v("，提供了驱动，使用 "),p("code",[_._v("gpu")]),_._v(" 能力需要使用驱动的"),p("code",[_._v("api")]),_._v("。 "),p("code",[_._v("gpu")]),_._v(" 的 "),p("code",[_._v("api")]),_._v(" 有一套开源标准叫做 "),p("code",[_._v("opengl")]),_._v("，有三百多个函数，用于各种图形的绘制。")]),_._v(" "),p("p",[_._v("我们在网页中绘制 3d 图形是使用 webgl 的 api，而浏览器在实现 webgl 的时候也是基于 opengl 的 api，最终会驱动 gpu 进行渲染。")]),_._v(" "),p("p",[_._v("浏览器在处理下面的 css 的时候，会使用 gpu 渲染：")]),_._v(" "),p("ul",[p("li",[_._v("transform")]),_._v(" "),p("li",[_._v("opacity")]),_._v(" "),p("li",[_._v("filter")]),_._v(" "),p("li",[_._v("will-change（实验性质）")])]),_._v(" "),p("p",[_._v("浏览器是把内容分到不同的图层分别渲染的，最后合并到一起，而触发 "),p("code",[_._v("gpu")]),_._v(" 渲染会新建一个图层，把该元素样式的计算交给 "),p("code",[_._v("gpu")]),_._v("。")]),_._v(" "),p("ul",[p("li",[_._v("opacity 需要改变每个像素的值，符合重复且大量的特点，会新建图层，交给 "),p("code",[_._v("gpu")]),_._v(" 渲染。")]),_._v(" "),p("li",[_._v("transform 是动画，每个样式值的计算也符合重复且大量的特点，也默认会使用 gpu 加速。同理 fiter 也是一样。")])]),_._v(" "),p("div",{staticClass:"custom-block tip"},[p("p",{staticClass:"custom-block-title"},[_._v("提示")]),_._v(" "),p("p",[_._v("注意的是 gpu 硬件加速是需要新建图层的，而把该元素移动到新图层是个耗时操作，界面可能会闪一下，所以最好提前做。will-change 就是提前告诉浏览器在一开始就把元素放到新的图层，方便后面用 gpu 渲染的时候，不需要做图层的新建。")])]),_._v(" "),p("p",[_._v("gpu 硬件加速能减轻 cpu 压力，使得渲染更流畅，但是也会增加内存的占用，对于 transform、opacity、filter 默认会开启硬件加速。其余情况，建议只在必要的时候用。")])])}),[],!1,null,null,null);v.default=e.exports}}]);