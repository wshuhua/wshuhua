(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{518:function(a,e,t){"use strict";t.r(e);var s=t(28),r=Object(s.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h3",{attrs:{id:"_01-简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_01-简介"}},[a._v("#")]),a._v(" 01. 简介")]),a._v(" "),t("p",[a._v("three.js 是使用javascript来写3D程序。\n在浏览器端，WebGL 是一个底层的标准，在这些标准被定义后，Chrome、Firefox 之类的浏览器 实现了这些标准。然后，就能通过javascript 代码，在网页上实现 三维图形的渲染。 ThreeJS则是封装了底层了图形接口，更容易来实现3D程序。")]),a._v(" "),t("h4",{attrs:{id:"核心"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#核心"}},[a._v("#")]),a._v(" 核心")]),a._v(" "),t("p",[a._v("一个 典型的three.js  程序 至少需要包括 渲染器（Renderer），场景（Scene），照相机（Camera），以及你在场景中创建的物体。")]),a._v(" "),t("h5",{attrs:{id:"渲染器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#渲染器"}},[a._v("#")]),a._v(" 渲染器")]),a._v(" "),t("p",[a._v("渲染器将和canvas 元素 进行绑定，如果在HTML中手动定义了canvas元素，那么Renderer 可以这样写")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var renderer = new THREE.WebGLRenderer({canvas: document.getElementById('#mainCanvas')});\n")])])]),t("p",[a._v("如果想在Three.js生成Canvas元素，在HTML中就不需要定义canvas元素，在javascript代码中可以这样写")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var renderer = new THREE.WebGLRenderer();\nrender.setSize(400, 400);\n")])])]),t("h5",{attrs:{id:"场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#场景"}},[a._v("#")]),a._v(" 场景")]),a._v(" "),t("p",[a._v("在Three.js 中添加的物体 都是添加到场景中的，因此它相当于一个大容器。在程序最开始的时候进行实例化，然后将物体添加到场景中。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var scene = new THREE.Scene();\n")])])]),t("p",[a._v("也就是说 ，场景是光源，相机和所有物体的父容器，通过："),t("code",[a._v("scene.children")]),a._v("可以访问到这些子物体。这些物体在创建的时候没有名字，可以通过"),t("code",[a._v("name")]),a._v(" 属性指定名字，这样就可以通过："),t("code",[a._v("scene.getChildByMName(name)")]),a._v("来访问具体夫人子物体。")]),a._v(" "),t("p",[t("code",[a._v("scene.traverse(funtion)")]),a._v(" 可以访问 该父场景中的所有子物体来执行回调函数。")]),a._v(" "),t("h5",{attrs:{id:"相机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#相机"}},[a._v("#")]),a._v(" 相机")]),a._v(" "),t("p",[a._v("WebGL 和Three.js 使用的坐标系 是右手坐标系，即右手伸开，拇指为X，四指为Y，手心为Z。")]),a._v(" "),t("p",[a._v("相机就像是人的眼睛一样，人站在不同的位置，抬头或者低头都能够看到不同的景色。在Threejs中有多种相机，透视相机（"),t("code",[a._v("THREE.PerspectiveCamera")]),a._v("）用的最多。")]),a._v(" "),t("p",[a._v("定义：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var camera = new THRRR.PerspectiveCamera(45, 4 / 3, 1, 1000);\n")])])]),t("p",[a._v("注意： 相机也需要添加到场景中。")]),a._v(" "),t("h4",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),t("p",[a._v("Three.js 中的场景是一个物体的容器，开发者将需要的物体放入场景中。相机的作用就是指向场景，在场景中取一个合适的景，把它拍下来。 渲染器的作用就是 将相机拍摄下来的照片 放到浏览器显示。在定义了场景中的物体，设置好的照相机以后，渲染器就知道 如何让渲染出二维的结果。这个时候，只需要调用渲染器的渲染函数，就能使其渲染一次。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("renderer.render(scene, camera);\n")])])]),t("h4",{attrs:{id:"照相机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#照相机"}},[a._v("#")]),a._v(" 照相机")]),a._v(" "),t("p",[a._v("根据投影方式的不同，照相机又分为正交投影相机 和透视投影相机。使用透视投影照相机 获得的结果 是类似人眼看到的 有 ‘近大远小’的效果，而使用正交投影照相机 得到的结果就像是平面画3D的效果，在三维空间内平行的线，投影到二维空间中也一定是平行的。")]),a._v(" "),t("h5",{attrs:{id:"正交投影照相机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#正交投影照相机"}},[a._v("#")]),a._v(" 正交投影照相机")]),a._v(" "),t("p",[a._v("正交投影照相机的构造函数是：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("THREE.OrthographicCamera(left, right, top, bottom, near, far)\n")])])]),t("p",[a._v("这六个参数分别代表正交投影照相机拍摄到的空间的六个面的位置，其为视景体（Frustum）。只有在视景体内部的物体才可能显示在屏幕上，而视景体外的物体 会在显示之前 被裁减掉。\n为了保持照相机的横竖比例，需要保持（right - left）和（top - bottom）的比例与Canvas 宽度和高度的比例一致。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var camera = new THREE.OrthographicCamera(-2, 2, 1.5, -1.5, 1, 1000);\ncamera.position.set(0, 0, 5);\nscene.add(camera);\n")])])]),t("p",[a._v("其中，第二句是设定照相机的位置。照相机默认都是沿 z 轴负方向观察的，可以通过 lookAt 函数指定它看着其他方向：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("camera.lookAt(new THREE.Vector3(0, 0, 0));\n")])])]),t("p",[a._v("这样就改变照相机观察方向由当前位置指向原点。注意， lookAt 函数接受的是一个 THREE.Vector3 的实例。")]),a._v(" "),t("h5",{attrs:{id:"透视投影相机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#透视投影相机"}},[a._v("#")]),a._v(" 透视投影相机")]),a._v(" "),t("p",[a._v("透视投影是更符合人眼视觉的投影，构造函数是：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("PerspectiveCamera( fov, aspect, near, far )\n")])])]),t("ul",[t("li",[t("p",[a._v("fov: 为视角的大小。如果设置为0,相当你闭上眼睛了,所以什么也看不到,如果为180,那么可以认为你的视界很广阔,但是在180度的时候，往往物体很小，因为他在你的整个可视区域中的比例变小了。")])]),a._v(" "),t("li",[t("p",[a._v("aspect: 为实际窗口的纵横比，即宽度除以高度。通常设为Canvas 的横纵比例。")])]),a._v(" "),t("li",[t("p",[a._v("near: 摄像机视锥体近端面")])]),a._v(" "),t("li",[t("p",[a._v("far: 摄像机视锥体远端面")])])]),a._v(" "),t("h4",{attrs:{id:"形状"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#形状"}},[a._v("#")]),a._v(" 形状")]),a._v(" "),t("p",[a._v("threejs封装了一些常见的几何形状，在使用时，就只需要定义threejs设定好需要的值即可，如果想要自定义形状，就需要手动创造顶点和面。")]),a._v(" "),t("h4",{attrs:{id:"立方体"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#立方体"}},[a._v("#")]),a._v(" 立方体")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("THREE.CubeGeometry(width, height, depth, widthSegments, heightSegments, depthSegments)\n")])])]),t("p",[a._v("这里，width 是x方向上的长度，height 是y方向上的长度，depth是z方向上的长度，后三个参数分别是三个方向上的分段数，如widthSegments 为3的话，代表x方向上水平分为三份。一般情况下不需要分段的话，可以不设置后三个参数，后三个参数的默认值为1。\n如："),t("code",[a._v("new THREE.CubeGEometry(1,2,3);")]),a._v(" 可以创建一个x方向 长度为1，y方向长度为2，z方向长度为3的立方体。")]),a._v(" "),t("p",[a._v("物体的几何中心默认在原点的位置。若设置了分段，会对六个面 进行分段，而不是对立方体进行分段，因此在立方体的中间是不分段的，只有六个侧面被分段。")]),a._v(" "),t("h4",{attrs:{id:"平面"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#平面"}},[a._v("#")]),a._v(" 平面")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("THREE.PlanGeometry(width, height, widthSegments, heightSegments)\n")])])]),t("p",[a._v("width 是x方向上的长度，height 是y方向的长度， 后两个参数 同样 表示分段数。")]),a._v(" "),t("h4",{attrs:{id:"球体"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#球体"}},[a._v("#")]),a._v(" 球体")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("THREE.SphereGeometry(radius, segmentsWidth, segmentsHeight, phiStart, phiLength, thetaStart, thetaLength)\n")])])]),t("ul",[t("li",[a._v("radius 是半径")]),a._v(" "),t("li",[a._v("segmentsWidth 表示经度上的切片数")]),a._v(" "),t("li",[a._v("segmentsHeight 表示 纬度上的切片数")]),a._v(" "),t("li",[a._v("phiStart 表示 经度开始的弧度")]),a._v(" "),t("li",[a._v("phiLength 表示 经度跨过的弧度；")]),a._v(" "),t("li",[a._v("thetaStart 表示纬度开始的弧度")]),a._v(" "),t("li",[a._v("thetaLength 表示纬度跨国的弧度。\n使用 "),t("code",[a._v("var sphere = new THREE.SphereGeometry(3, 8, 6)")]),a._v(" 可以创建一个 半径为3， 经度划分为8份，纬度划分为6份的球体。")])]),a._v(" "),t("p",[a._v("segmentsWidth 相当于经度被切成了几瓣，而 segmentsHeight 相当于纬度被切成了几层。对于球\n体而言，当这两个值较大的时候，形成的多面体就可以近似看做是球体了。")]),a._v(" "),t("h4",{attrs:{id:"圆形"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#圆形"}},[a._v("#")]),a._v(" 圆形")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("THREE.CircleGemetry(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded)\n")])])]),t("p",[a._v("其中， radiusTop 与radiusBottom 分别是顶面与底面的半径，由此可知，当这两个 参数设置为不同的值时，实际上创建的是一个圆台，height是圆柱体的高度，radiusSegments 与hegithSegments 可类比球体中的分段，openEnded是一个布尔值，表示是否咩有顶点和底面，默认为false，表示有顶面和底面。")]),a._v(" "),t("h4",{attrs:{id:"圆环"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#圆环"}},[a._v("#")]),a._v(" 圆环")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("THREE.TorusGemetry(radius, tube, radialSegments, tubularSegments, arc)\n")])])]),t("p",[a._v("其中， radius 是圆环半径；tube 是管道半径； radialSegments 与 tubularSegments 分\n别是两个分段数； arc 是圆环面的弧度，默认为 Math.PI * 2 。")]),a._v(" "),t("h3",{attrs:{id:"材质"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#材质"}},[a._v("#")]),a._v(" 材质")]),a._v(" "),t("p",[a._v("材质（Material）是与渲染相关的属性。通过设置材质可以改变物体的颜色、纹理贴图、光照模式等。材质的共有属性包括：")]),a._v(" "),t("ul",[t("li",[a._v("基础属性")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("id: 用来标识材质\nname：赋予材质名称\nopaticy：定义物体透明度，取值范围：0 ～ 1\nside：设定在几何体的哪个面应用材质，默认值为THREE.FrontSide,即外面。也可以设置为THREE.BackSide(内面) 或者THREE.DoubleSide(双面)\n")])])]),t("h4",{attrs:{id:"基本材质"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本材质"}},[a._v("#")]),a._v(" 基本材质")]),a._v(" "),t("p",[a._v("用基本材质（BasicMaterial） 的物体渲染后的颜色适中为该材质的颜色，不会由于光照 产生明暗，阴影的效果。如果没有指定材质的颜色，则颜色是随机的。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("THREE.MeshBasicMaterial({color: 0xffff00, opacity: 0.75})\n")])])]),t("p",[a._v("其中，opt 为包括各属性的值。如新建一个不透明的0.75的黄色材质")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("new THREE.MeshBasicMaterial({color: 0xffff00, opacity: 0.75})\n")])])]),t("p",[a._v("常用的属性包括：")]),a._v(" "),t("ul",[t("li",[a._v("visible：是否可见，默认为true")]),a._v(" "),t("li",[a._v("side：渲染面片正面或是反面，默认为正面THREE.FrontSide, 可设置为反面THREE.BackSide, 或双面THREE.DoubleSide")]),a._v(" "),t("li",[a._v("wireframe: 是否渲染线而非面，默认为false")]),a._v(" "),t("li",[a._v("color：十六进制RGB颜色，如红色：0xffff00")]),a._v(" "),t("li",[a._v("map：使用纹理贴图")])]),a._v(" "),t("h4",{attrs:{id:"lambert-材质"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lambert-材质"}},[a._v("#")]),a._v(" Lambert 材质")]),a._v(" "),t("p",[a._v("Lambert 光照模型的主要特点是只考虑漫反射而不考虑镜面反射的效果，因而对于金属，镜子等需要镜面反射效果的物体就不适应，对于其他物体等我的漫反射效果都是适用的。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("new THREE.MeshLamberMaterial(opt)\n")])])]),t("p",[a._v("color 是用来表现材质对散射光的反射能力，也是最常用来设置材质颜色的属性。除此之外，还可以用ambient和emissive 控制材质的颜色。")]),a._v(" "),t("p",[a._v("ambient 表示对环境光的反射能力，只有当设置了AmbientLight后，该值才是有效的，材质对环境光的反射能力与环境光强相乘后的到材质实际表现的颜色。")]),a._v(" "),t("p",[a._v("emissive是材质的自发光颜色，可以用来表现光源的颜色。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("new THREE.MeshLamberMaterial({color: 0xfffff00, emissive: 0xff0000})\n")])])]),t("h4",{attrs:{id:"phong-材质"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#phong-材质"}},[a._v("#")]),a._v(" Phong 材质")]),a._v(" "),t("p",[a._v("Phone 模型开绿了镜面反射的效果，因此对于金属，镜面反射的表现尤为合适。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("new THREE.MeshPhoneMaterial(opt)\n")])])]),t("p",[a._v("可以通过shininess 属性控制光照模型中的n值，当shininess 值越大时，高光的光斑越小，默认值为30")]),a._v(" "),t("p",[a._v("使用黄色的镜面光，红色的散射光")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("new THREE.MeshPhoneMaterial({color: 0xff0000, specular: 0xffff00, shininess: 100})\n")])])]),t("h4",{attrs:{id:"depth-材质"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#depth-材质"}},[a._v("#")]),a._v(" Depth 材质")]),a._v(" "),t("p",[a._v("这种材质的特点在于，不控制物体的渲染效果，外光根据物体到相机的距离变化，一般与其他材质结合形成远处逐渐消失的效果。")]),a._v(" "),t("h4",{attrs:{id:"联合材质"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#联合材质"}},[a._v("#")]),a._v(" 联合材质")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var depthMaterial = new THREE.MeshDepthMaterial;\nvar bacsicMaterial = new THREE.MeshBasicMaterial(opt);\nvar cube = new THREE.SceneUtils.createMaterialObject(cubeGeometry, [depthMaterial, basicMaterial]);\ncube.children[1].scale.set(0.99, 0.99, 0.99);\n")])])]),t("p",[a._v("对于要融合的材质，需要添加属性transparent: true 开启融合模式。\ncreateMaterialObject() 创建网格时，几何体会被复制，返回一个网格组，内部的网格完全一样。渲染时 画面回闪烁。所以需要最后一行代码来缩小带有depth材质的网格，避免出现闪烁。")]),a._v(" "),t("h4",{attrs:{id:"物体"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#物体"}},[a._v("#")]),a._v(" 物体")]),a._v(" "),t("p",[a._v("使用几何形状和材质就能创建物体了。最常见的一种物体就是网格（Mesh），网格是由顶点，边，面等组成的物体，其他物体包括线段（Line），骨骼（Bone），粒子系统（ParticleSystem）等。\n创建物体需要指定几何形状和材质，其中，几何形状决定了物体的顶点位置等信息，材质决定了物体的颜色，和纹理等信息。")]),a._v(" "),t("h4",{attrs:{id:"创建网格"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建网格"}},[a._v("#")]),a._v(" 创建网格")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Mesh(geometry, material)\n")])])]),t("p",[a._v("创建网格要把几何形状与材质传入其构造函数。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var material = new THREE.MeshLamberMaterial({color: oxffff00});\nvar geometry = new THREE.CubeGeometry(1, 2, 3);\nvar mesh = new THREE.Mesh(geometry, material);\nscene.add(mesh);\n")])])]),t("p",[a._v("若不设置属性material, 则每次会随机分配一种wireframe 为true的材质，每次刷新页面后的颜色时不同的。除了在构造函数中指定材质，在网格被创建后，也能对材质进行修改。")]),a._v(" "),t("h4",{attrs:{id:"几何变换"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#几何变换"}},[a._v("#")]),a._v(" 几何变换")]),a._v(" "),t("p",[a._v("平移，缩放，旋转时物体三个常用的属性，即为translate，scale，rotate三个属性。")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("平移\nmesh.translateX(100) // 沿着x轴正方向平移距离100\nvar axis = new THREE.Vector(0, 1, 0); // 创建一个三维向量，xyz分量分别为0, 1, 0\nmesh.translateOnAxis(axis, 100); // 沿着向量axis 方向平移 100")])]),a._v(" "),t("li",[t("p",[a._v("缩放\nmesh.scale.x = 2.0 // x轴方向放大2倍\nmesh.scale.set(0.5, 0.5, 0.5) // 缩小为原来的0.5倍")])])]),a._v(" "),t("h3",{attrs:{id:"加载几何模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#加载几何模型"}},[a._v("#")]),a._v(" 加载几何模型")]),a._v(" "),t("p",[a._v("THREE.js 有一系列导入外部文件的辅助函数，是在three.js 之外的，使用前需要额外下载。 "),t("em",[a._v(".obj 是最常用的模型格式，导入")]),a._v(".obj 需要OBJLoader.js; 导入带.mtl材质的.obj 文件需要MTLLoader.js 以及 OBJMTLLoaderjs.")]),a._v(" "),t("h4",{attrs:{id:"无材质模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#无材质模型"}},[a._v("#")]),a._v(" 无材质模型")]),a._v(" "),t("p",[a._v("创建loader变量，用于导入模型：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var loader = new THREE.OBJLoader();\n")])])]),t("p",[a._v("接收两个参数： 第一个：模型路径 第二个：表示完成导入后的回调函数，一般我们需要在这个回调函数中将导入的模型添加到场景中。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("loader.load('../lib/port.obj', function(obj){mesh = obj; // 储存到全局变量中scene.add(obj)})\n")])])]),t("p",[a._v("默认的情况下，只有正面的面片被绘制，模型中部分可能穿模。而如果需要双面绘制，需要这样设置：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var loader = new THREE.OBJLoader();\nloader.load('../lib/port.obj', function(obj){\n  obj.traverse(function(child){\n    if (child instanceof THREE.Mesh) {\n      child.material.side = THREE.DoubleSide;\n    }\n  });\n  mesh = obj;\n  scene.add(obj)\n})\n")])])]),t("h3",{attrs:{id:"光线"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#光线"}},[a._v("#")]),a._v(" 光线")]),a._v(" "),t("h4",{attrs:{id:"环境光"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#环境光"}},[a._v("#")]),a._v(" 环境光")])])}),[],!1,null,null,null);e.default=r.exports}}]);