(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{502:function(_,v,t){"use strict";t.r(v);var a=t(28),s=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"_1-宏观视角下的浏览器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-宏观视角下的浏览器"}},[_._v("#")]),_._v(" 1. 宏观视角下的浏览器")]),_._v(" "),t("h3",{attrs:{id:"_1-1-chrome架构演变史"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-chrome架构演变史"}},[_._v("#")]),_._v(" 1.1 Chrome架构演变史")]),_._v(" "),t("h4",{attrs:{id:"单进程浏览器时代"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单进程浏览器时代"}},[_._v("#")]),_._v(" 单进程浏览器时代：")]),_._v(" "),t("p",[_._v("单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等")]),_._v(" "),t("p",[_._v("如此多的功能模块运行在一个进程里，导致单进程浏览器不稳定、不流畅和不安全的一个主要因素。")]),_._v(" "),t("ul",[t("li",[_._v("不稳定")])]),_._v(" "),t("p",[_._v("早期浏览器需要借助于插件来实现诸如 Web 视频、Web 游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。")]),_._v(" "),t("p",[_._v("除了插件之外，渲染引擎模块也是不稳定的，通常一些复杂的 JavaScript 代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃。")]),_._v(" "),t("ul",[t("li",[_._v("不流畅")])]),_._v(" "),t("p",[_._v("所有页面的渲染模块、JavaScript 执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。")]),_._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[_._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("function")]),_._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[_._v("freeze")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("{")]),_._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("while")]),_._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[_._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("{")]),_._v("\n    console"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[_._v("log")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[_._v('"freeze"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("}")]),_._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("}")]),_._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[_._v("freeze")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n")])])]),t("p",[_._v("如果让这个脚本运行在一个单进程浏览器的页面里 会导致什么？")]),_._v(" "),t("p",[_._v("因为浏览器中所有的页面都运行在该线程中，所以这些页面都没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。")]),_._v(" "),t("p",[_._v("除了上述脚本或者插件会让单进程浏览器变卡顿外，页面的内存泄漏也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢。")]),_._v(" "),t("ul",[t("li",[_._v("不安全")])]),_._v(" "),t("p",[_._v("插件可以使用 C/C++ 等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也就意味着这个插件能完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。至于页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。")]),_._v(" "),t("h4",{attrs:{id:"多进程浏览器时代"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多进程浏览器时代"}},[_._v("#")]),_._v(" 多进程浏览器时代")]),_._v(" "),t("p",[_._v("早期多进程架构：")]),_._v(" "),t("p",[t("img",{attrs:{src:"/images/js/chrome1.png",alt:""}})]),_._v(" "),t("p",[_._v("Chrome早期多进程架构，由插件进程、渲染进程和主进程组成，进程之间由 IPC进行通信")]),_._v(" "),t("ul",[t("li",[_._v("由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就解决了页面或者插件的崩溃会导致整个浏览器崩溃。")])]),_._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[_._v("多进程架构也会出现一个页面崩溃影响到其他页面的情况")]),_._v(" "),t("p",[_._v('通常情况下是一个页面使用一个进程，但是，有一种情况，叫"同一站点(same-site)"。')]),_._v(" "),t("p",[_._v("具体地讲，我们将“同一站点”定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：")]),_._v(" "),t("ul",[t("li",[_._v("https://time.geekbang.org")]),_._v(" "),t("li",[_._v("https://www.geekbang.org")]),_._v(" "),t("li",[_._v("https://www.geekbang.org:8080")])]),_._v(" "),t("p",[_._v("都是属于同一站点，因为它们的协议都是https，而根域名也都是geekbang.org。")]),_._v(" "),t("p",[_._v("Chrome的默认策略是：每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫"),t("code",[_._v("process-per-site-instance")]),_._v("。 直白的讲，就是如果几个页面符合同一站点，那么他们将被分配到一个渲染进程里面去。 所以，这种情况下，一个页面崩溃了，会导致同一站点的页面同时崩溃，因为他们使用了同一个渲染进程。 为什么要让他们跑在一个进程里面呢？ 因为在一个渲染进程里面，他们就会共享JS的执行环境，也就是说A页面可以直接在B页面中执行脚本。因为是同一家的站点，所以是有这个需求的。")])]),_._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[_._v("同一站点和同源策略区别")])]),_._v(" "),t("ul",[t("li",[t("p",[_._v("内存泄漏的解决方法: 因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。")])]),_._v(" "),t("li",[t("p",[_._v("安全问题解决：使用安全沙箱。可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。")])])]),_._v(" "),t("h4",{attrs:{id:"目前多进程架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#目前多进程架构"}},[_._v("#")]),_._v(" 目前多进程架构")]),_._v(" "),t("p",[t("img",{attrs:{src:"/images/js/chrome2.png",alt:""}})]),_._v(" "),t("p",[_._v("最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("浏览器主进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。")])]),_._v(" "),t("li",[t("p",[_._v("渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，"),t("code",[_._v("排版引擎 Blink")]),_._v(" 和 "),t("code",[_._v("JavaScript 引擎 V8")]),_._v(" 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。")])]),_._v(" "),t("li",[t("p",[_._v("GPU进程：Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。")])]),_._v(" "),t("li",[t("p",[_._v("网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。")])]),_._v(" "),t("li",[t("p",[_._v("插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。")])])]),_._v(" "),t("h4",{attrs:{id:"优点-缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优点-缺点"}},[_._v("#")]),_._v(" 优点/缺点")]),_._v(" "),t("p",[_._v("多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：")]),_._v(" "),t("ul",[t("li",[_._v("更高的资源占用。因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。")]),_._v(" "),t("li",[_._v("更复杂的体系架构。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。")])]),_._v(" "),t("p",[_._v("对于上面这两个问题，Chrome 团队一直在寻求一种弹性方案，既可以解决资源占用高的问题，也可以解决复杂的体系架构的问题。")]),_._v(" "),t("h4",{attrs:{id:"未来面向服务的架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#未来面向服务的架构"}},[_._v("#")]),_._v(" 未来面向服务的架构")]),_._v(" "),t("p",[_._v("为了解决这些问题，在 2016 年，Chrome 官方团队使用“面向服务的架构”（Services Oriented Architecture，简称 SOA）的思想设计了新的 Chrome 架构。也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、高速、安全的目标。")]),_._v(" "),t("p",[_._v("通俗来说就是以前是每个页面需要若干进程完成各自的工作，现在是将各个页面通用的功能（视频、网络、渲染等）发布为系统服务，页面在需要的时候与相应的服务通信完成需要的功能。这起码把进程间的耦合从页面中分离出去了。")]),_._v(" "),t("p",[_._v("Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务")]),_._v(" "),t("p",[t("img",{attrs:{src:"/images/js/chrome3.png",alt:""}})]),_._v(" "),t("p",[_._v("Chrome 还提供灵活的弹性架构，在强大性能设备上会以多进程的方式运行基础服务，但是如果在资源受限的设备上（如下图），Chrome 会将很多服务整合到一个进程中，从而节省内存占用。")]),_._v(" "),t("ul",[t("li",[_._v("在资源不足的设备上，将服务合并到浏览器进程中")])]),_._v(" "),t("p",[t("img",{attrs:{src:"/images/js/chrome4.png",alt:""}})]),_._v(" "),t("p",[_._v("早期浏览器：\n不稳定（单独进程）\n不流畅（单独进程）\n不安全（沙箱）")]),_._v(" "),t("p",[_._v("早期多进程架构：\n主进程 渲染进程 插件进程")]),_._v(" "),t("p",[_._v("现代多进程架构：\n主进程 渲染进程 插件进程 GPU进程 网络进程")]),_._v(" "),t("p",[_._v("未来：\n面向服务架构")]),_._v(" "),t("h2",{attrs:{id:"_2-tcp协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-tcp协议"}},[_._v("#")]),_._v(" 2. TCP协议")]),_._v(" "),t("p",[_._v("性能指标:")]),_._v(" "),t("ul",[t("li",[t("ol",[t("li",[_._v("FP(First Paint):从开始加载到浏览器首次绘制像素到屏幕上的时间,也就是页面在屏幕上首次发生视觉变化的时间。")])])]),_._v(" "),t("li",[t("ol",{attrs:{start:"2"}},[t("li",[_._v("FCP（First Contentful Paint）:浏览器首次绘制来自 DOM 的内容的时间。这是用户第一次开始看到页面内容，但仅仅有内容，并不意味着它是有用的内容（例如 Header、导航栏等），也不意味着有用户要消费的内容。")])])]),_._v(" "),t("li",[t("ol",{attrs:{start:"3"}},[t("li",[_._v("FMP（First Meaningful Paint）:页面的主要内容绘制到屏幕上的时间。主要内容的定义因页面而异，例如对于博客文章，它的主要内容是标题和摘要，对于搜索页面，它的主要内容是搜索结果，对于电商的页面，图片则是主要内容。")])])]),_._v(" "),t("li",[t("ol",{attrs:{start:"4"}},[t("li",[_._v("FSP（First Screen Paint）:页面从开始加载到首屏内容全部绘制完成的时间，用户可以看到首屏的全部内容。")])])]),_._v(" "),t("li",[t("ol",{attrs:{start:"5"}},[t("li",[_._v("TTI（Time to Interactive）:表示网页第一次完全达到可交互状态的时间点，浏览器已经可以持续性的响应用户的输入。")])])])]),_._v(" "),t("p",[_._v("互联网中的数据是通过数据包来传输的。如果发送的数据很大，那么该数据就会被拆分为很多小数据包来传输。比如你现在听的音频数据，是拆分成一个个小的数据包来传输的，并不是一个大的文件一次传输过来的。")]),_._v(" "),t("ul",[t("li",[_._v("IP：把数据包送达目的主机")])]),_._v(" "),t("p",[_._v("IP协议把数据分解为数据包，打包时加上本机的Ip地址，称为"),t("code",[_._v("ip头数据")]),_._v("，通过物理底层传输出去。数据包的构成："),t("code",[_._v("数据部分+IP头部分")]),_._v("。\n"),t("img",{attrs:{src:"/images/js/ip.png",alt:""}})]),_._v(" "),t("ol",[t("li",[_._v("上层将含有“极客时间”的数据包交给网络层；")]),_._v(" "),t("li",[_._v("网络层再将 IP 头附加到数据包上，组成新的 IP 数据包，并交给底层；")]),_._v(" "),t("li",[_._v("底层通过物理网络将数据包传输给主机 B；")]),_._v(" "),t("li",[_._v("数据包被传输到主机 B 的网络层，在这里主机 B 拆开数据包的 IP 头信息，并将拆开来的数据部分交给上层；")]),_._v(" "),t("li",[_._v("最终，含有“极客时间”信息的数据包就到达了主机 B 的上层了。")])]),_._v(" "),t("h4",{attrs:{id:"udp-把数据包送达应用程序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#udp-把数据包送达应用程序"}},[_._v("#")]),_._v(" UDP：把数据包送达应用程序")]),_._v(" "),t("p",[_._v("“用户数据包协议（User Datagram Protocol）”，简称 UDP。")]),_._v(" "),t("p",[_._v("UDP 中一个最重要的信息是端口号，端口号其实就是一个数字，每个想访问网络的程序都需要绑定一个端口号。通过端口号 "),t("code",[_._v("UDP")]),_._v(" 就能把指定的数据包发送给指定的程序了，所以 "),t("code",[_._v("IP")]),_._v(" 通过 "),t("code",[_._v("IP")]),_._v(" 地址信息把数据包发送给指定的电脑，而 "),t("code",[_._v("UDP")]),_._v(" 通过端口号把数据包分发给正确的程序。和 "),t("code",[_._v("IP")]),_._v(" 头一样，端口号会被装进"),t("code",[_._v("UDP")]),_._v(" 头里面，"),t("code",[_._v("UDP")]),_._v(" 头再和原始数据包合并组成新的 "),t("code",[_._v("UDP")]),_._v(" 数据包。"),t("code",[_._v("UDP")]),_._v(" 头中除了目的端口，还有源端口号等信息。")]),_._v(" "),t("p",[t("img",{attrs:{src:"/images/js/udp.png",alt:""}})]),_._v(" "),t("ul",[t("li",[_._v("上层将含有“极客时间”的数据包交给传输层；")]),_._v(" "),t("li",[_._v("传输层会在数据包前面附加上 UDP 头，组成新的 UDP 数据包，再将新的 UDP 数据包交给网络层；")]),_._v(" "),t("li",[_._v("网络层再将 IP 头附加到数据包上，组成新的 IP 数据包，并交给底层；")]),_._v(" "),t("li",[_._v("数据包被传输到主机 B 的网络层，在这里主机 B 拆开 IP 头信息，并将拆开来的数据部分交给传输层；")]),_._v(" "),t("li",[_._v("在传输层，数据包中的 UDP 头会被拆开，并根据 UDP 中所提供的端口号，把数据部分交给上层的应用程序；")]),_._v(" "),t("li",[_._v("最终，含有“极客时间”信息的数据包就旅行到了主机 B 上层应用程序这里。")])]),_._v(" "),t("h4",{attrs:{id:"udp优-缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#udp优-缺点"}},[_._v("#")]),_._v(" UDP优/缺点")]),_._v(" "),t("p",[_._v("在使用 UDP 发送数据时，有各种因素会导致数据包出错，虽然 UDP 可以校验数据是否正确，但是对于错误的数据包，UDP 并不提供"),t("code",[_._v("重发机制")]),_._v("，只是丢弃当前的包，而且 UDP 在发送之后也无法知道是否能达到目的地。")]),_._v(" "),t("p",[_._v("UDP 不能保证数据可靠性，但是传输速度却非常快，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。")]),_._v(" "),t("h4",{attrs:{id:"tcp-把数据完整地送达应用程序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-把数据完整地送达应用程序"}},[_._v("#")]),_._v(" TCP：把数据完整地送达应用程序")]),_._v(" "),t("p",[_._v("UDP缺点：")]),_._v(" "),t("ul",[t("li",[_._v("数据包在传输过程中容易丢失；")]),_._v(" "),t("li",[_._v("大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件。")])]),_._v(" "),t("p",[t("code",[_._v("TCP")]),_._v("（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。相对于 UDP，TCP 有下面两个特点:")]),_._v(" "),t("ul",[t("li",[_._v("对于数据包丢失的情况，TCP 提供"),t("code",[_._v("重传机制")]),_._v("；")]),_._v(" "),t("li",[_._v("TCP 引入了"),t("code",[_._v("数据包排序机制")]),_._v("，用来保证把乱序的数据包组合成一个完整的文件。")])]),_._v(" "),t("p",[_._v("和UDP 头一样，TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。")]),_._v(" "),t("p",[t("img",{attrs:{src:"/images/js/TCP.png",alt:""}})]),_._v(" "),t("p",[_._v("与UDP不同的地方在于，通过 TCP 头的信息保证了一块大的数据传输的完整性。")]),_._v(" "),t("p",[_._v("互联网中的数据是通过数据包来传输的，数据包在传输过程中容易丢失或出错。IP 负责把数据包送达目的主机。\nUDP 负责把数据包送达具体应用。\n而 TCP 保证了数据完整地传输，它的连接可分为三个阶段：建立连接、传输数据和断开连接 三个阶段。")]),_._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[_._v("TCP传送数据时 浏览器端就做渲染处理了么？如果前面数据包丢了 后面数据包先来是要等么？类似的那种实时渲染怎么处理？针对数据包的顺序性？")]),_._v(" "),t("p",[_._v("接收到http响应头中的content-type类型时就开始准备渲染进程了，响应体数据一旦接受到便开始做DOM解析了！基于http不用担心数据包丢失的问题，因为丢包和重传都是在tcp层解决的。http能保证数据按照顺序接收的（也就是说，从tcp到http的数据就已经是完整的了，即便是实时渲染，如果发生丢包也得在重传后才能开始渲染）")])]),_._v(" "),t("h2",{attrs:{id:"_3-http请求流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-http请求流程"}},[_._v("#")]),_._v(" 3. HTTP请求流程")]),_._v(" "),t("p",[t("code",[_._v("HTTP")]),_._v(" 是一种允许浏览器向服务器获取资源的协议，是 "),t("code",[_._v("Web")]),_._v(" 的基础，通常由浏览器发起请求，用来获取不同类型的文件，例如 "),t("code",[_._v("HTML")]),_._v(" 文件、"),t("code",[_._v("CSS")]),_._v(" 文件、"),t("code",[_._v("JavaScript")]),_._v(" 文件、图片、视频等。此外，HTTP 也是浏览器使用最广的协议。")]),_._v(" "),t("h4",{attrs:{id:"浏览器端发起-http-请求流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器端发起-http-请求流程"}},[_._v("#")]),_._v(" 浏览器端发起 HTTP 请求流程")]),_._v(" "),t("p",[_._v("如果在浏览器地址栏里输入某个网站的地址，浏览器会完成哪些动作呢？")]),_._v(" "),t("ol",[t("li",[_._v("构建请求\n浏览器构建请求行信息（如下所示），构建好后，浏览器准备发起网络请求。")])]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("GET /index.html HTTP1.1\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[t("p",[_._v("查找缓存\n当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。")])]),_._v(" "),t("li",[t("p",[_._v("准备 IP 地址和端口")])])]),_._v(" "),t("p",[_._v("浏览器使用 HTTP 协议作为应用层协议，用来封装请求的文本信息；并使用 TCP/IP 作传输层协议将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。也就是说 HTTP 的内容是通过 TCP 的传输数据阶段来实现的")]),_._v(" "),t("p",[t("img",{attrs:{src:"/images/js/tcp+http.png",alt:""}})]),_._v(" "),t("ul",[t("li",[_._v("DNS解析")])]),_._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[t("ol",{attrs:{start:"4"}},[t("li",[_._v("等待 TCP 队列")])])])]),_._v(" "),t("p",[_._v("Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。")]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("http/1.1: 一个tcp同时只能处理一个请求，浏览器会为每个域名维护6个tcp连接！ 但是每个tcp连接是可以复用的，也就是处理完一个请求之后，不断开这个tcp连接，可以用来处理下个http请求！ \nhttp2: 可以并行请求资源的，所以如果使用http2，浏览器只会为每个域名维护一个tcp连接\n")])])]),t("ol",{attrs:{start:"5"}},[t("li",[t("p",[_._v("建立 TCP 连接")])]),_._v(" "),t("li",[t("p",[_._v("发送 HTTP 请求")])])]),_._v(" "),t("p",[_._v("浏览器会向服务器发送请求行，它包括了请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议。")]),_._v(" "),t("h4",{attrs:{id:"服务器端处理-http-请求流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#服务器端处理-http-请求流程"}},[_._v("#")]),_._v(" 服务器端处理 HTTP 请求流程")]),_._v(" "),t("ol",[t("li",[_._v("返回请求")])]),_._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[_._v("curl "),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v("-")]),_._v("i  https"),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v(":")]),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v("/")]),t("span",{pre:!0,attrs:{class:"token regex"}},[t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[_._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[_._v("time.geekbang.org")]),t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[_._v("/")])]),_._v("\n")])])]),t("p",[t("img",{attrs:{src:"/images/js/data.png",alt:""}})]),_._v(" "),t("p",[_._v("服务器会返回响应行，包括协议版本和状态码。")]),_._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[_._v("断开连接")])]),_._v(" "),t("p",[_._v("通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：")]),_._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token literal-property property"}},[_._v("Connection")]),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v(":")]),_._v("Keep"),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v("-")]),_._v("Alive \n")])])]),t("p",[_._v("那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。")]),_._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[_._v("重定向")])]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("curl -I geekbang.org\n")])])]),t("p",[_._v("状态码301，从响应头的Location内容中取出重定向地址。")]),_._v(" "),t("p",[t("img",{attrs:{src:"/images/js/location.png",alt:""}})]),_._v(" "),t("p",[_._v("-I表示只需要获取响应头和响应行数据，而不需要获取响应体的数据\n-i是为了返回响应行、响应头和响应体的数据")]),_._v(" "),t("p",[_._v("HTTP 请求示意图:\n"),t("img",{attrs:{src:"/images/js/httpLoop.png",alt:""}})]),_._v(" "),t("p",[_._v("浏览器中的 HTTP 请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备 IP 和端口(DNS)、等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器返回请求和断开连接。")]),_._v(" "),t("h2",{attrs:{id:"_4-导航流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-导航流程"}},[_._v("#")]),_._v(" 4. 导航流程")]),_._v(" "),t("p",[_._v("从输入URL到页面展示，这中间发生了什么？")]),_._v(" "),t("p",[t("img",{attrs:{src:"/images/js/render.png",alt:""}})]),_._v(" "),t("ul",[t("li",[t("p",[_._v("浏览器主要负责用户交互，子进程管理和文件存储等功能。")])]),_._v(" "),t("li",[t("p",[_._v("网络进程是面向渲染进程和浏览器进程等提供网络下载功能。")])]),_._v(" "),t("li",[t("p",[_._v("渲染进程的主要职责是把从网络下载的HTML，JavaScript，CSS，图片等资源解析为可以显示和交互的页面。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信息的。所以chrome采用安全沙箱模式。")])]),_._v(" "),t("li",[t("p",[_._v("首先，浏览器进程接收到用户输入的 URL 请求，浏览器进程便将该 URL 转发给网络进程。")])]),_._v(" "),t("li",[t("p",[_._v("然后，在网络进程中发起真正的 URL 请求。")])]),_._v(" "),t("li",[t("p",[_._v("接着网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。")])]),_._v(" "),t("li",[t("p",[_._v("浏览器进程接收到网络进程的响应头数据之后，发送“提交导航 (CommitNavigation)”消息到渲染进程；")])]),_._v(" "),t("li",[t("p",[_._v("渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立"),t("code",[_._v("数据管道")]),_._v("；")])]),_._v(" "),t("li",[t("p",[_._v("最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”。浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态。")])])]),_._v(" "),t("ol",[t("li",[_._v("从输入 URL 到页面展示")])]),_._v(" "),t("p",[_._v("当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的 URL。如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。如果判断输入内容符合 URL 规则，比如输入的是 "),t("code",[_._v("time.geekbang.org")]),_._v("，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL.")]),_._v(" "),t("p",[_._v("当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 "),t("code",[_._v("beforeunload")]),_._v(" 事件的机会，(beforeunload事件可以在跳转前执行一些逻辑，或者取消跳转)")]),_._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[_._v("URL 请求过程")])]),_._v(" "),t("p",[_._v("接下来，便进入了页面资源请求过程。这时，浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("首先，网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。这请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。")])]),_._v(" "),t("li",[t("p",[_._v("然后利用 IP 地址和服务器建立 TCP 连接（如果请求协议是 HTTPS，那么还需要建立 TLS 连接）。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。")])]),_._v(" "),t("li",[t("p",[_._v("服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了")])]),_._v(" "),t("li",[t("p",[_._v("（1）重定向")])])]),_._v(" "),t("p",[_._v("在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 "),t("code",[_._v("301")]),_._v(" 或者 "),t("code",[_._v("302")]),_._v("，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。")]),_._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[_._v("301/302区别")]),_._v(" "),t("p",[_._v("301:永久改变的资源位置， 302:暂时改变的资源位置")])]),_._v(" "),t("ul",[t("li",[_._v("（2）响应数据类型处理")])]),_._v(" "),t("p",[_._v("Content-Type。Content-Type 是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。")]),_._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[_._v("准备渲染进程")])]),_._v(" "),t("p",[_._v("默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中（同一站点, iframe级别的渲染进程分配）。")]),_._v(" "),t("p",[_._v("打开一个新页面采用的渲染进程策略就是：")]),_._v(" "),t("p",[_._v("通常情况下，打开新的页面都会使用单独的渲染进程；如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。")]),_._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[_._v("提交文档\n所谓提交文档，就是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程，具体流程是这样的：")])]),_._v(" "),t("ul",[t("li",[_._v("首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；")]),_._v(" "),t("li",[_._v("渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；")]),_._v(" "),t("li",[_._v("等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；")]),_._v(" "),t("li",[_._v("浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。")])]),_._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[_._v("形象描述")]),_._v(" "),t("ul",[t("li",[_._v("大哥大("),t("code",[_._v("浏览器进程")]),_._v(")接收到小弟("),t("code",[_._v("网络进程")]),_._v(")响应头数据后，通知小弟("),t("code",[_._v("渲染进程")]),_._v(")(提交文档)，让其与网络进程建立管道通讯，")]),_._v(" "),t("li",[_._v("收到大哥大的命令，小弟("),t("code",[_._v("渲染进程")]),_._v(")赶紧与小弟（"),t("code",[_._v("网络进程")]),_._v("）建立数据管道")]),_._v(" "),t("li",[_._v("渲染进程接收完网络进程的数据后，赶紧给大哥大"),t("code",[_._v("(浏览器进程)")]),_._v("汇报（确认提交）")]),_._v(" "),t("li",[_._v("大哥大知道小弟处理好琐事了，开始做小弟们做不了的事，更新"),t("code",[_._v("浏览器界面状态")]),_._v(" - 安全状态 - 地址栏 URL - 前进后退的历史状态 - 更新 Web 页面")])])]),_._v(" "),t("ol",{attrs:{start:"5"}},[t("li",[_._v("渲染阶段")])]),_._v(" "),t("p",[_._v("一旦文档被提交，渲染进程便开始页面解析和子资源加载了。")]),_._v(" "),t("ul",[t("li",[_._v("服务器可以根据响应头来控制浏览器的行为，如跳转、网络数据类型判断。")]),_._v(" "),t("li",[_._v("Chrome 默认采用每个标签对应一个渲染进程，但是如果两个页面属于同一站点，那这两个标签会使用同一个渲染进程。")]),_._v(" "),t("li",[_._v("浏览器的导航过程涵盖了从用户发起请求到提交文档给渲染进程的中间所有阶段。")])]),_._v(" "),t("p",[_._v("从输入 URL 到页面展示，这中间发生了什么 ？")]),_._v(" "),t("ol",[t("li",[_._v("用户输入url并回车")]),_._v(" "),t("li",[_._v("浏览器进程检查url，组装协议，构成完整的url")]),_._v(" "),t("li",[_._v("浏览器进程通过进程间通信（IPC）把url请求发送给网络进程")]),_._v(" "),t("li",[_._v("网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程")]),_._v(" "),t("li",[_._v("如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下：")])]),_._v(" "),t("ul",[t("li",[_._v("5.1 进行DNS解析，获取服务器ip地址，端口")]),_._v(" "),t("li",[_._v("5.2 利用ip地址和服务器建立tcp连接")]),_._v(" "),t("li",[_._v("5.3 构建请求头信息")]),_._v(" "),t("li",[_._v("5.4 发送请求头信息")]),_._v(" "),t("li",[_._v("5.5 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容")])]),_._v(" "),t("ol",{attrs:{start:"6"}},[t("li",[_._v("网络进程解析响应流程；")])]),_._v(" "),t("ul",[t("li",[_._v("6.1 检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步,如果是200，则继续处理请求。")]),_._v(" "),t("li",[_._v("6.2 200响应处理：\n检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行\n后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。")])]),_._v(" "),t("ol",{attrs:{start:"7"}},[t("li",[_._v("准备渲染进程")])]),_._v(" "),t("ul",[t("li",[_._v("7.1 浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程")])]),_._v(" "),t("ol",{attrs:{start:"8"}},[t("li",[_._v("传输数据、更新状态")])]),_._v(" "),t("ul",[t("li",[_._v("8.1 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”")]),_._v(" "),t("li",[_._v("8.2 渲染进程接收完数据后，向浏览器发送“确认提交”")]),_._v(" "),t("li",[_._v("8.3 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面。")])]),_._v(" "),t("h2",{attrs:{id:"_5-渲染流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-渲染流程"}},[_._v("#")]),_._v(" 5. 渲染流程")]),_._v(" "),t("p",[_._v("由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线")]),_._v(" "),t("ul",[t("li",[_._v("按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成")])]),_._v(" "),t("h3",{attrs:{id:"_5-1-构建-dom-树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-构建-dom-树"}},[_._v("#")]),_._v(" 5.1 构建 DOM 树")]),_._v(" "),t("p",[_._v("这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。")]),_._v(" "),t("p",[_._v("构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由 "),t("code",[_._v("HTML")]),_._v(" 解析器解析，最终输出树状结构的"),t("code",[_._v("DOM")]),_._v("。")]),_._v(" "),t("h3",{attrs:{id:"_5-2-样式计算-recalculate-style"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-样式计算-recalculate-style"}},[_._v("#")]),_._v(" 5.2 样式计算（Recalculate Style）")]),_._v(" "),t("ol",[t("li",[_._v("把 CSS 转换为浏览器能够理解的结构\nCSS 样式来源主要有三种：")])]),_._v(" "),t("ul",[t("li",[_._v("通过 link 引用的外部 CSS 文件")]),_._v(" "),t("li"),_._v(" "),t("li",[_._v("元素的 style 属性内嵌的 CSS")])]),_._v(" "),t("p",[_._v("当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets(cssom树)。")]),_._v(" "),t("h3",{attrs:{id:"_5-3-布局阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-布局阶段"}},[_._v("#")]),_._v(" 5.3 布局阶段")]),_._v(" "),t("p",[_._v("Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。")]),_._v(" "),t("ul",[t("li",[_._v("创建布局树\n"),t("ul",[t("li",[_._v("遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；")]),_._v(" "),t("li",[_._v("而不可见的节点会被布局树忽略掉")])])]),_._v(" "),t("li",[_._v("布局计算")])]),_._v(" "),t("h3",{attrs:{id:"_5-4-分层"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-分层"}},[_._v("#")]),_._v(" 5.4 分层")]),_._v(" "),t("p",[_._v("渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）")]),_._v(" "),t("p",[_._v("通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层")]),_._v(" "),t("p",[_._v("渲染引擎为特定的节点创建新的图层:")]),_._v(" "),t("p",[_._v("渲染引擎会为节点创建新的图层：")]),_._v(" "),t("ol",[t("li",[_._v("拥有层叠上下文属性的元素 层叠上下文属性：明确定位属性的元素，定义透明属性的元素，使 用css滤镜元素，设置z-index属性的元素")]),_._v(" "),t("li",[_._v("需要裁剪的地方")])]),_._v(" "),t("h3",{attrs:{id:"_5-5-图层绘制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-图层绘制"}},[_._v("#")]),_._v(" 5.5 图层绘制")]),_._v(" "),t("p",[_._v("可以打开“开发者工具”的“Layers”标签，选择“document”层，来实际体验下绘制列表，如下图所示：")]),_._v(" "),t("p",[t("img",{attrs:{src:"/images/js/layer.png",alt:""}})]),_._v(" "),t("p",[_._v("区域 1 就是 document 的绘制列表，拖动区域 2 中的进度条可以重现列表的绘制过程。")]),_._v(" "),t("h3",{attrs:{id:"_5-6-栅格化-raster-操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-6-栅格化-raster-操作"}},[_._v("#")]),_._v(" 5.6 栅格化（raster）操作")]),_._v(" "),t("p",[_._v("绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。你可以结合下图来看下渲染主线程和合成线程之间的关系：\n"),t("img",{attrs:{src:"/images/js/raster.png",alt:""}})]),_._v(" "),t("p",[_._v("当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程")]),_._v(" "),t("p",[_._v("在有些情况下，有的图层可以很大，比如有的页面要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要")]),_._v(" "),t("p",[_._v("基于这个原因，合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512")]),_._v(" "),t("p",[t("img",{attrs:{src:"/images/js/tile.png",alt:""}})]),_._v(" "),t("ul",[t("li",[_._v("合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行。")]),_._v(" "),t("li",[_._v("栅格化：指讲图块转化为位图；")]),_._v(" "),t("li",[_._v("图块是栅格化的最小单位，渲染进程维护了一个栅格化线程池，所有的图块栅格化都是在栅格化线程池内执行；\n"),t("img",{attrs:{src:"/images/js/raster1.png",alt:""}})])]),_._v(" "),t("p",[_._v("栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。\n"),t("img",{attrs:{src:"/images/js/GPU_raster.png",alt:""}})]),_._v(" "),t("h4",{attrs:{id:"_5-7-合成和显示"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-7-合成和显示"}},[_._v("#")]),_._v(" 5.7 合成和显示")]),_._v(" "),t("p",[_._v("一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——"),t("code",[_._v("DrawQuad")]),_._v("，然后将该命令提交给浏览器进程。")]),_._v(" "),t("p",[_._v("浏览器进程里面有一个叫 "),t("code",[_._v("viz")]),_._v(" 的组件，用来接收合成线程发过来的 "),t("code",[_._v("DrawQuad")]),_._v(" 命令，然后根据 "),t("code",[_._v("DrawQuad")]),_._v("命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。")]),_._v(" "),t("p",[_._v("整体渲染：\n"),t("img",{attrs:{src:"/images/js/render_all.png",alt:""}})]),_._v(" "),t("ul",[t("li",[_._v("渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。")]),_._v(" "),t("li",[_._v("渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。")]),_._v(" "),t("li",[_._v("创建布局树，并计算元素的布局信息。对布局树进行分层，并生成分层树。")]),_._v(" "),t("li",[_._v("为每个图层生成绘制列表，并将其提交到合成线程。")]),_._v(" "),t("li",[_._v("合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。")]),_._v(" "),t("li",[_._v("合成线程发送绘制图块命令 DrawQuad 给浏览器进程。")]),_._v(" "),t("li",[_._v("浏览器进程根据 "),t("code",[_._v("DrawQuad")]),_._v(" 消息生成页面，并显示到显示器上。")])]),_._v(" "),t("p",[_._v("“重排”“重绘”和“合成”:")]),_._v(" "),t("p",[t("strong",[_._v("重排")]),_._v(": 更新元素的几何属性,重排需要更新完整的渲染流水线\n"),t("strong",[_._v("重绘")]),_._v(": 更新元素的绘制属性,重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。\n"),t("strong",[_._v("合成")]),_._v(": CSS3 transform,避开重排和重绘阶段，直接在非主线程上执行合成动画操作,相对于重绘和重排，合成能大大提升绘制效率。")]),_._v(" "),t("p",[_._v("减少重排重绘, 方法如下：")]),_._v(" "),t("ol",[t("li",[_._v("使用 class 操作样式，而不是频繁操作 style")]),_._v(" "),t("li",[_._v("避免使用 table 布局")]),_._v(" "),t("li",[_._v("批量dom 操作，例如 createDocumentFragment，或者使用框架，例如 React")]),_._v(" "),t("li",[_._v("Debounce window resize 事件")]),_._v(" "),t("li",[_._v("对 dom 属性的读写要分离")]),_._v(" "),t("li",[_._v("will-change: transform 做优化")])]),_._v(" "),t("h2",{attrs:{id:"_6-浏览器下的执行机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-浏览器下的执行机制"}},[_._v("#")]),_._v(" 6. 浏览器下的执行机制")]),_._v(" "),t("h3",{attrs:{id:"_6-1-变量提升"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-变量提升"}},[_._v("#")]),_._v(" 6.1 变量提升")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("JavaScript 代码的执行流程")])]),_._v(" "),t("li",[t("p",[_._v("1.编译阶段： JS代码在正式执行前会先进行编译，在此过程中会生成执行上下文和可执行代码。所谓执行上下文就是一段JS代码的执行环境。在执行上下文中会创建一个变量环境对象，JS引擎在遇到var声明的变量或者function声明的函数时，会在该环境对象中创建一个与变量或函数同名的属性保存undefined或函数在堆中的地址。其他声明以外的代码，JS引擎会将其编译为字节码。（对于let声明的变量保存在执行上下文的词法环境中） 。\n函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量赋值之后覆盖。")])]),_._v(" "),t("li",[t("p",[_._v("2.执行阶段： 按照顺序一行一行的执行可执行代码，遇到变量或者函数，会去变量环境对象中去查找，当执行过程中遇到变量赋值则会将结果更新到环境对象中。")])])]),_._v(" "),t("h3",{attrs:{id:"_6-2-调用栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-调用栈"}},[_._v("#")]),_._v(" 6.2 调用栈")]),_._v(" "),t("ul",[t("li",[_._v("每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码。")]),_._v(" "),t("li",[_._v("如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。")]),_._v(" "),t("li",[_._v("当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。")]),_._v(" "),t("li",[_._v("当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。")])])])}),[],!1,null,null,null);v.default=s.exports}}]);