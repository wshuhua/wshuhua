(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{482:function(e,t,r){"use strict";r.r(t);var _=r(28),v=Object(_.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h3",{attrs:{id:"_1-浏览器内核"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-浏览器内核"}},[e._v("#")]),e._v(" 1. 浏览器内核")]),e._v(" "),r("p",[e._v("浏览器引擎指的是浏览器的排版引擎（layout engine），也称为浏览器引擎（brower engine），页面渲染引擎（rendering engine）或样板引擎。")]),e._v(" "),r("p",[e._v("浏览器内核可以分为两部分：")]),e._v(" "),r("ul",[r("li",[e._v("渲染引擎： 负责获取网页的内容并显示，不同的浏览器内核对网页的解析渲染也不同")]),e._v(" "),r("li",[e._v("js引擎： 负责解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果")])]),e._v(" "),r("p",[e._v("目前主流的四大内核有：")]),e._v(" "),r("ul",[r("li",[e._v("Gecko: 早期被Netscape和Mozilia Firefox浏览器使用")]),e._v(" "),r("li",[e._v("Trident:微软开发,被IE4~IE11浏览器使用,但是Edge浏览器已经转向Blink")]),e._v(" "),r("li",[e._v("Webkit: 苹果基于KHTML开发,开源的,用于Safari,Goole Chrome之前也在使用Webkit引擎包含WebCore排版引擎及JavaScriptCore解析引擎）")]),e._v(" "),r("li",[e._v("Blink: 是Webkit的一个分支,Google开发,目前应用于Google Chorme,Edge,Opera等")])]),e._v(" "),r("h3",{attrs:{id:"_2-浏览器工作原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-浏览器工作原理"}},[e._v("#")]),e._v(" 2. 浏览器工作原理")]),e._v(" "),r("p",[r("img",{attrs:{src:"/images/js/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png",alt:""}})]),e._v(" "),r("p",[e._v("浏览器输入url（也就是域名）访问一个网站的时候,首先通过DNS服务器解析成对应的IP地址,浏览器第一次会拿到该网站的index.html,在解析这个html文件的时候,如果遇到link标签css文件,又会从服务器下载该css文件,如果遇到script标签javascript文件,同样也会从服务器下载该js文件。")]),e._v(" "),r("h3",{attrs:{id:"_3-浏览器渲染过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-浏览器渲染过程"}},[e._v("#")]),e._v(" 3. 浏览器渲染过程")]),e._v(" "),r("p",[r("img",{attrs:{src:"/images/js/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B.png",alt:""}})]),e._v(" "),r("ul",[r("li",[e._v("当浏览器拿到index.html文件的时候,浏览器内核的"),r("code",[e._v("HTML Parser")]),e._v("转成DOM树")]),e._v(" "),r("li",[e._v("此时javascript也可以进行一些DOM操作(createElement等等),也会被转换成DOM树")]),e._v(" "),r("li",[e._v("css文件也会被浏览器内核的"),r("code",[e._v("CSS Parser")]),e._v("进行解析,生成的"),r("code",[e._v("Style Rules")]),e._v("会跟DOM树 "),r("code",[e._v("Attachment")]),e._v(" 在一起")]),e._v(" "),r("li",[e._v("通过"),r("code",[e._v("Layout")]),e._v("布局后,从而生成"),r("code",[e._v("Render Tree")]),e._v("(渲染树)")]),e._v(" "),r("li",[e._v("最后进行"),r("code",[e._v("Painting")]),e._v("元素绘制,最终"),r("code",[e._v("Display")]),e._v("进行展示.")])]),e._v(" "),r("h4",{attrs:{id:"_3-1-构建dom树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-构建dom树"}},[e._v("#")]),e._v(" 3.1 构建DOM树")]),e._v(" "),r("p",[e._v("当浏览器客户端从服务器那接受到HTML文档后，就会遍历文档节点然后生成DOM树，DOM树结构和HTML标签一一对应。需要注意记下几点：")]),e._v(" "),r("ul",[r("li",[e._v("DOM树在构建的过程中可能会被CSS和JS的加载而执行阻塞。")]),e._v(" "),r("li",[e._v("display:none 的元素也会在DOM树中。")]),e._v(" "),r("li",[e._v("注释也会在DOM树中")]),e._v(" "),r("li",[e._v("script标签会在DOM树中")])]),e._v(" "),r("h4",{attrs:{id:"_3-2-css解析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-css解析"}},[e._v("#")]),e._v(" 3.2 CSS解析")]),e._v(" "),r("p",[e._v("浏览器会解析CSS文件并生成CSS规则树，在过程中，每个CSS文件都会被分析成StyleSheet对象，每个对象都包括CSS规则，CSS规则对象包括对应的选择器和声明对象以及其他对象。\n在这个过程需要注意的是：")]),e._v(" "),r("ul",[r("li",[e._v("CSS解析可以与DOM解析同进行。")]),e._v(" "),r("li",[e._v("CSS解析与script的执行互斥 。")]),e._v(" "),r("li",[e._v("在Webkit内核中进行了script执行优化，只有在JS访问CSS时才会发生互斥。")])]),e._v(" "),r("h4",{attrs:{id:"_3-3-构建渲染树-rendr-tree-construction"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-构建渲染树-rendr-tree-construction"}},[e._v("#")]),e._v(" 3.3 构建渲染树（Rendr tree construction）")]),e._v(" "),r("p",[e._v("通过DOM树和CSS规则树，浏览器就可以通过这两个构建渲染树了。浏览器会先从DOM树的根节点开始遍历每个可见节点，让后对每个可见节点找到适配的CSS样式规则并应用。具体的规则有以下几点需要注意：")]),e._v(" "),r("ul",[r("li",[e._v("Render Tree和DOM Tree不完全对应。")]),e._v(" "),r("li",[e._v("display: none的元素不在Render Tree中")]),e._v(" "),r("li",[e._v("visibility: hidden的元素在Render Tree中")])]),e._v(" "),r("h4",{attrs:{id:"_3-4-渲染树布局-layout-of-the-render-tree"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-渲染树布局-layout-of-the-render-tree"}},[e._v("#")]),e._v(" 3.4 渲染树布局(layout of the render tree)")]),e._v(" "),r("p",[e._v("布局阶段会从渲染树的更节点开始遍历，由于渲染树的每个节点都是一个Render Object对象，包含宽高，位置，背景色等样式信息。所以浏览器就可以通过这些样式信息来确定每个节点对象在页面上的确切大小和位置，布局阶段的输出就是我们常说的盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。需要注意的是：")]),e._v(" "),r("ul",[r("li",[e._v("float元素，absoulte元素，fixed元素会发生位置偏移。")]),e._v(" "),r("li",[e._v("我们常说的脱离文档流，其实就是脱离Render Tree。")])]),e._v(" "),r("h4",{attrs:{id:"_3-5-渲染树绘制-painting-the-render-tree"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-渲染树绘制-painting-the-render-tree"}},[e._v("#")]),e._v(" 3.5 渲染树绘制（Painting the render tree）")]),e._v(" "),r("p",[e._v("在绘制阶段，浏览器会遍历渲染树，调用渲染器的paint()方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的UI后端组件完成的。")]),e._v(" "),r("h3",{attrs:{id:"_4-浏览器渲染网页"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-浏览器渲染网页"}},[e._v("#")]),e._v(" 4. 浏览器渲染网页")]),e._v(" "),r("h4",{attrs:{id:"_4-1-阻塞渲染"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-阻塞渲染"}},[e._v("#")]),e._v(" 4.1 阻塞渲染")]),e._v(" "),r("p",[e._v("现代浏览器总是并行加载自语言。例如当HTML解析器被脚本阻塞时，解析器虽然会停止构建DOM，但仍然会辨识该脚本后面的资源，并进行预加载。且由于以下两点。浏览器会延迟 JavaScript 的执行和 DOM 构建：")]),e._v(" "),r("ul",[r("li",[e._v("CSS 被默认被视为阻塞渲染的资源，因此浏览器将在 CSSOM 构建完毕前不会渲染任何已处理的内容。")]),e._v(" "),r("li",[e._v("JavaScript 不仅可以读取和修改 DOM 属性，还可以读取和修改 CSSOM 属性，因此CSS解析与script的执行互斥。")])]),e._v(" "),r("p",[e._v("正是由于以上这些原因，script标签的位置很重要我们在实际开发中应该尽量坚持以下两个原则：")]),e._v(" "),r("ul",[r("li",[e._v("在引入顺序上，CSS 资源先于 JavaScript 资源。")]),e._v(" "),r("li",[e._v("JavaScript 应尽量少的去影响 DOM 的构建。")])]),e._v(" "),r("h4",{attrs:{id:"_4-2-回流和重绘-reflow和repaint"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-回流和重绘-reflow和repaint"}},[e._v("#")]),e._v(" 4.2 回流和重绘（reflow和repaint）")]),e._v(" "),r("p",[e._v("我们都知道HTML默认是流式布局的，但CSS和JS会打破这种布局，改变DOM的外观样式以及大小和位置。因此我们就需要知道两个概念:")]),e._v(" "),r("ul",[r("li",[r("code",[e._v("reflow（回流）")]),e._v("：当浏览器发现某个部分发生了变化从而影响了布局，这个时候就需要倒回去重新渲染，大家称这个回退的过程叫 reflow。 常见的reflow是一些会影响页面布局的操作，诸如Tab，隐藏等。reflow 会从 html 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置，以确认是渲染树的一部分发生变化还是整个渲染树。reflow几乎是无法避免的，因为只要用户进行交互操作，就势必会发生页面的一部分的重新渲染，且通常我们也无法预估浏览器到底会reflow哪一部分的代码，因为他们会相互影响。")]),e._v(" "),r("li",[e._v("repaint（重绘）： repaint则是当我们改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸和位置没有发生改变。")])]),e._v(" "),r("p",[e._v("需要注意的是，display:none 会触发 reflow，而visibility: hidden属性则并不算是不可见属性，它的语义是隐藏元素，但元素仍然占据着布局空间，它会被渲染成一个空框，这在我们上面有提到过。所以 visibility:hidden 只会触发 repaint，因为没有发生位置变化。")]),e._v(" "),r("h5",{attrs:{id:"减少回流"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#减少回流"}},[e._v("#")]),e._v(" 减少回流")]),e._v(" "),r("p",[e._v("我们不能避免reflow，但还是能通过一些操作来减少回流：")]),e._v(" "),r("ul",[r("li",[e._v("用transform做形变和位移.")]),e._v(" "),r("li",[e._v("通过绝对位移来脱离当前层叠上下文，形成新的Render Layer。")])]),e._v(" "),r("h4",{attrs:{id:"优化渲染效率"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#优化渲染效率"}},[e._v("#")]),e._v(" 优化渲染效率")]),e._v(" "),r("ul",[r("li",[e._v("合法地去书写 HTML 和 CSS ，且不要忘了文档编码类型。")]),e._v(" "),r("li",[e._v("样式文件应当在 head 标签中，而脚本文件在 body 结束前，这样可以防止阻塞的方式。")]),e._v(" "),r("li",[e._v("简化并优化CSS选择器，尽量将嵌套层减少到最小。")]),e._v(" "),r("li",[e._v("尽量减少在 JavaScript 中进行DOM操作。")]),e._v(" "),r("li",[e._v("修改元素样式时，更改其class属性是性能最高的方法。")]),e._v(" "),r("li",[e._v("尽量用 transform 来做形变和位移")])]),e._v(" "),r("p",[r("a",{attrs:{href:"https://srtian96.gitee.io/blog/2018/06/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考"),r("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=v.exports}}]);