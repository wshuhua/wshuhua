(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{489:function(e,r,t){"use strict";t.r(r);var n=t(28),s=Object(n.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h3",{attrs:{id:"_01-旧架构-react15"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_01-旧架构-react15"}},[e._v("#")]),e._v(" 01. 旧架构（react15）")]),e._v(" "),t("p",[e._v("React15架构可以分为两层：")]),e._v(" "),t("ul",[t("li",[e._v("Reconciler（stack Reconciler 协调器）—— 负责找出变化的组件")]),e._v(" "),t("li",[e._v("Renderer（渲染器）—— 负责将变化的组件渲染到页面上")])]),e._v(" "),t("p",[t("strong",[e._v("Reconciler")]),e._v("：")]),e._v(" "),t("p",[e._v("每当有更新发生时，Reconciler会做如下工作：")]),e._v(" "),t("ul",[t("li",[e._v("调用函数组件、或class组件的render方法，将返回的JSX转化为虚拟DOM")]),e._v(" "),t("li",[e._v("将虚拟DOM和上次更新时的虚拟DOM对比（递归处理虚拟DOM的）")]),e._v(" "),t("li",[e._v("通过对比找出本次更新中变化的虚拟DOM")]),e._v(" "),t("li",[e._v("通知Renderer将变化的虚拟DOM渲染到页面上")])]),e._v(" "),t("p",[e._v("架构图如下所示：\n"),t("img",{attrs:{src:"/images/react/react15%E6%9E%B6%E6%9E%84.png",alt:""}})]),e._v(" "),t("p",[e._v("缺陷出现在 stack Reconciler 递归更新，数据放在递归的调用栈中，一旦开始，无法终止，直到遍历完整棵树，才能将主线程释放。\n如果主线程有用户操作或动画渲染操作，就必须等到主线程释放，才能被响应，无法快速响应，即失帧。")]),e._v(" "),t("h3",{attrs:{id:"_02-新架构-react16"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_02-新架构-react16"}},[e._v("#")]),e._v(" 02. 新架构（React16）")]),e._v(" "),t("p",[e._v("React16架构可以分为三层：")]),e._v(" "),t("ul",[t("li",[e._v("Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler")]),e._v(" "),t("li",[e._v("Reconciler（fiber Reconciler协调器，基于fiber节点实现的）—— 负责找出变化的组件")]),e._v(" "),t("li",[e._v("Renderer（渲染器）—— 负责将变化的组件渲染到页面上")])]),e._v(" "),t("p",[e._v("相对比15。新增了Scheduler。\n我们以浏览器是否有剩余时间作为任务中断的标准，那么我们需要一种机制，当浏览器有剩余时间时通知我们。 "),t("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback",target:"_blank",rel:"noopener noreferrer"}},[e._v("requestIdleCallback"),t("OutboundLink")],1),e._v("在浏览器空闲时期被调用。由于requestIdleCallback兼容性问题和触发频率问题，react没有采用。")]),e._v(" "),t("p",[e._v("基于上述原因，React实现了功能更完备的requestIdleCallback polyfill，就是"),t("a",{attrs:{href:"https://github.com/facebook/react/tree/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler",target:"_blank",rel:"noopener noreferrer"}},[e._v("Scheduler"),t("OutboundLink")],1),e._v(",除了在空闲时触发回调外，Scheduler还提供多种调度优先级供任务设置。")]),e._v(" "),t("p",[t("strong",[e._v("Reconciler")]),e._v("：")]),e._v(" "),t("p",[e._v("更新工作从递归变成了可以中断的循环过程。每次循环都会调用"),t("strong",[e._v("shouldYield")]),e._v("判断当前是否有剩余时间。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("/** @noinline */\nfunction workLoopConcurrent() {\n  // Perform work until Scheduler asks us to yield\n  while (workInProgress !== null && !shouldYield()) {\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n}\n")])])]),t("p",[e._v("Reconciler与Renderer不再是交替工作,当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟DOM打上代表增/删/更新的标记，类似这样")]),e._v(" "),t("p",[e._v("整个Scheduler与Reconciler的工作都在内存中进行。只有当所有组件都完成Reconciler的工作，才会统一交给Renderer。")]),e._v(" "),t("p",[e._v("架构图如下所示：\n"),t("img",{attrs:{src:"/images/react/react16%E6%9E%B6%E6%9E%84.png",alt:""}})]),e._v(" "),t("h3",{attrs:{id:"_03-fiber架构的心智模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_03-fiber架构的心智模型"}},[e._v("#")]),e._v(" 03. fiber架构的心智模型")]),e._v(" "),t("p",[e._v("神马是心智模型？")]),e._v(" "),t("p",[e._v("官方简单理解就是：它是人【主观】认识事物的方法和习惯，是隐藏在你一切行为方式、思考方式背后的那些形式和规律。")]),e._v(" "),t("p",[t("img",{attrs:{src:"/images/react/%E6%A8%A1%E5%9E%8B.png",alt:""}})]),e._v(" "),t("h3",{attrs:{id:"_04-fiber架构的实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_04-fiber架构的实现原理"}},[e._v("#")]),e._v(" 04. fiber架构的实现原理")]),e._v(" "),t("ul",[t("li",[e._v("fiber的结构")])]),e._v(" "),t("p",[e._v("react/packages/react-reconciler/src/ReactFiber.new.js")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function FiberNode(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n){\n  // 作为静态数据结构的属性\n  this.tag = tag; // 组件类型，\n  this.key = key;\n  this.elementType = null;\n  this.type = null;\n  this.stateNode = null; //真实dom节点\n\n  // 作为连接其他Fiber节点形成Fiber树\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0; // 对于同级节点，代表他们插入的位置索引\n\n  this.ref = null;\n   \n  // 作为动态的工作单元的属性\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n  this.dependencies = null;\n\n  this.mode = mode;\n\n  this.effectTag = NoEffect;\n  this.subtreeTag = NoSubtreeEffect;\n  this.deletions = null;\n  this.nextEffect = null;\n\n  this.firstEffect = null;\n  this.lastEffect = null;\n  \n  // 调度优先级相关\n  this.lanes = NoLanes;\n  this.childLanes = NoLanes;\n\n  // 指向该Fiber在另一次更新时对应的Fiber\n  this.alternate = null;  // fiber 架构的工作方式\n  ...\n}\n")])])]),t("ul",[t("li",[e._v("作为架构来说")])]),e._v(" "),t("p",[e._v("每个fiber 节点有个对应的React Element，多个fiber 节点依赖下面三个属性连接：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("this.return = null;  // 指向父级Fiber节点\n\nthis.child = null; // 指向子Fiber节点\n\nthis.sibling = null; // 指向右边第一个兄弟Fiber节点\n")])])]),t("p",[e._v("举例说明：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function App() {\n  return (\n    <div>\n      wsh\n      <span>age: 18</span>\n    </div>\n  )\n}\n")])])]),t("p",[e._v("对应的fiber树如下：")]),e._v(" "),t("ul",[t("li",[e._v("作为静态数据结构：")])]),e._v(" "),t("p",[e._v("作为静态的数据结构，保存了组件相关信息")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("this.tag = tag; // Fiber对应组件的类型 Function/Class/Host...\n\nthis.key = key; // key属性\n\nthis.elementType = null; // 大部分情况同type，某些情况不同，比如FunctionComponent使用React.memo包裹\n\nthis.type = null; // 对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagName\n\nthis.stateNode = null; // Fiber对应的真实DOM节点\n")])])]),t("ul",[t("li",[e._v("作为动态的工作单元:")])]),e._v(" "),t("p",[e._v("作为动态的工作单元，Fiber中下面参数保存了本次更新相关的信息")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 保存本次更新造成的状态变化相关信息\nthis.pendingProps = pendingProps;\nthis.menoizedProps = null;\nthis.updateQueue = null;\nthis.memoizedState = null;\nthis.dependencies = null;\n\nthis.mode = mode;\n\n// 保存本次更新会造成的DOM操作\nthis.effectTag = NoEffect;\nthis.nextEffect = null;\n\nthis.firstEffect = null;\nthis.lastEffect = null;\n")])])]),t("p",[e._v("保存调度优先级字段在如下字段：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 调度优先级相关\nthis.lanes = NoLanes;\nthis.childLanes = NoLanes;\n")])])]),t("h4",{attrs:{id:"expirationtime-lanes-优先级对比pr"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#expirationtime-lanes-优先级对比pr"}},[e._v("#")]),e._v(" expirationTime/ lanes 优先级对比"),t("a",{attrs:{href:"https://github.com/facebook/react/pull/18796",target:"_blank",rel:"noopener noreferrer"}},[e._v("PR"),t("OutboundLink")],1),e._v("：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Lanes 模型与 Expiration Times 模型相比有两个主要优点")]),e._v(" "),t("ul",[t("li",[e._v("Lanes将任务优先级的概念（任务 A 的优先级是否高于任务 B）与任务批处理（任务A是这组任务的一部分吗？）解耦")]),e._v(" "),t("li",[e._v("Lanes 可以用单一的 32 位数据类型表示许多不同的任务线程。")])])])]),e._v(" "),t("p",[e._v("在旧模型中，为了决定是否在正在处理的批处理中包含给定的工作单元，我们将比较它们的相对优先级：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const isTaskIncludedInBatch = priorityOfTask >= priorityOfBatch;\n")])])]),t("p",[e._v("这是因为react施加了一个约束，即除非还包括更高优先级的任务，否则不允许完成较低优先级的任务。给定优先级 A > B > C，如果不处理 A，就无法处理B；如果不处理完成 B 和 A，你也不能处理 C。\n这个约束是在Suspense出现之前设计的，这个在当时是有意义的（具体什么意义，我就不深究了， 😁）。当我们的所有工作都受 CPU 限制时，除了按优先级之外，沒有太多理由按任何顺序处理任务。但是，当我们引入 IO 密集型任务（即 Suspense）时，我们可能会遇到较高优先级 IO 密集型任务阻止较低优先级 CPU 密集型任务完成的情况。")]),e._v(" "),t("p",[e._v("Expiration Times 的一个类似缺陷限制了我们如何表达一组多个优先级。")]),e._v(" "),t("p",[e._v("就内存或计算而言，使用 Set 对象是不切实际的。我们正在处理的存在性检查非常普遍，因此它们需要快速并使用尽可能少的内存。\n作为妥协，我们通常会做的是维持一系列优先级。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const isTaskIncludedInBatch = taskPriority <= highestPriorityInRange && taskPriority >= lowestPriorityInRange;\n")])])]),t("p",[e._v("旧模型将 优先级和 批处理这两个概念耦合到一个单一的数据类型中。 我们表达其中一个的能力是有限的，除非用影响另一个的术语。\n在新模型中，我们将这两个概念解耦。 相反，任务组不是用相对数字表示，而是用位掩码表示：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const isTaskIncludedInBatch = (task & batchOfTasks) !== 0;\n")])])]),t("ul",[t("li",[e._v("表示任务的位掩码类型称为 Lane")]),e._v(" "),t("li",[e._v("表示批次的位掩码类型称为 Lanes")])]),e._v(" "),t("p",[e._v("在更具体的 React 术语中，由 setState 调度的更新对象包含一个通道字段，一个启用单个位的位掩码。 这将替换旧模型中的 update.expirationTime 字段。\n另一方面，一个fiber 不仅仅与单个更新相关联，而是可能与多个更新相关联。 所以它有一个 lanes 字段，一个启用了零个或多个位的位掩码（旧模型中的 fiber.expirationTime）； 和一个 childLanes 字段 (fiber.childExpirationTime)。启用零个或多个位（旧模型中的 fiber.expirationTime）和一个 childLanes 字段 (fiber.childExpirationTime)。")]),e._v(" "),t("p",[e._v("Lanes是一种不透明的类型。 只能在 ReactFiberLane 模块内执行直接位掩码操作。 在其他地方，必须从该模块导入一个辅助函数。 这是一个折衷，但我认为最终是值得的，因为处理Lanes可能非常微妙，并且将所有逻辑放在一起将使我们更容易调整我们的启发式算法，而无需每次进行大量重构（像这样）。")]),e._v(" "),t("p",[e._v("常见的 Expiration Time 字段，转化为 Lanes")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("renderExpirationtime -> renderLanes\nupdate.expirationTime -> update.lane\nfiber.expirationTime -> fiber.lanes\nfiber.childExpirationTime -> fiber.childLanes\nroot.firstPendingTime and root.lastPendingTime -> fiber.pendingLanes\n")])])]),t("h3",{attrs:{id:"_05-fiber架构的工作原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_05-fiber架构的工作原理"}},[e._v("#")]),e._v(" 05. fiber架构的工作原理")]),e._v(" "),t("h4",{attrs:{id:"什么是双缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是双缓存"}},[e._v("#")]),e._v(" 什么是双缓存？")]),e._v(" "),t("p",[e._v("通俗来说，当我们用canvas绘制动画，每一帧绘制前都会调用ctx.clearRect清除上一帧的画面。如果当前帧画面计算量比较大，导致清除上一帧画面到绘制当前帧画面之间有较长间隙，就会出现白屏。为了解决这个问题，我们可以在内存中绘制当前帧动画，绘制完毕后直接用当前帧替换上一帧画面，由于省去了两帧替换间的计算时间，不会出现从白屏到出现画面的闪烁情况。")]),e._v(" "),t("p",[e._v("这种在内存中构建并直接替换的技术叫做双缓存。")]),e._v(" "),t("p",[e._v("React使用“双缓存”来完成Fiber树的构建与替换——对应着DOM树的创建与更新。")]),e._v(" "),t("h4",{attrs:{id:"双缓存fiber树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双缓存fiber树"}},[e._v("#")]),e._v(" 双缓存Fiber树")]),e._v(" "),t("p",[e._v("在React中最多会同时存在两棵Fiber树。")]),e._v(" "),t("ul",[t("li",[e._v("当前屏幕上显示内容对应的Fiber树称为"),t("strong",[e._v("current Fiber")]),e._v(">树")]),e._v(" "),t("li",[e._v("正在内存中构建的Fiber树称为"),t("strong",[e._v("workInProgress Fiber")]),e._v("树")])]),e._v(" "),t("p",[e._v("current Fiber树中的Fiber节点被称为current fiber，workInProgress Fiber树中的Fiber节点被称为workInProgress fiber，他们通过alternate属性连接。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("currentFiber.alternate === workInProgressFiber;\nworkInProgressFiber.alternate === currentFiber;\n")])])]),t("p",[e._v("React应用的根节点"),t("strong",[e._v("fiber Node")]),e._v("通过使current指针在不同Fiber树的rootFiber间切换来完成current Fiber树指向的切换。")]),e._v(" "),t("p",[t("strong",[e._v("切换时机")]),e._v("：即当workInProgress Fiber树构建完成交给Renderer渲染在页面上后，应用根节点的current指针指向workInProgress Fiber树，此时workInProgress Fiber树就变为current Fiber树。")]),e._v(" "),t("p",[e._v("每次状态更新都会产生新的workInProgress Fiber树，通过current与workInProgress的替换，完成DOM更新。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function App() {\n  const [num, add] = useState(0);\n  return (\n    <p onClick={() => add(num + 1)}>{num}</p>\n  )\n}\n\nReactDOM.render(<App/>, document.getElementById('root'));\n")])])]),t("p",[e._v("首次渲染时：")]),e._v(" "),t("ol",[t("li",[e._v("fiberRootNode的current会指向当前页面上已渲染内容对应Fiber树，即current Fiber树。")]),e._v(" "),t("li",[e._v("接下来进入render阶段，根据组件返回的JSX在内存中依次创建Fiber节点并连接在一起构建Fiber树，被称为workInProgress Fiber树。（下图中右侧为内存中构建的树，左侧为页面显示的树）")]),e._v(" "),t("li",[e._v("图中右侧已构建完的workInProgress Fiber树在commit阶段渲染到页面。\n此时DOM更新为右侧树对应的样子。fiberRootNode的current指针指向workInProgress Fiber树使其变为current Fiber 树")])]),e._v(" "),t("p",[t("img",{attrs:{src:"/images/react/%E6%96%B0%E5%BB%BA.png",alt:""}})]),e._v(" "),t("p",[e._v("更新时：")]),e._v(" "),t("ol",[t("li",[e._v("接下来我们点击p节点触发状态改变，这会开启一次新的render阶段并构建一棵新的workInProgress Fiber 树")]),e._v(" "),t("li",[e._v("workInProgress Fiber 树在render阶段完成构建后进入commit阶段渲染到页面上。渲染完毕后，workInProgress Fiber 树变为current Fiber 树。\n"),t("img",{attrs:{src:"/images/react/%E6%9B%B4%E6%96%B0.png",alt:""}})])]),e._v(" "),t("h4",{attrs:{id:"jsx-与fiber-关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jsx-与fiber-关系"}},[e._v("#")]),e._v(" jsx 与fiber 关系")]),e._v(" "),t("p",[e._v("jsx是一种描述当前组件内容的数据结构，不包含schedule，reconclie，render所需的相关信息")]),e._v(" "),t("p",[e._v("在新建时，Reconciler根据JSX描述的组件内容生成组件对应的Fiber节点。\n再更新时，Reconclier 将jsx 数据与Fibler 节点保存的数据对比，生成对应的workInProgress fiber。")])])}),[],!1,null,null,null);r.default=s.exports}}]);