(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{471:function(e,t,n){"use strict";n.r(t);var r=n(28),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h3",{attrs:{id:"_01-component"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_01-component"}},[e._v("#")]),e._v(" 01. Component")]),e._v(" "),n("p",[e._v("packages/react/src/ReactBaseClasses.js")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 用于更新组件状态的基类帮助程序\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  // If a component has string refs, we will assign a different object later.\n  this.refs = emptyObject; // 如果一个组件有字符串引用，后面指定一个不同的对象。\n  this.updater = updater || ReactNoopUpdateQueue; // updater 对象上保存着更新租金的方法\n}\n\nComponent.prototype.setState = function(partialState, callback) {\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n\nComponent.prototype.forceUpdate = function(callback) {\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n};\n")])])]),n("ul",[n("li",[e._v("Component 底层 React 的处理逻辑是: 类组件执行构造函数过程中会在实例上绑定 props 和 context ，初始化置空 refs 属性，原型链上绑定setState、forceUpdate 方法。对于 updater，React 在实例化类组件之后会单独绑定 update 对象.")])]),e._v(" "),n("p",[e._v("所以说 为什么调用 super(props)，由此而来。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("constructor(){\n    super()\n    console.log(this.props) // 打印 undefined 为什么?\n}\n")])])]),n("p",[e._v("绑定 props 是在父类 Component 构造函数中，执行 super 等于执行 Component 函数，此时 props 没有作为第一个参数传给 super() ，在 Component 中就会找不到 props 参数，从而变成 undefined。")]),e._v(" "),n("ul",[n("li",[e._v("调用super的原因：在ES6中，在子类的constructor中必须先调用super才能引用this")]),e._v(" "),n("li",[e._v("super(props)的目的：在constructor中可以使用this.props")])]),e._v(" "),n("p",[e._v("如何被实例化？源码如下：")]),e._v(" "),n("p",[e._v("packages/react-reconciler/src/ReactFiberClassComponent.new.js")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function constructClassInstance (workInProgress, ctor, props) {\n    ...\n    let instance = new ctor(props, context);\n    adoptClassInstance(workInProgress, instance);\n    ...\n}\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function adoptClassInstance(workInProgress, instance) {\n  instance.updater = classComponentUpdater;\n}\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const classComponentUpdater = {\n  isMounted,\n  enqueueSetState(inst, payload, callback) {\n    // setState 触发\n  }\n  enqueueReplaceState(inst, payload, callback) {\n    // replaceState 触发\n    update.tag = ReplaceState;\n  }\n  enqueueForceUpdate(inst, payload, callback) {\n    // forceUpdate 触发\n    update.tag = ForceUpdate;\n  }\n}\n")])])]),n("p",[e._v("enqueueSetState/enqueueReplaceState/enqueueForceUpdate 实现方式基本一致")]),e._v(" "),n("ol",[n("li",[e._v("更新过期时间")]),e._v(" "),n("li",[e._v("创建Update对象")]),e._v(" "),n("li",[e._v("为update对象绑定一些属性，比如 tag 、callback")]),e._v(" "),n("li",[e._v("创建的update对象入队 (enqueueUpdate)")]),e._v(" "),n("li",[e._v("进入调度过程")])]),e._v(" "),n("h3",{attrs:{id:"_02-purecomponent"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_02-purecomponent"}},[e._v("#")]),e._v(" 02. PureComponent")]),e._v(" "),n("p",[e._v("PureComponent 和Component用法差不多，唯一不同的是，纯组件PureComponent会进行浅比较，props 和state是否相同是否重新渲染组件。一般用于于性能优化，减少render次数。如果对象包含复杂的数据结构(比如对象和数组)，会浅比较，如果深层次的改变，是无法作出判断的，React.PureComponent 认为没有变化，而没有渲染试图。我们可以借助于immetable.js,提高对象的比较性能,用 immetable.js 配合 shouldComponentUpdate 或者 react.memo来使用, 通过immetable.js里面提供的 is 方法来判断，前后对象数据类型是否发生变化")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('import React, { PureComponent } from "react";\nclass Index extends PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {\n      user: {\n        name: "wsh",\n        age: 18,\n      }\n    };\n    this.handerClick = this.handerClick.bind(this);\n  }\n  handerClick = () => {\n    const { user } = this.state;\n    user.age++;\n    // this.setState({ user: {...user} });\n    this.setState({ user }); // 不更新的原因：两次user对象，都指向同一个user,没有发生改变，所以不更新视图\n  };\n  render() {\n    const { user } = this.state;\n    return (\n      <div>\n        <div>\n          name: {user.name}\n          age: {user.age}\n        </div>\n        <button onClick={this.handerClick}>点击</button>\n      </div>\n    );\n  }\n}\n\nexport default Index;\n')])])]),n("h3",{attrs:{id:"_03-memo"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_03-memo"}},[e._v("#")]),e._v(" 03. memo")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("React.memo 与PureComponent作用类似，可以用作性能优化.")])]),e._v(" "),n("li",[n("p",[e._v("React.memo 是高阶组件，函数组件和类组件都可以使用,PureComponent是 只能用作类组件")])]),e._v(" "),n("li",[n("p",[e._v("React.memo只能对props的情况确定是否渲染，而PureComponent是针对props和state")])]),e._v(" "),n("li",[n("p",[e._v("React.memo([组件本身],param)，第一个参数是原始组件本身，第二个参数是通过对比props是否相等来对比是否渲染（pre，next）=> { return true or false } 与shouldComponentUpdate 相反，返回true，说明props没有发生变化，不渲染，返回false 选择组件")]),e._v(" "),n("p",[e._v("React.memo: 第二个参数 返回 true 组件不渲染 ， 返回 false 组件重新渲染。\nshouldComponentUpdate: 返回 true 组件渲染 ， 返回 false 组件不渲染。")])])]),e._v(" "),n("p",[e._v("React.memo在一定程度上，等价于在组件外部使用shouldComponentUpdate，用于拦截新老props，确定组件是否更新。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('import React, { Component, memo } from "react";\n\nfunction TextMemo(props) {\n  console.log("子组件渲染");\n  if (props) {\n    return <div>hello react</div>;\n  }\n}\nconst controllIsRender = (pre, next) => {\n  if (pre.age === next.age) {\n    return true;\n  } else if (next.age > 5) {\n    return true;\n  } else {\n    return false;\n  }\n};\nconst NewMemo = memo(TextMemo, controllIsRender);\n\nclass Index extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 1,\n      age: 1,\n    };\n  }\n  render() {\n    const { count, age } = this.state;\n    return (\n      <div>\n        <div>\n          改变count：当前值 {count}\n          <button onClick={() => this.setState({ count: count + 1 })}>count++</button>\n          <button onClick={() => this.setState({ count: count - 1 })}>count--</button>\n        </div>\n        <div>\n          改变age：当前后 {age}\n          <button onClick={() => this.setState({ age: age + 1 })}>age++</button>\n          <button onClick={() => this.setState({ age: age - 1 })}>age--</button>\n        </div>\n        <NewMemo age={age} count={count} />\n      </div>\n    );\n  }\n}\n\nexport default Index;\n\n')])])]),n("h3",{attrs:{id:"_04-forwardref"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_04-forwardref"}},[e._v("#")]),e._v(" 04. forwardRef")]),e._v(" "),n("h4",{attrs:{id:"场景一-隔代获取ref引用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#场景一-隔代获取ref引用"}},[e._v("#")]),e._v(" 场景一：隔代获取ref引用")]),e._v(" "),n("ul",[n("li",[e._v("正常情况下：react不允许ref 通过props 传递，因为在组件上已经带有ref这个属性,在组件进行调和过程中，已经被特殊处理了。")]),e._v(" "),n("li",[e._v("forwardRef 出现可以解决这个问题，把ref转发到自定义的forwardRef定义的属性上，可以让ref通过props进行传递")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('import React, { Component, forwardRef } from "react";\nfunction Son(props) {\n  const { grandRef } = props;\n  return <div>\n      <span ref={grandRef}>Son</span>\n  </div>;\n}\nclass Father extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return <Son grandRef={this.props.grandRef} />;\n  }\n}\nconst NewFather = forwardRef((props, ref) => (\n  <Father grandRef={ref} {...props} />\n));\n\nexport default class GrandFather extends Component {\n  constructor(props) {\n    super(props);\n  }\n  node = null;\n  componentDidMount() {\n      console.log(this.node)\n  }\n  render() {\n    return <div>\n        <NewFather ref={(node) => this.node = node}/>\n        <Father/>\n    </div>;\n  }\n}\n\n')])])]),n("h4",{attrs:{id:"场景二-高阶组件转发ref"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#场景二-高阶组件转发ref"}},[e._v("#")]),e._v(" 场景二：高阶组件转发ref")]),e._v(" "),n("p",[e._v("由于属性代理的hoc，被包裹一层，如果是类组件，通过ref拿不到原始组件的实例的，可以借助forWardRef转发ref拿到对应的实例")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import React, { Component, useRef, useEffect } from 'react'\nfunction HOC(Comp){\n    class Wrap extends Component {\n        render() {\n            const {forwardRef, ...otherProps} = this.props;\n            return (\n                <Comp ref={forwardRef} {...otherProps}/>\n            )\n        }\n    }\n    return React.forwardRef((props, ref) => <Wrap forwardRef={ref} {...props}/>)\n}\nclass Index extends Component{\n    componentDidMount(){\n        console.log('hello react')\n    }\n    render() {\n        return (\n            <div>hello forwardRef</div>\n        )\n    }\n}\nconst HocIndex = HOC(Index);\nexport default () => {\n    const node = useRef(null);\n    useEffect(() => {\n      console.log(node.current.componentDidMount(), '--')\n    }, [])\n    return <div>\n        <HocIndex ref={node}/>\n    </div>\n}\n\n")])])]),n("h3",{attrs:{id:"_05-lazy"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_05-lazy"}},[e._v("#")]),e._v(" 05. lazy")]),e._v(" "),n("p",[e._v("React.lazy 接受一个函数，这个函数需要动态调用 import()。它必须返回一个 Promise ，该 Promise 需要 resolve 一个 default export 的 React 组件。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import React, { Component, Suspense } from 'react'\nconst UserInfo = React.lazy(() => new Promise((resolve)=>{\n  setTimeout(() => {\n    resolve(import('../Component/UserInfo'))\n  }, 1000)\n  \n}))\nexport default class Index extends Component {\n  render() {\n    return (\n      <Suspense fallback=\"loading...\">\n        <UserInfo/>\n      </Suspense>\n    )\n  }\n}\n\n")])])]),n("ul",[n("li",[e._v("import 原理如下：\nimport() 函数是由TS39提出的一种动态加载模块的规范实现，其返回是一个 promise。在浏览器宿主环境中一个import()的参考实现如下：")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('function import(url) {\n    return new Promise((resolve, reject) => {\n      const script = document.createElement(\'script\');\n      // toString(32) 32进制\n      const tmpGlobal = "__tempModuleLoadingVariable"+ Math.random().toString(32).substring(2);\n      script.type = "module";\n      script.textContent = `import * as m from "${url}"; window.${tmpGlobal} = m;`;\n      script.onload = () => {\n          resolve(window[tmpGlobal]);\n          delete(window[tmpGlobal]);\n          script.remove();\n      }\n      script.onerror = () => {\n          reject(new Error("Failed to load module script with URL " + url));\n          delete(window[tmpGlobal]);\n          script.remove();\n      }\n      document.documentElement.appendChild(script)\n    })\n}\n')])])]),n("h3",{attrs:{id:"_06-fragment"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_06-fragment"}},[e._v("#")]),e._v(" 06. Fragment")]),e._v(" "),n("p",[e._v("不增加额外的dom节点，能够让一个组件返回多个元素\n写法：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<React.Fragment></React.Fragment>\n或者\n<></>\n")])])]),n("p",[e._v("二者区别：")]),e._v(" "),n("ul",[n("li",[e._v("Fragment支持key元素，<></>不支持key元素")])]),e._v(" "),n("p",[e._v("通过我们在map数据时，react底层会处理 默认在外部嵌套一个[Fragment]标签\n例如：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" [1,3,4].map(v => <span key={v}>{v}</span>)\n 等价于\n <Fragment>\n  <span></span>\n  <span></span>\n  <span></span>\n</Fragment>\n")])])]),n("h3",{attrs:{id:"_07-profiler"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_07-profiler"}},[e._v("#")]),e._v(" 07. Profiler")]),e._v(" "),n("p",[e._v("Profiler react 性能审查工具")]),e._v(" "),n("p",[e._v("react 有两个阶段为我们的应用工作")]),e._v(" "),n("ul",[n("li",[e._v("render：React通过将渲染结果与先前的渲染进行比较来确定需要进行哪些DOM更改")]),e._v(" "),n("li",[e._v("commit：React应用需要进行的任何更改。 从DOM中添加/删除并调用生命周期挂钩，例如componentDidMount和componentDidUpdate")])]),e._v(" "),n("p",[e._v("profiler DevTools 是在commit 阶段收集性能数据的。各次 commit 会被展示在界面顶部的条形图中")]),e._v(" "),n("p",[e._v("Profiler 一般有两个参数：")]),e._v(" "),n("ul",[n("li",[e._v("id：用来标识 Profiler的唯一性")]),e._v(" "),n("li",[e._v("onRender：用于渲染完成，接受渲染参数")])]),e._v(" "),n("p",[e._v("Profiler 需要一个 onRender 函数作为参数。 React 会在 profile 包含的组件树中任何组件 “提交” 一个更新的时候调用这个函数。 它的参数描述了渲染了什么和花费了多久。"),n("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/profiler.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("官网"),n("OutboundLink")],1)]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('function onRenderCallback(\n  id, // 发生提交的 Profiler 树的 “id”\n  phase, // "mount" （如果组件树刚加载） 或者 "update" （如果它重渲染了）之一\n  actualDuration, // 本次更新 committed 花费的渲染时间\n  baseDuration, // 估计不使用 memoization 的情况下渲染整颗子树需要的时间\n  startTime, // 本次更新中 React 开始渲染的时间\n  commitTime, // 本次更新中 React committed 的时间\n  interactions // 属于本次更新的 interactions 的集合\n) {\n  // 合计或记录渲染时间。。。\n}\n')])])]),n("ul",[n("li",[e._v("id: string - 发生提交的 Profiler 树的 id。 如果有多个 profiler，它能用来分辨树的哪一部分发生了“提交”。")]),e._v(" "),n("li",[e._v('phase: "mount" | "update" - 判断是组件树的第一次装载引起的重渲染，还是由 props、state 或是 hooks 改变引起的重渲染。')]),e._v(" "),n("li",[e._v("actualDuration: number - 本次更新在渲染 Profiler 和它的子代上花费的时间。 这个数值表明使用 memoization 之后能表现得多好。（例如 React.memo，useMemo，shouldComponentUpdate）。 理想情况下，由于子代只会因特定的 prop 改变而重渲染，因此这个值应该在第一次装载之后显著下降。")]),e._v(" "),n("li",[e._v("baseDuration: number - 在 Profiler 树中最近一次每一个组件 render 的持续时间。 这个值估计了最差的渲染时间。（例如当它是第一次加载或者组件树没有使用 memoization）。")]),e._v(" "),n("li",[e._v("startTime: number - 本次更新中 React 开始渲染的时间戳。")]),e._v(" "),n("li",[e._v("commitTime: number - 本次更新中 React commit 阶段结束的时间戳。 在一次 commit 中这个值在所有的 profiler 之间是共享的，可以将它们按需分组。")]),e._v(" "),n("li",[e._v("interactions: Set - 当更新被制定时，“interactions” 的集合会被追踪。（例如当 render 或者 setState 被调用时）( 能用来识别更新是由什么引起的,实验性)。")])]),e._v(" "),n("h3",{attrs:{id:"_08-strictmode"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_08-strictmode"}},[e._v("#")]),e._v(" 08. StrictMode")]),e._v(" "),n("p",[e._v("作用：用来检测项目中潜在的问题，与 Fragment 一样， StrictMode 不会渲染任何可见的UI 。它为其后代元素触发额外的检查和警告")]),e._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[e._v("注意：")]),e._v(" "),n("p",[e._v("严格模式检查仅在开发模式下运行；它们不会影响生产构建。")])]),e._v(" "),n("p",[e._v("可以为应用程序的任何部分启用严格模式")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import React from 'react';\n\nfunction ExampleApplication() {\n  return (\n    <div>\n      <Header />\n      <React.StrictMode>\n        <div>\n          <ComponentOne />\n          <ComponentTwo />\n        </div>\n      </React.StrictMode>\n      <Footer />\n    </div>\n  );\n}\n\n")])])]),n("p",[e._v("StrictMode 目前有助于")]),e._v(" "),n("ul",[n("li",[e._v("识别不安全的生命周期(UNSAFE_componentWillMount, UNSAFE_componentWillReceiveProps, UNSAFE_componentWillUpdate)")]),e._v(" "),n("li",[e._v("关于使用过时字符串 ref API 的警告")]),e._v(" "),n("li",[e._v("关于使用废弃的 findDOMNode 方法的警告")]),e._v(" "),n("li",[e._v("检测意外的副作用")]),e._v(" "),n("li",[e._v("检测过时的 context API")])])])}),[],!1,null,null,null);t.default=a.exports}}]);