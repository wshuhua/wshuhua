(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{492:function(e,t,n){"use strict";n.r(t);var r=n(28),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h3",{attrs:{id:"_01-createelement"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_01-createelement"}},[e._v("#")]),e._v(" 01. createElement")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://babeljs.io/repl",target:"_blank",rel:"noopener noreferrer"}},[e._v("babel 转换"),n("OutboundLink")],1)]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('class App extends Component {\n  render() {\n    return (\n      <div className="App">\n        hello react\n      </div>\n    );\n  }\n}\n')])])]),n("p",[e._v("通过Babel来配合会将JSX转移成React.createElement函数调用,代码如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('"use strict";\n\nclass App extends Component {\n  render() {\n    return /*#__PURE__*/React.createElement("div", {\n      className: "App"\n    }, "hello react");\n  }\n\n}\n')])])]),n("p",[e._v("React.createElement函数的语法如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("React.createElement(type, [props], [...children])\n")])])]),n("ul",[n("li",[e._v("type： 表示元素名称")]),e._v(" "),n("li",[e._v("props：表示组件的入参 也就是传入组件的属性")]),e._v(" "),n("li",[e._v("children：表示子组件")])]),e._v(" "),n("p",[e._v("React.createElement函数用于创建并返回指定类型的新react元素\n经过createElement处理，最终会形成 $$typeof: Symbol(react.element)对象。对象上保存了该react.element的信息。")]),e._v(" "),n("table",[n("thead",[n("tr",[n("th",[e._v("jsx元素类型")]),e._v(" "),n("th",[e._v("react.createElement 转换后")]),e._v(" "),n("th",[e._v("type 属性")])])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("element元素类型")]),e._v(" "),n("td",[e._v("react element类型")]),e._v(" "),n("td",[e._v("标签字符串，例如 div")])]),e._v(" "),n("tr",[n("td",[e._v("fragment类型")]),e._v(" "),n("td",[e._v("react element类型")]),e._v(" "),n("td",[e._v("symbol react.fragment类型")])]),e._v(" "),n("tr",[n("td",[e._v("文本类型")]),e._v(" "),n("td",[e._v("直接字符串")]),e._v(" "),n("td",[e._v("无")])]),e._v(" "),n("tr",[n("td",[e._v("数组类型")]),e._v(" "),n("td",[e._v("返回数组结构，里面元素被react.createElement转换")]),e._v(" "),n("td",[e._v("无")])]),e._v(" "),n("tr",[n("td",[e._v("组件类型")]),e._v(" "),n("td",[e._v("react element类型")]),e._v(" "),n("td",[e._v("组件类或者组件函数本身")])]),e._v(" "),n("tr",[n("td",[e._v("三元表达式")]),e._v(" "),n("td",[e._v("先执行三元运算，然后按照上述规则处理")]),e._v(" "),n("td",[e._v("看三元运算返回结果")])]),e._v(" "),n("tr",[n("td",[e._v("函数执行")]),e._v(" "),n("td",[e._v("先执行函数，然后按照上述规则处理")]),e._v(" "),n("td",[e._v("看函数执行返回结果")])])])]),e._v(" "),n("h3",{attrs:{id:"_02-cloneelement"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_02-cloneelement"}},[e._v("#")]),e._v(" 02. cloneElement")]),e._v(" "),n("p",[e._v("createElement 是把我们写的jsx 变成element元素，而cloneElement则是以element元素为模版，进行克隆并返回新的元素，返回新的props元素是将新旧props浅合并得到的\n例如在react-router的Switch，通过这种方式来匹配唯一的Route并进行渲染")]),e._v(" "),n("h3",{attrs:{id:"_03-createcontext"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_03-createcontext"}},[e._v("#")]),e._v(" 03. createContext")]),e._v(" "),n("p",[e._v("createContext 用于创建一个contenxt对象，\ncreateContext对象中，包括")]),e._v(" "),n("ul",[n("li",[e._v("Provider： 用于传递Context对象值value")]),e._v(" "),n("li",[e._v("Consumer： 接受value变化订阅的Consumer")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const myContext = React.createContext(defaultValue); \n")])])]),n("p",[e._v("defaultValue： 只有当组件所处的树没有匹配的provider时，其defaultValue参数才会生效")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('import React, { Component } from "react";\nconst MyContext = React.createContext(null);\n\nfunction ComponentA() {\n  return (\n    <div>\n      ComponentA\n      <ComponentB />\n    </div>\n  );\n}\nfunction ComponentB(props) {\n  return (\n    <MyContext.Consumer>{(value) => <div>{value.age}</div>}</MyContext.Consumer>\n  );\n}\nclass context extends Component {\n  render() {\n    const userInfo = {\n      name: "wsh",\n      age: 18,\n    };\n    return (\n      <div>\n        <MyContext.Provider value={userInfo}>\n          <ComponentA />\n        </MyContext.Provider>\n      </div>\n    );\n  }\n}\n\nexport default context;\n')])])]),n("h3",{attrs:{id:"_04-createref"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_04-createref"}},[e._v("#")]),e._v(" 04. createRef")]),e._v(" "),n("p",[e._v("createRef 创建一个ref元素，添加在react元素上")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('export default class ref extends Component {\n    constructor(props) {\n        super(props)\n        this.node = React.createRef()\n    }\n    componentDidMount() {\n        this.node.current.style.color="red"\n        console.log(this.node)\n    }\n    render() {\n        return (\n            <div>\n                <div ref={this.node}>hello react</div>\n            </div>\n        )\n    }\n}\n')])])]),n("h3",{attrs:{id:"_05-isvaildelement"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_05-isvaildelement"}},[e._v("#")]),e._v(" 05. isVaildElement")]),e._v(" "),n("p",[e._v("isValidElement 用来检测是否为react element元素，结果返回true｜false，一般用于公共组件/开源库，在业务组件，状态都是已知的，不需要去验证.")]),e._v(" "),n("h3",{attrs:{id:"_06-children-map"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_06-children-map"}},[e._v("#")]),e._v(" 06. Children.map")]),e._v(" "),n("ul",[n("li",[e._v("场景一： 多个子元素")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function WarpComponent(props){\n    console.log(props.children)\n    return <div>\n        {props.children}\n    </div>\n}\nfunction Index(){\n    const arr = [1,2,3,4]\n    return <div style={{ marginTop:'50px' }} >\n        <WarpComponent>\n            <span>11</span>\n            {arr.map((v) => <Text value={v}/>)}\n        </WarpComponent>\n    </div>\n}\n")])])]),n("p",[e._v("结果：\n"),n("img",{attrs:{src:"/images/react/childrenMap.png",alt:""}})]),e._v(" "),n("p",[e._v("通过 React.Children.map操作")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function WarpComponent(props){\n    const newChildren = React.Children.map(props.children,(item)=>item)\n    console.log(newChildren)\n    return <div>\n        {newChildren}\n    </div>\n}\n")])])]),n("p",[e._v("结果：\n"),n("img",{attrs:{src:"/images/react/childrenMap1.png",alt:""}})]),e._v(" "),n("p",[e._v("如果 children 是一个 Fragment 对象，它将被视为单一子节点的情况处理，不会被遍历")]),e._v(" "),n("h3",{attrs:{id:"_07-children-foreach"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_07-children-foreach"}},[e._v("#")]),e._v(" 07. Children.forEach")]),e._v(" "),n("p",[e._v("Children.forEach 与 Children.map 用法类似，但是它仅停留在遍历阶段\nReact.Children.forEach = React.Children.toArray + Array.prototype.forEach")]),e._v(" "),n("h3",{attrs:{id:"_08-children-count"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_08-children-count"}},[e._v("#")]),e._v(" 08. Children.count")]),e._v(" "),n("p",[e._v("返回同一级别子组件的数量")]),e._v(" "),n("h3",{attrs:{id:"_09-children-toarray"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_09-children-toarray"}},[e._v("#")]),e._v(" 09. Children.toArray")]),e._v(" "),n("p",[e._v("Children.toArray返回，props.children扁平化后结果。")]),e._v(" "),n("h3",{attrs:{id:"_10-children-only"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-children-only"}},[e._v("#")]),e._v(" 10. Children.only")]),e._v(" "),n("p",[e._v("验证 children 是否只有一个子节点（一个 React 元素），如果有则返回它，否则此方法会抛出错误。")])])}),[],!1,null,null,null);t.default=a.exports}}]);