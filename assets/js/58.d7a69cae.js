(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{511:function(n,e,a){"use strict";a.r(e);var t=a(28),s=Object(t.a)({},(function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h3",{attrs:{id:"变量类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#变量类型"}},[n._v("#")]),n._v(" 变量类型")]),n._v(" "),a("p",[n._v("ts是强类型，在声明变量的时候，我们必须给他一个类型\n具体类型：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("1. number\n2. string\n3. boolean\n4. enum\n5. Array\n6. Tuple \n6. Symbol；\n7. undefined\n8. any\n9. null\n10. void\n")])])]),a("h3",{attrs:{id:"array"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#array"}},[n._v("#")]),n._v(" array")]),n._v(" "),a("p",[n._v("写法一： 在元素类型后面加上[]")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("let arr: number[] = [1, 2, 3];\n")])])]),a("p",[n._v("写法二： 数组泛型，Array<元素类型>")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("let arr1: Array<number> = [1, 2, 3];\n")])])]),a("h3",{attrs:{id:"tuple"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tuple"}},[n._v("#")]),n._v(" Tuple")]),n._v(" "),a("p",[n._v("元组类型允许表示一个已知元素数量和类型的数组，混合类型, 对应位置的类型需要相同。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("let a: [string, number];\n// 正确写法\na = ['hello', 1]; // OK\n// 不能这样写不然会报错\na = [1, 'hello']; // Error\na = [1, 1, '1']; // Error\n")])])]),a("h3",{attrs:{id:"symbol-类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#symbol-类型"}},[n._v("#")]),n._v(" symbol 类型")]),n._v(" "),a("ul",[a("li",[n._v("只能通过objInfo[symbol] 的方式修改属性值")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const symbol = Symbol('userName')\nlet objInfo = {\n   [symbol]: 'wsh'\n}\n")])])]),a("ul",[a("li",[n._v("对象中的symbol 属性:")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("Object.getOwnPropertySymbols(objInfo) \nReflect.ownKeys(objInfo)\n")])])]),a("ul",[a("li",[n._v("symbol.for(): 根据给定的键 key，来从运行时的 symbol 注册表中找到对应的 symbol,如果找到了，则返回它，否则，新建一个与该键关联的 symbol，并放入全局 symbol 注册表中")]),n._v(" "),a("li",[n._v("symbol.keyFor(): 获取 symbol 注册表中与某个 symbol 关联的键, 如果使用基本的symbol创建的，结果就是undefined")])]),n._v(" "),a("h3",{attrs:{id:"any"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#any"}},[n._v("#")]),n._v(" any")]),n._v(" "),a("p",[n._v("any, 为不清楚类型的变量指定一个类型, 退出类型检查")]),n._v(" "),a("h3",{attrs:{id:"void"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#void"}},[n._v("#")]),n._v(" void")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("void 表示没有任何类型。当一个函数没有返回值时,其返回值类型通常是 void.")])]),n._v(" "),a("li",[a("p",[n._v("声明一个void类型的变量只能为它赋予undefined和null")])])]),n._v(" "),a("h3",{attrs:{id:"null-undefined"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#null-undefined"}},[n._v("#")]),n._v(" null/undefined")]),n._v(" "),a("ul",[a("li",[n._v("默认情况下null和undefined是所有类型的子类型。 例如可以把 null和undefined赋值给number类型的变量。")])]),n._v(" "),a("h3",{attrs:{id:"never"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#never"}},[n._v("#")]),n._v(" never")]),n._v(" "),a("p",[n._v("never,  表示永远不会有值的一种类型")]),n._v(" "),a("ul",[a("li",[n._v("那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function error(message: string): never {\n    throw new Error(message);\n}\n")])])]),a("ul",[a("li",[n._v("返回never的函数必须存在无法达到的终点")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function infiniteLoop(): never {\n    while (true) {\n    }\n}\n")])])]),a("ul",[a("li",[n._v("错误示例")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('// 这个函数不能申明其返回值类型是 never\nfunction warnUser(): void {\n    console.log("This is my warning message");\n}\n\nconst foo: never = 123; // Error: number 类型不能赋值给 never 类型\n')])])]),a("ul",[a("li",[n._v("使用用例")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function foo(x: string | number): boolean {\n  if (typeof x === 'string') {\n    return true;\n  } else if (typeof x === 'number') {\n    return false;\n  }\n\n  // 如果不是一个 never 类型，这会报错：\n  // - 不是所有条件都有返回值 （严格模式下）\n  // - 或者检查到无法访问的代码\n  // 但是由于 TypeScript 理解 `fail` 函数返回为 `never` 类型\n  // 它可以让你调用它，因为你可能会在运行时用它来做安全或者详细的检查。\n  return fail('Unexhaustive');\n}\n\nfunction fail(message: string): never {\n  throw new Error(message);\n}\n")])])]),a("h3",{attrs:{id:"unknown"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#unknown"}},[n._v("#")]),n._v(" unknown")]),n._v(" "),a("ul",[a("li",[n._v("任何类型都可以赋值unknow")]),n._v(" "),a("li",[n._v("如果没有类型断言或者基于控制流的类型细化时，unknown不可以赋值给其他类型")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("let value2: unknown;\nlet value3: string = value2\n")])])]),a("ul",[a("li",[n._v("如果没有类型断言或者基于控制流的类型细化时，不能在他上面进行任何操作")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("let value3: unknown;\nvalue3+= 23\n")])])]),a("ul",[a("li",[n._v("unknown与任何其他类型组成的交叉类型，最后都等于其他类型")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("type type1 = string & unknown\ntype type2 = number & unknown\ntype type3 = unknown & unknown\n")])])]),a("ul",[a("li",[n._v("unknown与任何其他类型（除了any）组成的联合类型，最后都等于unknown")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("type type5 = unknown | string\ntype type6 = unknown | any\n")])])]),a("ul",[a("li",[n._v("never是unknown的子类型")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("type type6 = never extends unknown ? true : false;\n")])])]),a("ul",[a("li",[n._v("keyof unknown 等于类型never")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("type type7 = keyof unknown\n")])])]),a("ul",[a("li",[n._v("只能对 unknown 进行等于/不等于操作，不能进行其他操作")]),n._v(" "),a("li",[n._v("unknown 类型的值不能访问他的属性、作为函数调用和作为类创建实例")]),n._v(" "),a("li",[n._v("使用映射类型时如果遍历的是unknown类型，则不会映射任何属性")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("type Types<T> = {\n    [P in keyof T]: number\n}\ntype type11 = Types<any>\ntype type12 = Types<unknown>\n")])])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[n._v("null / undefined")]),n._v(" "),a("p",[n._v("编译器不能消除null或者undefined，可以使用类型断言操作员手动删除它们。语法是后缀【!】")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const getLengthFunc = (value: string | null): number => {\n  return (value || \"\").length;\n};\nfunction getSpliceStr(num: number | null): string {\n  function getRs(prefix: string) {\n    return prefix + num!.toFixed().toString();\n  }\n  num = num || 0.1;\n  return getRs('liston-');\n}\nconsole.log(getSpliceStr(2.002))\n")])])]),a("h4",{attrs:{id:"noimplicitany"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#noimplicitany"}},[n._v("#")]),n._v(" noImplicitAny")]),n._v(" "),a("p",[n._v("选项 noImplicitAny 用来告诉编译器，当无法推断一个变量时发出一个错误（或者只能推断为一个隐式的 any 类型），你可以：")]),n._v(" "),a("ul",[a("li",[n._v("通过显式添加 :any 的类型注解，来让它成为一个 any 类型；")]),n._v(" "),a("li",[n._v("通过一些更正确的类型注解来帮助 TypeScript 推断类型。\n"),a("a",{attrs:{href:"https://www.typescriptlang.org/docs/handbook/intro.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("官方文档"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=s.exports}}]);