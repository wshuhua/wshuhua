(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{501:function(e,t,n){"use strict";n.r(t);var a=n(28),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h3",{attrs:{id:"状态更新流程概览"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#状态更新流程概览"}},[e._v("#")]),e._v(" 状态更新流程概览")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("触发状态更新")]),e._v(" "),n("ul",[n("li",[e._v("ReactDOM.render")]),e._v(" "),n("li",[e._v("this.setState")]),e._v(" "),n("li",[e._v("this.forceUpdate")]),e._v(" "),n("li",[e._v("useState")]),e._v(" "),n("li",[e._v("useReducer")])])]),e._v(" "),n("li",[n("p",[e._v("创建update 对象")])]),e._v(" "),n("li",[n("p",[e._v("从fiber 到root（markUpdateLaneFromFiberToRoot）")])]),e._v(" "),n("li",[n("p",[e._v("调度更新（ensureRootIsScheduled）")])]),e._v(" "),n("li",[n("p",[e._v("render阶段 （入口：performSyncWorkOnRoot 或preformConcurrentWorkOnRoot）")])]),e._v(" "),n("li",[n("p",[e._v("commit阶段（入口：commitRoot）")])])]),e._v(" "),n("p",[e._v("Update： 每次状态更新创建的一个保存更新状态相关内容的对象。在render阶段的beginWork中会根据Update计算新的state。")]),e._v(" "),n("h4",{attrs:{id:"更新调度"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#更新调度"}},[e._v("#")]),e._v(" 更新调度")]),e._v(" "),n("p",[e._v("ensureRootIsSchedule")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("if (newCallbackPriority === SyncLanePriority) {\n  // 任务已经过期，需要同步执行render阶段\n  newCallbackNode = scheduleSyncCallback(\n    performSyncWorkOnRoot.bind(null, root)\n  );\n} else {\n  // 根据任务优先级异步执行render阶段\n  var schedulerPriorityLevel = lanePriorityToSchedulerPriority(\n    newCallbackPriority\n  );\n  newCallbackNode = scheduleCallback(\n    schedulerPriorityLevel,\n    performConcurrentWorkOnRoot.bind(null, root)\n  );\n}\n")])])]),n("h3",{attrs:{id:"update-分类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#update-分类"}},[e._v("#")]),e._v(" update 分类")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("ReactDOM.render/ ReactDOM.client.createRoot HostRoot")])]),e._v(" "),n("li",[n("p",[e._v("this.setState ClassComponent")])]),e._v(" "),n("li",[n("p",[e._v("this.forceUpdate ClassComponent")])]),e._v(" "),n("li",[n("p",[e._v("useState FunctionComponent")])]),e._v(" "),n("li",[n("p",[e._v("seReducer FunctionComponent")])])]),e._v(" "),n("p",[e._v("三种类型的组件可以触发更新")]),e._v(" "),n("p",[e._v("由于不同组件工作方式不一致，所以存在两种不同结构的update, ClassComponent| HostComponent 共用一套 Update 结构，FunctionComponent 单独一种结构")]),e._v(" "),n("h3",{attrs:{id:"update-结构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#update-结构"}},[e._v("#")]),e._v(" Update 结构")]),e._v(" "),n("p",[e._v("ClassComponent 与HostRoot （rootFiber.tag对应类型）共用同一套Update结构")]),e._v(" "),n("p",[e._v("源码如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function createUpdate(eventTime, lane) {\n  var update = {\n    eventTime: eventTime,\n    lane: lane,\n    tag: UpdateState,\n    payload: null,\n    callback: null,\n    next: null\n  };\n  return update;\n}\n")])])]),n("ul",[n("li",[e._v("eventTime: 任务时间，通过 performance.now() 获取的毫秒数")]),e._v(" "),n("li",[e._v("lane：优先级相关字段，不同Update 优先级可能是不同的")]),e._v(" "),n("li",[e._v("tag: 更新类型。UpdateState ｜ ReplaceState ｜ ForceUpdate ｜ CaptureUpdate\n。对于ClassComponent，payload为this.setState的第一个传参。对于HostRoot，payload为ReactDOM.render的第一个传参")]),e._v(" "),n("li",[e._v("payload：更新挂载的数据，不同类型组件挂载的数据不一样，对于ClassComponent。 payload为this.setState的第一个传参。对于HostRoot, payload为ReactDOM.render的第一个传参。")]),e._v(" "),n("li",[e._v("callback： 更新的回调函数，setState的回调函数，HostRoot的第三个参数回调函数")]),e._v(" "),n("li",[e._v("next: 与其他update形成链表")])]),e._v(" "),n("h3",{attrs:{id:"update与fiber的关系"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#update与fiber的关系"}},[e._v("#")]),e._v(" update与fiber的关系")]),e._v(" "),n("p",[e._v("Fiber节点 组成Fiber树，页面上最多存在两颗树")]),e._v(" "),n("ol",[n("li",[e._v("代表当前状态的ccurrent Fiber树")]),e._v(" "),n("li",[e._v("代表正在render阶段的workInProgress Fiber树")])]),e._v(" "),n("p",[e._v("类似Fiber 节点组成 Fiber树，Fiber节点上的多个Update 会形成链表并被包含在fiber.updateQueue中。")]),e._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[e._v("一个fiber节点存在多个Update")]),e._v(" "),n("p",[e._v("在一个ClassComponent中触发this.onClick方法，方法内部调用了两次this.setState。这会在该fiber中产生两个Update。")])]),e._v(" "),n("p",[e._v("Fiber 节点最多同时存在两个updateQueue")]),e._v(" "),n("ul",[n("li",[e._v("current Fiber 保存的updateQueue 即 current updateQueue")]),e._v(" "),n("li",[e._v("workInProgress Fiber 保存的updateQueue 即 workInProgress updateQueue")])]),e._v(" "),n("p",[e._v("在commit阶段页面完成渲染，workInProgress Fiber树 变成 current Fiber 树，workInProgress Fiber树的Fiber 节点 对应的updateQueue 变为current updateQueue。")]),e._v(" "),n("h3",{attrs:{id:"updatequeue"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#updatequeue"}},[e._v("#")]),e._v(" updateQueue")]),e._v(" "),n("p",[e._v("updateQueue 数据结构：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function initializeUpdateQueue<State>(fiber: Fiber): void {\n  const queue: UpdateQueue<State> = {\n    baseState: fiber.memoizedState,\n    firstBaseUpdate: null,\n    lastBaseUpdate: null,\n    shared: {\n      pending: null,\n    },\n    effects: null,\n  };\n  fiber.updateQueue = queue;\n}\n\n")])])]),n("ul",[n("li",[e._v("baseState: 本次更新前该Fiber节点的state，update基于改该state 计算更新后的state （类比于新智模型中的master分支）")]),e._v(" "),n("li",[e._v("firstBaseUpdate｜ lastBaseUpdate：本次更新前该Fiber 节点已经保存的Update。 以链表形式存在，链表头为firstBaseUpdate，链表尾：lastBaseUpdate。之所以在更新产生前已经保存该Fiber节点内的Update，是由于有些Update 优先级低，在render阶段由update计算state时被跳过。（类比于心智模型中执行git rebase 基于的commit（节点D：紧急bug修复产生的））")]),e._v(" "),n("li",[e._v("shared.pending: 触发更新时，产生的update会保存在shared.pending中形成单向环状链表。当由Update计算state时这个环会被剪开并连接在lastBaseUpdate后面。（类比心智模型中本次需要提交的commit（节点ABC）（正常迭代需求任务））")]),e._v(" "),n("li",[e._v("effects：数组。保存update.callback !== null的Update")])]),e._v(" "),n("h4",{attrs:{id:"例子"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#例子"}},[e._v("#")]),e._v(" 例子：")]),e._v(" "),n("p",[e._v("假设有一个fiber刚经历commit阶段完成渲染。该fiber上有两个由于优先级过低所以在上次的render阶段并没有处理的Update。他们会成为下次更新的baseUpdate。假设为u1和u2，其中u1.next === u2")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("fiber.updateQueue.firstBaseUpdate = u1\nfiber.updateQueue.laseBaseUpdate = u2\nu1.next = u2\n\nfiber.updateQueue.baseState: u1 => u2\n")])])]),n("p",[e._v("在fiber上触发两次状态更新，这会先后产生两个新的Update，为u3和u4。")]),e._v(" "),n("p",[e._v("每个 update 都会通过 enqueueUpdate 方法插入到 updateQueue 队列上")]),e._v(" "),n("p",[e._v("当插入u3后：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("fiber.updatQueue.shared.pending === u3\n\nu3.next === u3;\n\n")])])]),n("p",[e._v("fiber.updateQueue.shared.pending表示为")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("u3 ─────┐ \n ^      |                                    \n └──────┘\n")])])]),n("p",[e._v("当u4插入：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("fiber.updateQueue.shared.pending === u4;\nu4.next === u3;\nu3.next === u4;\n\n")])])]),n("p",[e._v("fiber.updateQueue.shared.pending表示为")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("u4 ─> u3┐ \n ^      |                                    \n └──────┘\n")])])]),n("p",[e._v("enqueueUpdate 源码如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function enqueueUpdate<State>(fiber: Fiber, update: Update<State>) {\n  const updateQueue = fiber.updateQueue;\n  // 仅在fiber已卸载时发生\n  if (updateQueue === null) {\n    return;\n  }\n\n  const sharedQueue: SharedQueue<State> = (updateQueue: any).shared;\n  const pending = sharedQueue.pending;\n  if (pending === null) {\n    // 这是第一次更新。 创建一个循环列表。\n    update.next = update;\n  } else {\n    update.next = pending.next;\n    pending.next = update;\n  }\n  sharedQueue.pending = update;\n}\n")])])]),n("p",[e._v("更新调度完成后进入render阶段。shared.pending的环被打开并连接在updateQueue.lastBaseUpdate后面：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("fiber.updateQueue.baseUpdate: u1 => u2 => u3 => u4\n")])])]),n("p",[e._v("然后遍历updateQueue.baseUpdate链表，以fiber.updateQueue.baseState为初始state，依次与遍历到的每个Update计算并产生新的state（该操作类比Array.prototype.reduce）。")]),e._v(" "),n("p",[e._v("在遍历时如果有优先级低的Update会被跳过。")]),e._v(" "),n("p",[e._v("当遍历完成后获得的state，就是该Fiber节点在本次更新的state（memoizedState）。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function processUpdateQueue<State>(\n  workInProgress: Fiber,\n  props: any,\n  instance: any,\n  renderLanes: Lanes,\n): void {\n  const queue: UpdateQueue<State> = (workInProgress.updateQueue: any);\n  hasForceUpdate = false;\n\n  let firstBaseUpdate = queue.firstBaseUpdate;\n  let lastBaseUpdate = queue.lastBaseUpdate;\n\n  // 检查是否有待处理的更新。 如果有，将它们转移到baseQueue.。\n  let pendingQueue = queue.shared.pending;\n  if (pendingQueue !== null) {\n    queue.shared.pending = null;\n\n    // 待处理队列是循环的。 断开第一个之间的指针，\n    const lastPendingUpdate = pendingQueue;\n    const firstPendingUpdate = lastPendingUpdate.next;\n    lastPendingUpdate.next = null;\n    // 将 pending updates追加加到base queue\n    if (lastBaseUpdate === null) {\n      firstBaseUpdate = firstPendingUpdate;\n    } else {\n      lastBaseUpdate.next = firstPendingUpdate;\n    }\n    lastBaseUpdate = lastPendingUpdate;\n\n    const current = workInProgress.alternate;\n    if (current !== null) {\n      const currentQueue: UpdateQueue<State> = (current.updateQueue: any);\n      const currentLastBaseUpdate = currentQueue.lastBaseUpdate;\n      if (currentLastBaseUpdate !== lastBaseUpdate) {\n        if (currentLastBaseUpdate === null) {\n          currentQueue.firstBaseUpdate = firstPendingUpdate;\n        } else {\n          currentLastBaseUpdate.next = firstPendingUpdate;\n        }\n        currentQueue.lastBaseUpdate = lastPendingUpdate;\n      }\n    }\n  }\n  if (firstBaseUpdate !== null) {\n    // 遍历更新列表以计算结果。\n    let newState = queue.baseState;\n    let newLanes = NoLanes;\n\n    let newBaseState = null;\n    let newFirstBaseUpdate = null;\n    let newLastBaseUpdate = null;\n\n    let update = firstBaseUpdate;\n    do {\n      const updateLane = update.lane;\n      const updateEventTime = update.eventTime;\n      if (!isSubsetOfLanes(renderLanes, updateLane)) {\n        // 优先级不足，跳过这个更新，如果他是首次跳出更新，前一个update/state作为新的基础的update/state.\n        const clone: Update<State> = {\n          eventTime: updateEventTime,\n          lane: updateLane,\n          suspenseConfig: update.suspenseConfig,\n\n          tag: update.tag,\n          payload: update.payload,\n          callback: update.callback,\n\n          next: null,\n        };\n        if (newLastBaseUpdate === null) {\n          newFirstBaseUpdate = newLastBaseUpdate = clone;\n          newBaseState = newState;\n        } else {\n          newLastBaseUpdate = newLastBaseUpdate.next = clone;\n        }\n        // 更新队列中剩余的优先级。\n        newLanes = mergeLanes(newLanes, updateLane);\n      } else {\n        // 此更新具有足够的优先级。\n\n        if (newLastBaseUpdate !== null) {\n          const clone: Update<State> = {\n            eventTime: updateEventTime,\n            lane: NoLane,\n            suspenseConfig: update.suspenseConfig,\n\n            tag: update.tag,\n            payload: update.payload,\n            callback: update.callback,\n\n            next: null,\n          };\n          newLastBaseUpdate = newLastBaseUpdate.next = clone;\n        }\n        markRenderEventTimeAndConfig(updateEventTime, update.suspenseConfig);\n\n        // 处理此更新。\n        newState = getStateFromUpdate(\n          workInProgress,\n          queue,\n          update,\n          newState,\n          props,\n          instance,\n        );\n        const callback = update.callback;\n        if (callback !== null) {\n          workInProgress.effectTag |= Callback;\n          const effects = queue.effects;\n          if (effects === null) {\n            queue.effects = [update];\n          } else {\n            effects.push(update);\n          }\n        }\n      }\n      update = update.next;\n      if (update === null) {\n        pendingQueue = queue.shared.pending;\n        if (pendingQueue === null) {\n          break;\n        } else {\n          const lastPendingUpdate = pendingQueue;\n          const firstPendingUpdate = ((lastPendingUpdate.next: any): Update<State>);\n          lastPendingUpdate.next = null;\n          update = firstPendingUpdate;\n          queue.lastBaseUpdate = lastPendingUpdate;\n          queue.shared.pending = null;\n        }\n      }\n    } while (true);\n\n    if (newLastBaseUpdate === null) {\n      newBaseState = newState;\n    }\n\n    queue.baseState = ((newBaseState: any): State);\n    queue.firstBaseUpdate = newFirstBaseUpdate;\n    queue.lastBaseUpdate = newLastBaseUpdate;\n\n    markSkippedUpdateLanes(newLanes);\n    workInProgress.lanes = newLanes;\n    workInProgress.memoizedState = newState;\n  }\n}\n\n")])])]),n("p",[e._v("state的变化在render阶段产生与上次更新不同的JSX对象，通过Diff算法产生effectTag，在commit阶段渲染在页面上。渲染完成后workInProgress Fiber树变为current Fiber树，整个更新流程到此结束。")]),e._v(" "),n("h3",{attrs:{id:"优先级"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#优先级"}},[e._v("#")]),e._v(" 优先级")]),e._v(" "),n("p",[e._v("runWithPriority方法接收一个优先级常量与一个回调函数作为参数。回调函数会以优先级高低为顺序排列在一个定时器中并在合适的时间触发。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function runWithPriority(priority, fn) {\n  var previousPriority = currentUpdatePriority;\n\n  try {\n    currentUpdatePriority = priority;\n    return fn();\n  } finally {\n    currentUpdatePriority = previousPriority;\n  }\n}\n")])])]),n("p",[n("img",{attrs:{src:"/images/react/class%E4%BC%98%E5%85%88%E7%BA%A7.jpeg",alt:""}})]),e._v(" "),n("p",[e._v("在这个例子中，有两个Update。我们将“关闭黑夜模式”产生的Update称为u1，输入字母“I”产生的Update称为u2。\n其中u1先触发并进入render阶段。其优先级较低，执行时间较长。此时：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("fiber.updateQueue = {\n  baseState: {\n    blackTheme: true,\n    text: 'H'\n  },\n  firstBaseUpdate: null,\n  lastBaseUpdate: null\n  shared: {\n    pending: u1\n  },\n  effects: null\n};\n")])])]),n("p",[e._v("在u1完成render阶段前用户通过键盘输入字母“I”，产生了u2。u2属于受控的用户输入，优先级高于u1，于是中断u1产生的render阶段。")]),e._v(" "),n("p",[e._v("此时：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("fiber.updateQueue.shared.pending === u2 ----\x3e u1\n                                     ^        |\n                                     |________|\n// 即\nu2.next === u1;\nu1.next === u2;\n")])])]),n("p",[e._v("其中u2优先级高于u1。")]),e._v(" "),n("p",[e._v("接下来进入u2产生的render阶段。")]),e._v(" "),n("p",[e._v("在processUpdateQueue 中， share.pending会被断开，并且拼接在baseUpdate只能够")]),e._v(" "),n("p",[e._v("update 顺序：ui -- u2\n遍历baseUpdate ，处理u2（优先级高）")]),e._v(" "),n("p",[e._v("由于u2不是baseUpdate中的第一个update，在其之前的u1由于优先级不够被跳过。")]),e._v(" "),n("p",[e._v("update之间可能有依赖关系，所以被跳过的update及其后面所有update会成为下次更新的baseUpdate。（即u1 -- u2）。")]),e._v(" "),n("p",[e._v("最终u2完成render - commit阶段。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("fiber.updateQueue = {\n  baseState: {\n    blackTheme: true,\n    text: 'HI'\n  },\n  firstBaseUpdate: u1,\n  lastBaseUpdate: u2\n  shared: {\n    pending: null\n  },\n  effects: null\n};\n")])])]),n("p",[e._v("然后commit阶段结尾会再调度一次更新，基于baseQueue 保存的firstBaseUpdate 进行更新")]),e._v(" "),n("p",[e._v("最后两次更新完成：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("fiber.updateQueue = {\n  baseState: {\n    blackTheme: false,\n    text: 'HI'\n  },\n  firstBaseUpdate: null,\n  lastBaseUpdate: null\n  shared: {\n    pending: null\n  },\n  effects: null\n};\n")])])]),n("p",[e._v("我们看在第二次更新，u2又被执行了一次，相应的render阶段的生命周期勾子componentWillXXX会触发两次，所以标记上unsafe")]),e._v(" "),n("h4",{attrs:{id:"update的完整性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#update的完整性"}},[e._v("#")]),e._v(" update的完整性")]),e._v(" "),n("p",[e._v("在render阶段，shared.pending 的环被打开，连接在updateQueue.laseBaseUpdate后面。\n实际上shared.pending会被同时连接在workInProgress updateQueue.lastBaseUpdate与current updateQueue.lastBaseUpdate后面。")]),e._v(" "),n("p",[e._v("在render阶段被中断后重新开始，会基于current updateQueue 克隆出workInProgress updateQueue。由于current.updateQueue.laseBaseUpdate 中保存了上一次的Update，所以不会丢失。")]),e._v(" "),n("p",[e._v("在commit阶段完成渲染，由于workInProgress.updateQueue.laseBaseUpdate中保存了上一次的Update，所以workInProgress Fiber树会成current Fiber树后也不会造成Update丢失。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const current = workInProgress.alternate;\n  if (current !== null) {\n    const currentQueue: UpdateQueue<State> = (current.updateQueue: any);\n    const currentLastBaseUpdate = currentQueue.lastBaseUpdate;\n    if (currentLastBaseUpdate !== lastBaseUpdate) {\n      if (currentLastBaseUpdate === null) {\n        currentQueue.firstBaseUpdate = firstPendingUpdate;\n      } else {\n        currentLastBaseUpdate.next = firstPendingUpdate;\n      }\n      currentQueue.lastBaseUpdate = lastPendingUpdate;\n  }\n}\n")])])]),n("h4",{attrs:{id:"如何保证状态依赖的连续性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何保证状态依赖的连续性"}},[e._v("#")]),e._v(" 如何保证状态依赖的连续性")]),e._v(" "),n("p",[e._v("当某个Update由于优先级被跳过，保存在baseUpdate中不仅是该Update，还包括链表中该Update中后续的所有Update。目的是为了保证状态的连续性。")]),e._v(" "),n("p",[e._v("比如：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("baseUpdate: \nshared.penging: A1 --\x3e B2 --\x3e C1 --\x3e D2\n\n")])])]),n("p",[e._v("ABCD 表示要插入页面的元素，数字表示优先级，越小优先级越高")]),e._v(" "),n("p",[e._v("第一次render， 优先级为1")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("baseState: '',\nbaseUpdate: null\nrender阶段使用的Update：【A1，C1】\nmemoizedState: AC\n")])])]),n("p",[e._v("第二次render， 优先级为2")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("baseState: A,\nbaseUpdate: B2--\x3eC1--\x3eD2\nrender阶段使用的update：【B2，C1, D2】\nmemoizedState: 'ABCD'\n")])])]),n("p",[e._v("为什么baseState不是第一次的memoizedState，是因为B2被跳过了，当Update被跳过时：下次更新的baseState !== 上次的memoizedState")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 优先级不足，跳过这个更新，如果他是首次跳出更新，前一个update/state作为新的基础的update/state.\nconst clone: Update<State> = {\n  eventTime: updateEventTime,\n  lane: updateLane,\n  suspenseConfig: update.suspenseConfig,\n\n  tag: update.tag,\n  payload: update.payload,\n  callback: update.callback,\n\n  next: null,\n};\nif (newLastBaseUpdate === null) {\n  newFirstBaseUpdate = newLastBaseUpdate = clone;\n  newBaseState = newState;\n} else {\n  newLastBaseUpdate = newLastBaseUpdate.next = clone;\n}\n")])])]),n("h3",{attrs:{id:"reactdom-render"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#reactdom-render"}},[e._v("#")]),e._v(" ReactDOM.render")]),e._v(" "),n("p",[e._v("renderDOM.render 会渲染FiberRootNode 和 rootFiber。其中fiberRootNode 是整个应用的根节点，rootFiber是要渲染组件所在树的根节点。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function legacyRenderSubtreeIntoContainer {\n  if (!root) {\n    // Initial mount\n    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(\n      container, /// 指ReactDOM.render的第二个参数（即应用挂载的DOM节点）\n      forceHydrate,\n    );\n    fiberRoot = root;\n  }\n}\n")])])]),n("p",[e._v("legacyCreateRootFromDOMContainer 方法会调用createFiberRoot方法完成FiberNodeRoot和rootFiber创建以及其关联，并初始化updateQueue")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("export function createFiberRoot(\n    containerInfo: any,\n    tag: RootTag,\n    hydrate: boolean,\n    hydrationCallbacks: null | SuspenseHydrationCallbacks,\n): FiberRoot {\n    // 创建fiberRootNode\n    const root:FiberRoot = (new FiberRootNode(containerInfo, tag, hydrate): any);\n\n    // 创建rootFiber\n    const uninitializedFiber = createHostRootFiber(tag);\n\n    // 连接rootFiber 与 fiberRootNode\n    root.current = uninitializedFiber;\n    uninitialized.stateNode = root;\n\n    // 初始化updateQueue\n    initializeUpdateQueue(unitializedFiber)；\n\n    return root;\n}\n\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("           stateNode\nrootFiber  --------\x3e  FiberNodeRoot\n           <--------\n           current\n")])])]),n("h4",{attrs:{id:"创建update"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#创建update"}},[e._v("#")]),e._v(" 创建update")]),e._v(" "),n("p",[e._v("updateConContainer代码如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function updateContainer(\n    element: ReactNodeList,\n    container: OpaqueRoot,\n    parentComponent: ?React$Component<any, any>,\n    callback: ?Function\n): Lane {\n    // ...\n\n    // 创建update\n    const update = createUpdate（eventTime,lane, suspenseConfig);\n  \n    // update.payload为需要挂载在根节点的组件\n    update.payload = {element};\n\n    // callback为ReactDOM.render的第三个参数 - 回调函数\n    callback = callback === undefined ? null : callback;\n    if (callback !== null) {\n        update.callback = callback;\n    }\n\n    // 将生成的update加入updateQueue\n    enqueueUpdate(current, update);\n    // 调度更新\n    scheduleUpdateOnFiber(current, lane, eventTime);\n    //...\n}\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("export function scheduleUpdateOnFiber(\n  fiber: Fiber,\n  lane: Lane,\n  eventTime: number,\n) {\n  // 检查是否有无限更新\n  checkForNestedUpdates();\n \n  ...\n  // 向上收集fiber.childLanes\n  const root = markUpdateLaneFromFiberToRoot(fiber, lane);\n \n  ...\n \n  // 在root上标记更新，将update的lane放到root.pendingLanes\n  markRootUpdated(root, lane, eventTime);\n \n  ...\n \n  // 根据Scheduler的优先级获取到对应的React优先级\n  const priorityLevel = getCurrentPriorityLevel();\n \n  if (lane === SyncLane) {\n    // 本次更新是同步的，例如传统的同步渲染模式\n    if (\n      (executionContext & LegacyUnbatchedContext) !== NoContext &&\n      (executionContext & (RenderContext | CommitContext)) === NoContext\n    ) {\n      // 如果是本次更新是同步的，并且当前还未渲染，意味着主线程空闲，并没有React的更新任务在执行，那么调用performSyncWorkOnRoot开始执行同步任务\n \n      ...\n \n      performSyncWorkOnRoot(root);\n    } else {\n      // 如果是本次更新是同步的，不过当前有React更新任务正在进行，而且因为无法打断，所以调用ensureRootIsScheduled,目的是去复用已经在更新的任务，让这个已有的任务把这次更新顺便做了\n      ensureRootIsScheduled(root, eventTime);\n      ...\n    }\n  } else {\n \n    ...\n \n    // 如果是更新是异步的，调用ensureRootIsScheduled去进入异步调度\n    ensureRootIsScheduled(root, eventTime);\n    schedulePendingInteractions(root, lane);\n  }\n \n  ...\n}\n")])])]),n("p",[e._v("ensureRootIsScheduled 实现：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function ensureRootIsScheduled(root: FiberRoot, currentTime: number) {\n  // 获取旧任务\n  const existingCallbackNode = root.callbackNode;\n \n  // 记录任务的过期时间，检查是否有过期任务，有则立即将它放到root.expiredLanes，\n  // 便于接下来将这个任务以同步模式立即调度\n  markStarvedLanesAsExpired(root, currentTime);\n \n  // 获取renderLanes\n  const nextLanes = getNextLanes(\n    root,\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\n  );\n \n  // 获取renderLanes对应的任务优先级\n  const newCallbackPriority = returnNextLanesPriority();\n \n  if (nextLanes === NoLanes) {\n    // 如果渲染优先级为空，则不需要调度\n    if (existingCallbackNode !== null) {\n      cancelCallback(existingCallbackNode);\n      root.callbackNode = null;\n      root.callbackPriority = NoLanePriority;\n    }\n    return;\n  }\n \n  // 如果存在旧任务，那么看一下能否复用\n  if (existingCallbackNode !== null) {\n \n    // 获取旧任务的优先级\n    const existingCallbackPriority = root.callbackPriority;\n \n    // 如果新旧任务的优先级相同，则无需调度\n    if (existingCallbackPriority === newCallbackPriority) {\n      return;\n    }\n    // 代码执行到这里说明新任务的优先级高于旧任务的优先级\n    // 取消掉旧任务，实现高优先级任务插队\n    cancelCallback(existingCallbackNode);\n  }\n \n  // 调度一个新任务\n  let newCallbackNode;\n  if (newCallbackPriority === SyncLanePriority) {\n \n    // 若新任务的优先级为同步优先级，则同步调度，传统的同步渲染和过期任务会走这里\n    newCallbackNode = scheduleSyncCallback(\n      performSyncWorkOnRoot.bind(null, root),\n    );\n  } else if (newCallbackPriority === SyncBatchedLanePriority) {\n \n    // 同步模式到concurrent模式的过渡模式：blocking模式会走这里\n    newCallbackNode = scheduleCallback(\n      ImmediateSchedulerPriority,\n      performSyncWorkOnRoot.bind(null, root),\n    );\n  } else {\n    // concurrent模式的渲染会走这里\n \n    // 根据任务优先级获取Scheduler的调度优先级\n    const schedulerPriorityLevel = lanePriorityToSchedulerPriority(\n      newCallbackPriority,\n    );\n \n    // 计算出调度优先级之后，开始让Scheduler调度React的更新任务\n    newCallbackNode = scheduleCallback(\n      schedulerPriorityLevel,\n      performConcurrentWorkOnRoot.bind(null, root),\n    );\n  }\n \n  // 更新root上的任务优先级和任务，以便下次发起调度时候可以获取到\n  root.callbackPriority = newCallbackPriority;\n  root.callbackNode = newCallbackNode;\n}\n")])])]),n("h4",{attrs:{id:"reactdom-render流程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#reactdom-render流程"}},[e._v("#")]),e._v(" ReactDOM.render流程")]),e._v(" "),n("p",[n("img",{attrs:{src:"/images/react/ReactDOM.render%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png",alt:""}})]),e._v(" "),n("h3",{attrs:{id:"this-setstate"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#this-setstate"}},[e._v("#")]),e._v(" this.setState")]),e._v(" "),n("p",[e._v("Component类型组件使用setState 在内部会调用 enqueueSetState")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Component.prototype.setState = function(partialState, callback) {\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n")])])]),n("p",[e._v("enqueueSetState 内部调用逻辑：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("enqueueSetState: function (inst, payload, callback) {\n    // 通过组件实例获取对应fiber\n    var fiber = get(inst);\n    var eventTime = requestEventTime();\n    // 获取优先级\n    var lane = requestUpdateLane(fiber);\n    // 创建update\n    var update = createUpdate(eventTime, lane);\n\n    // payload为：this.setState的第一个传参\n    update.payload = payload;\n    \n    // 赋值回调函数\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback(callback, 'setState');\n      }\n\n      update.callback = callback;\n    }\n\n    // 将update 插入到updateQueue中\n    enqueueUpdate(fiber, update);\n\n    // 更新调度\n    var root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n\n    if (root !== null) {\n      entangleTransitions(root, fiber, lane);\n    }\n\n    {\n      markStateUpdateScheduled(fiber, lane);\n    }\n}\n")])])]),n("h3",{attrs:{id:"this-forceupdate"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#this-forceupdate"}},[e._v("#")]),e._v(" this.forceUpdate")]),e._v(" "),n("p",[e._v("与setState不同的是：会添加tag：ForceUpdate")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  enqueueForceUpdate: function (inst, callback) {\n    var fiber = get(inst);\n    var eventTime = requestEventTime();\n    var lane = requestUpdateLane(fiber);\n    var update = createUpdate(eventTime, lane);\n    // 赋值tag为ForceUpdate\n    update.tag = ForceUpdate;\n\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback(callback, 'forceUpdate');\n      }\n\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    var root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n\n    if (root !== null) {\n      entangleTransitions(root, fiber, lane);\n    }\n\n    {\n      markForceUpdateScheduled(fiber, lane);\n    }\n  }\n")])])]),n("p",[e._v("然后在判断ClassComponent 是否需要更新时，根据这个tag 用来区分是否是fouceUpdate")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function checkHasForceUpdateAfterProcessing(): boolean {\n  return hasForceUpdate;\n}\nfunction checkShouldComponentUpdate(\n  workInProgress,\n  ctor,\n  oldProps,\n  newProps,\n  oldState,\n  newState,\n  nextContext,\n) {\n  const instance = workInProgress.stateNode;\n  if (typeof instance.shouldComponentUpdate === 'function') {\n    let shouldUpdate = instance.shouldComponentUpdate(\n      newProps,\n      newState,\n      nextContext,\n    );\n    return shouldUpdate;\n  }\n\n  if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n    return (\n      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)\n    );\n  }\n\n  return true;\n}\n const shouldUpdate =\n  checkHasForceUpdateAfterProcessing() ||\n  checkShouldComponentUpdate(\n    workInProgress,\n    ctor,\n    oldProps,\n    newProps,\n    oldState,\n    newState,\n    nextContext,\n  );\n")])])]),n("ul",[n("li",[e._v("checkHasForceUpdateAfterProcessing： 用来区分是否是forceUpdate")]),e._v(" "),n("li",[e._v("checkShouldComponentUpdate：内部会调用shouldComponentUpdate，以及ClassComponent为PureComponent时会浅比较state与props。")])]),e._v(" "),n("p",[e._v("当tag为forceUpdate时，不会受shouldComponentUpdate和PureComponent影响，一定会更新。")])])}),[],!1,null,null,null);t.default=r.exports}}]);