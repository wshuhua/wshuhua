(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{503:function(n,t,e){"use strict";e.r(t);var a=e(28),s=Object(a.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h3",{attrs:{id:"枚举-enum"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#枚举-enum"}},[n._v("#")]),n._v(" 枚举: enum")]),n._v(" "),e("p",[n._v("数字枚举")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("enum Status {\n    Uploading,\n    Success,\n    Failed = 8\n}\n\nconsole.log(Status.Uploading)  // 0\nconsole.log(Status.Success) // 1\nconsole.log(Status.Failed) // 8\n\nenum Status {\n    Uploading = 3,\n    Success,\n    Failed = 8\n}\n\nconsole.log(Status.Uploading)  // 3\nconsole.log(Status.Success) // 4\nconsole.log(Status.Failed) // 8\n")])])]),e("ul",[e("li",[n._v("如果没有初始化，默认初始化值为0，每项+1")]),n._v(" "),e("li",[n._v("如果有初始化，则在初始化值的基础上，每项+1")])]),n._v(" "),e("p",[n._v("字符串枚举")]),n._v(" "),e("ul",[e("li",[n._v("每个成员必须用字符串文字或其他字符串枚举成员进行常量初始化，否则会报Error：Enum member must have initializer")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("enum Status {\n    Uploading = 'Uploading',\n    Success = 'Success',\n    Failed = 'Failed'\n}\n\nconsole.log(Status.Uploading)\nconsole.log(Status.Success)\nconsole.log(Status.Failed)\n")])])]),e("p",[n._v("异构枚举")]),n._v(" "),e("ul",[e("li",[n._v("不建议使用")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('enum BooleanLikeHeterogeneousEnum {\n    No = 0,\n    Yes = "YES",\n}\n')])])]),e("p",[n._v("反向映射")]),n._v(" "),e("ul",[e("li",[n._v("一个枚举被编译成一个存储forward（name- > value）和reverse（value- > name）映射的对象")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('enum Enum {\n    A\n  }\nconst a = Enum.A; // 0\nconst nameOfA = Enum[a]; // "A"\n\n \x3c!-- var Enum;\n(function (Enum) {\n  Enum[Enum["A"] = 0] = "A";\n})(Enum || (Enum = {})); --\x3e\n\n')])])]),e("p",[n._v("常数枚举")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("const enum Directions {\n    Up,\n    Down,\n    Left,\n    Right\n}\n\nconst directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\nconsole.log(directions)\n\x3c!--会被编译成 var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */]; --\x3e\n")])])]),e("h3",{attrs:{id:"函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[n._v("#")]),n._v(" 函数")]),n._v(" "),e("p",[n._v("可以声明具名函数和匿名函数")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function fn(x) { // 名字为b的函数\n  return x;\n}\nconst fn1 = function (x) { // 没有名字的函数声明，直接将函数值赋给变量b1\n  return x;\n}\n")])])]),e("p",[n._v("函数的类型包含参数类型和返回值类型两个部分. 可选参数名必需放在必传的参数后面")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("- this\n\n返回一个函数：\n")])])]),e("p",[n._v("const fn2: (y: number) => number = function (x: number): number {\nreturn x;\n}")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("\nconst b14 = {\n  m1: 1,\n  m2: function (): () => void { // 返回一个函数\n    return function (): void {\n      console.log(this.m1);\n    };\n  },\n}\n\nb14.m2()(); // 打印：undefined\n")])])]),e("p",[n._v("这里的this是window对象（如果是严格模式的话，this为undefined），因为返回一个函数再执行，相当于在顶层作用域下执行：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function (): void {\n  console.log(this.m1); // 打印：undefined\n};\n")])])]),e("p",[n._v("解决方案：\n使用箭头函数解决这个问题，因为箭头函数捕获函数创建时候的this而不是函数调用时的this。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("const b14 = {\n  m1: 1,\n  m2: function (): () => void { // 返回一个函数\n    return (): void => {\n      console.log(this.m1);\n    };\n  },\n}\nb14.m2()(); // 打印：1\n\n// 这里的this就是函数创建时候的this，即b14对象\n")])])]),e("p",[n._v("传递一个函数作为参数：\n打开noImplicitThis配置，在使用隐含any类型的this的时候会报错。打开noImplicitThis配置之后，下面这段代码，this的位置会报错：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("const b15 = {\n  m1: 1,\n  m2: function (x: () => void): void { // 将函数作为一个参数\n    x();\n  },\n};\n\nconst b16 = function (): void {\n  console.log(this.m1);\n}\n\nb15.m2(b16); // 打印：undefined\n")])])]),e("h3",{attrs:{id:"类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类"}},[n._v("#")]),n._v(" 类")]),n._v(" "),e("ul",[e("li",[n._v("类可以从基类继承属性和方法。")]),n._v(" "),e("li",[n._v("public、private、protected是类成员的三个修饰符。分别表示公有成员、私有成员、被保护的成员。")]),n._v(" "),e("li",[n._v("TypeScript 3.8 带来了私有字段，私有字段以#符号开头")]),n._v(" "),e("li",[n._v("每个私有字段名称都唯一地作用于其包含的类。")]),n._v(" "),e("li",[n._v("【private修饰符修饰的私有成员】和【前面加上#表示的私有字段】都只能在包含它们的类中被访问。前者能修饰方法和属性，后者只能表示属性不能表示方法。")]),n._v(" "),e("li",[n._v("protected成员不能被派生类的实例访问")]),n._v(" "),e("li",[n._v("构造函数被标记为protected，这意味着这个类不能在包含它的类外面被实例化，但是可以被扩展.")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("class C11 {\n  protected m1: number = 123;\n}\n\nclass C12 extends C11 {\n  m2(): void {\n    console.log(this.m1);\n  }\n}\n\nconst c12 = new C12();\nc12.m2(); // 打印：123\nc12.m1; // 报错：属性“m1”受保护，只能在类“C11”及其子类中访问.\n\nclass C13 {\n  m1: number;\n  protected constructor(x) {\n    this.m1 = x;\n  }\n}\n\nclass C14 extends C13 {\n  constructor(x) {\n    super(x);\n  }\n}\n\nconst c13 = new C13(1); // 报错：类“C13”的构造函数是受保护的，仅可在类声明中访问\nconst c14 = new C14(1);\nconsole.log(c14.m1); // 打印：1\n")])])]),e("h3",{attrs:{id:"装饰器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#装饰器"}},[n._v("#")]),n._v(" 装饰器 @")]),n._v(" "),e("ul",[e("li",[n._v("每个装饰器的表达式从上到下进行评估，然后结果被称为从下到上的函数。")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function setName() {\n    console.log('get setName');\n    return (target: any) => {\n        console.log(target, 'setName');\n    }\n}\nfunction setAge() {\n    console.log('get setAge');\n    return (target: any) => {\n        console.log(target, 'setAge');\n    }\n}\n\n@setName()\n@setAge()\n\n// 执行结果为\n// get setName\n// get setAge\n// setAge\n// setAge\n")])])]),e("h4",{attrs:{id:"类装饰器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类装饰器"}},[n._v("#")]),n._v(" 类装饰器")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function addName(constructor: new() => any) {\n    constructor.prototype.name = 'liston';\n}\n@addName\nclass ClassD {}\ninterface ClassD {\n    name: string\n}\n// 接口添加到 类的原型对象上，注意：interface需要在class 之后添加\nconst d = new ClassD();\nconsole.log(d, 'ClassD')\nconsole.log(d.name)\n")])])]),e("h4",{attrs:{id:"方法装饰器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#方法装饰器"}},[n._v("#")]),n._v(" 方法装饰器")]),n._v(" "),e("p",[n._v("在一个方法声明前被声明，装饰器应用到方法的属性描述符上，并且可以用来观察、修改、或者替代一个方法定义。一个方法装饰器不能被用在声明文件中、重载中、或者在任何环境上下文（比如declare类）中\n方法装饰器的表达式在运行时作为一个函数调用，包含三个参数：")]),n._v(" "),e("ol",[e("li",[n._v("target：对于静态成员，是类的构造函数；对于实例成员，是类的原型（prototype）。")]),n._v(" "),e("li",[n._v("propertyKey：成员的名称。")]),n._v(" "),e("li",[n._v("descriptor：成员的属性描述符。（注意：属性描述符在你的脚本目标小于ES5的时候会是undefined）")])]),n._v(" "),e("p",[n._v("属性描述符：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("interface PropertyDescriptor {\n    configurable?: boolean;\n    enumerable?: boolean;\n    value?: any;\n    writable?: boolean;\n    get?(): any;\n    set?(v: any): void;\n}\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("class C26 {\n  @writable(false)\n  m1() {\n    console.log(\"aaa\");\n  }\n}\n\nfunction writable(x: boolean) {\n  return function (\n    target: any,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) {\n    return {\n      writable: false,\n    };\n  };\n}\n\nconst c26 = new C26();\nc26.m1 = () => {\n  console.log(\"bbb\");\n};\n// ERROR: decorators.ts:123 Uncaught TypeError: Cannot assign to read only property 'm1' of object '#<C26>'...\n")])])]),e("h4",{attrs:{id:"存取器装饰器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#存取器装饰器"}},[n._v("#")]),n._v(" 存取器装饰器")]),n._v(" "),e("ul",[e("li",[n._v("存取器装饰器应用在存取器的属性描述符")])]),n._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[n._v("注意：")]),n._v(" "),e("p",[n._v("TypeScript不允许同时装饰成员的get和set存取器。该成员的所有装饰器必须应用到文档顺序的第一个存取器。这是因为装饰器应用于属性描述符，属性描述符将get和set存取器组合在一起，而不是分开声明。否则会报Error：Decorators cannot be applied to multiple get/set accessors of the same name")])]),n._v(" "),e("h4",{attrs:{id:"属性装饰器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#属性装饰器"}},[n._v("#")]),n._v(" 属性装饰器")]),n._v(" "),e("ul",[e("li",[n._v("属性装饰器在一个属性声明前声明。一个属性装饰器不能用在一个声明文件中，或者任何其他的环境上下文（比如一个declare类）中")]),n._v(" "),e("li",[n._v("属性装饰器的表达式会作为一个函数在运行时被调用，使用以下两个参数：")])]),n._v(" "),e("p",[n._v("1.target: 对于静态成员来说是类的构造函数，对于实例成员来说是类的原型。")]),n._v(" "),e("p",[n._v("2.propertyKey: 成员的名字。")]),n._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[n._v("注意：")]),n._v(" "),e("p",[n._v("因为TypeScript中初始化属性装饰器的机制，一个属性描述符不能用作一个属性装饰器的参数。这是因为目前当定义原型的成员的时候，没有机制来描述一个实例属性，并且没有办法来观察或者修改属性的初始化。返回值也被忽视了。因此，一个属性装饰器只能用来观察类中已经明确声明了一个名字的属性")])]),n._v(" "),e("h4",{attrs:{id:"参数装饰器-babel-暂不支持"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参数装饰器-babel-暂不支持"}},[n._v("#")]),n._v(" 参数装饰器(babel 暂不支持)")]),n._v(" "),e("p",[n._v("参数装饰器在参数声明前被声明。参数装饰器应用于类的构造函数声明或方法声明。参数装饰器不能用在声明文件中、重载中、或者在任何其他环境上下文（比如一个declare类）中。")]),n._v(" "),e("p",[n._v("参数装饰器的会作为函数在运行时被调用，带着以下三个参数")]),n._v(" "),e("ol",[e("li",[n._v("target: 对于静态成员，是类的构造函数；对于实例成员，是类的原型（prototype）。")]),n._v(" "),e("li",[n._v("propertyKey: 成员的名称。")]),n._v(" "),e("li",[n._v("parameterIndex: 函数的参数列表中参数的序号索引。")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("class C29 {\n  m1 (@decoratorC29 x: number) {\n    console.log(x);\n  }\n\n  m2 () {\n    console.log('456');\n  }\n}\n\nfunction decoratorC29 (\n  target: any,\n  propertyKey: string | symbol,\n  parameterIndex: number\n) {\n  target.m2();\n}\n")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);