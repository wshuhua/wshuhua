(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{502:function(v,t,a){"use strict";a.r(t);var _=a(28),e=Object(_.a)({},(function(){var v=this,t=v.$createElement,a=v._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h3",{attrs:{id:"_1-js引擎"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-js引擎"}},[v._v("#")]),v._v(" 1. js引擎")]),v._v(" "),a("p",[v._v("JavaScript引擎分类：")]),v._v(" "),a("ul",[a("li",[v._v("SpiderMonkey: 第一款JavaScript引擎,由BrenDan Eich开发(也就是JavaScript作者)")]),v._v(" "),a("li",[v._v("Chakra: 微软开发,用于IE浏览器")]),v._v(" "),a("li",[v._v("JavaScriptCore: WebKit中的JavaScript引擎,Apple公司开发")]),v._v(" "),a("li",[v._v("V8: Google开发的强大JavaScript引擎,也帮助Chrome从众多浏览器中脱颖而出")])]),v._v(" "),a("h3",{attrs:{id:"_2-v8引擎的原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-v8引擎的原理"}},[v._v("#")]),v._v(" 2. V8引擎的原理")]),v._v(" "),a("p",[v._v("V8是用C++编写的Google开源高性能JavaScript和WebAssembly引擎,它用于Chrome和Node.js等.\n它实现ECMAScript和WebAssembly,并在Windows7或更高版本,MacOs10.12+和使用x64,IA-32,ARM或MISP处理器的Linux系统上运行。")]),v._v(" "),a("p",[a("img",{attrs:{src:"/images/js/V8%E5%BC%95%E6%93%8E.png",alt:""}})]),v._v(" "),a("p",[v._v("v8引擎通过Parse 进行词法分析，语法分析后转换成AST抽象语法树,再通过Ignition转换器将其转换成字节码。")]),v._v(" "),a("h3",{attrs:{id:"_3-v8引擎的架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-v8引擎的架构"}},[v._v("#")]),v._v(" 3. V8引擎的架构")]),v._v(" "),a("ul",[a("li",[v._v("Parse：模块会将JavaScript代码转换成AST（抽象语法树），这是因为解释器并不认识JavaScript代码(如果函数没有被调用，那么是不会被转换成AST的)")]),v._v(" "),a("li",[v._v("Ignition：可以理解为解释器（转换器），将ast 转化为字节码，同时会收集TurboFan优化所需要的信息（比如函数参数的类型信息，有了类型才能进行真实的运算）,如果函数只调用一次，Ignition会执行解释执行ByteCode;")]),v._v(" "),a("li",[v._v("TurboFan：可以理解为编译器，可以将字节码编译为CPU可以直接执行的机器码；如果一个函数被多次调用，那么就会被标记为热点函数，那么就会经过TurboFan转换成优化的机器码，提高代码的执行性能")])]),v._v(" "),a("p",[v._v("特殊场景：机器码被还原为ByteCode，后续执行函数中，函数类型发生了变化（比如sum函数原来执行的是number类型，后来执行变成了string类型），之前优化的机器码并不能正确的处理运算，就会逆向的转换成字节码")]),v._v(" "),a("h3",{attrs:{id:"_4-v8引擎的解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-v8引擎的解析"}},[v._v("#")]),v._v(" 4. V8引擎的解析")]),v._v(" "),a("p",[v._v("V8引擎的解析图\n"),a("img",{attrs:{src:"/images/js/V8%E5%BC%95%E6%93%8E%E7%9A%84%E8%A7%A3%E6%9E%90%E5%9B%BE.png",alt:""}})]),v._v(" "),a("ol",[a("li",[a("p",[v._v("Blink(浏览器内核)将js代码交给V8引擎,Stream获取到源码进行编码转换")])]),v._v(" "),a("li",[a("p",[v._v("Scanner会进行词法分析(lexical analysis),词法分析会将代码转换成tokens")])]),v._v(" "),a("li",[a("p",[v._v("tokens会被转换成AST树,经过Parser和PreParser")])])]),v._v(" "),a("ul",[a("li",[v._v("3.1 Parser就是直接将tokens转成AST树架构")]),v._v(" "),a("li",[v._v("3.2 PreParser预解析,什么时候进行预解析呢? 存在不必要的函数会进行预解析。为了提高网页的运行效率，v8引擎通过Lazy Parsing(延迟解析)，将不必要立即执行的函数进行预解析。")])]),v._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[v._v("提示")]),v._v(" "),a("p",[v._v("Webkit 渲染引擎有一个优化，当渲染进程接收 HTML 文件字节流时，会先开启一个预解析线程，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析线程会提前下载这些数据。当渲染进程接收 HTML 文件字节流时，会先开启一个预解析线程，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析线程会提前下载这些数据。")])]),v._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[v._v("生成AST树后,会被Ignition转成字节码(bytecode),之后的过程就是代码的执行")])]),v._v(" "),a("h3",{attrs:{id:"_5-js代码执行过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-js代码执行过程"}},[v._v("#")]),v._v(" 5. js代码执行过程")]),v._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[v._v("提示")]),v._v(" "),a("ul",[a("li",[v._v("VO：Variable Object每一个执行上下文会被关联到一个变量对象称为AO")]),v._v(" "),a("li",[v._v("GO：Global Object")]),v._v(" "),a("li",[v._v("AO：Activation Object")]),v._v(" "),a("li",[v._v("ESC：执行上下文栈(Execution Context Stack,简称ECS),它是用于执行代码的调用栈")]),v._v(" "),a("li",[v._v("GEC：全局执行上下文（Global Execution Context） 全局的代码块为了执行构建的产物")]),v._v(" "),a("li",[v._v("FEC：函数执行上下文(Functional Execution Context）")])])]),v._v(" "),a("p",[v._v("js引擎会在执行代码之前,在堆内存中创建一个全局对象：GO")]),v._v(" "),a("ul",[a("li",[v._v("该对象所有的作用域(scope)都可以访问")]),v._v(" "),a("li",[v._v("里面会包含**Date,Array,String,Number,setTimeout,setInterval等等;")]),v._v(" "),a("li",[v._v("window属性指向自己")])]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[v._v('// GlobalObject\nvar globalObject = {\n   String: "类",\n   Date: "类",\n   setTimeout: "函数",\n   // ....\n   window: globalObject(指向本身),\n   name: undefined,\n   num1: undefined,\n   num2: undefined,\n   result: undefined\n}\n')])])]),a("h4",{attrs:{id:"执行上下文栈-调用栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文栈-调用栈"}},[v._v("#")]),v._v(" 执行上下文栈(调用栈)")]),v._v(" "),a("p",[v._v("js引擎内部有一个执行上下文栈(Execution Context Stack,简称ECS),它是用于执行代码(全局的代码块)的调用栈。")]),v._v(" "),a("p",[v._v("全局的代码块为了执行会构建一个Global Execution Context(GEC)\nGEC会被放入到ECS中执行。")]),v._v(" "),a("p",[v._v("GEC被放入到ECS中里面包含两部分内容:")]),v._v(" "),a("ol",[a("li",[v._v("在代码执行前,parser转成AST的过程中,会将全局定义的变量,函数等加入到GO中,但是并不会赋值(undefined)\n这个过程也称之为变量的作用域提升(hoisting)")]),v._v(" "),a("li",[v._v("在代码执行中,对变量赋值,或者执行其他的函数。")])]),v._v(" "),a("h4",{attrs:{id:"执行函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行函数"}},[v._v("#")]),v._v(" 执行函数")]),v._v(" "),a("p",[v._v("在执行的过程中执行到一个函数时,就会根据函数体创建一个函数执行上下文(Functional Execution Context/FEC),并且压入到EC Stack中.")]),v._v(" "),a("p",[v._v("FEC中包含三部分内容:")]),v._v(" "),a("ol",[a("li",[v._v("在解析函数成为AST树结构时,会创建一个Activation Object(AO):\nAO中包含形参,arguments,函数定义和指向函数对象,定义的变量")]),v._v(" "),a("li",[v._v("作用域链,由VO(在函数中就是AO对象)和父级VO组成,查找时会一层层查找")]),v._v(" "),a("li",[v._v("this绑定的值")])]),v._v(" "),a("p",[a("img",{attrs:{src:"/images/js/ECS.png",alt:""}})]),v._v(" "),a("h3",{attrs:{id:"_6-垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-垃圾回收"}},[v._v("#")]),v._v(" 6. 垃圾回收")]),v._v(" "),a("p",[v._v("JavaScript 中的数据是如何存储？")]),v._v(" "),a("ul",[a("li",[v._v("原始数据类型是存储在栈空间中的，引用类型的数据是存储在堆空间中的。")])]),v._v(" "),a("h4",{attrs:{id:"栈垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈垃圾回收"}},[v._v("#")]),v._v(" 栈垃圾回收：")]),v._v(" "),a("p",[v._v("当函数执行结束，JS引擎通过向下移动"),a("code",[v._v("ESP")]),v._v("（extended stack pointer）指针（记录调用栈当前执行状态的指针），来销毁该函数保存在栈中的执行上下文（变量环境、词法环境、this、outer）。")]),v._v(" "),a("h4",{attrs:{id:"堆垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#堆垃圾回收"}},[v._v("#")]),v._v(" 堆垃圾回收:")]),v._v(" "),a("h5",{attrs:{id:"代际假说"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代际假说"}},[v._v("#")]),v._v(" 代际假说")]),v._v(" "),a("p",[v._v("特点：")]),v._v(" "),a("ul",[a("li",[v._v("1、大部分对象存活时间很短")]),v._v(" "),a("li",[v._v("2、不被销毁的对象，会活的更久\n分类：\nV8 中会把堆分为"),a("code",[v._v("新生代")]),v._v("和"),a("code",[v._v("老生代")]),v._v("两个区域。")])]),v._v(" "),a("p",[a("code",[v._v("新生代")]),v._v("和"),a("code",[v._v("老生代")]),v._v("划分区别：")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("时间上：新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象，占用空间大。")])]),v._v(" "),a("li",[a("p",[v._v("容量上：新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。")])]),v._v(" "),a("li",[a("p",[v._v("副垃圾回收器，主要负责新生代的垃圾回收。")])]),v._v(" "),a("li",[a("p",[v._v("主垃圾回收器，主要负责老生代的垃圾回收。")])])]),v._v(" "),a("h5",{attrs:{id:"垃圾回收器的工作流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收器的工作流程"}},[v._v("#")]),v._v(" 垃圾回收器的工作流程")]),v._v(" "),a("ol",[a("li",[a("p",[v._v("标记：标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象（标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据）")])]),v._v(" "),a("li",[a("p",[v._v("回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象")])]),v._v(" "),a("li",[a("p",[v._v("内存整理：回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片。")])])]),v._v(" "),a("h4",{attrs:{id:"副垃圾回收器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#副垃圾回收器"}},[v._v("#")]),v._v(" 副垃圾回收器")]),v._v(" "),a("p",[v._v("功能：")]),v._v(" "),a("ul",[a("li",[v._v("副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区。")])]),v._v(" "),a("p",[v._v("新生代中用 "),a("code",[v._v("Scavenge")]),v._v(" 算法来处理。\n"),a("code",[v._v("Scavenge")]),v._v(" 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示：")]),v._v(" "),a("p",[a("img",{attrs:{src:"/images/js/space.png",alt:""}})]),v._v(" "),a("p",[v._v("新加入的对象都会存放到"),a("code",[v._v("对象区域")]),v._v("，当对象区域快被写满时，就需要执行一次垃圾清理操作。")]),v._v(" "),a("p",[v._v("在垃圾回收过程中，首先要对对象区域中的垃圾做"),a("code",[v._v("标记")]),v._v("；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象"),a("code",[v._v("复制")]),v._v("到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。")]),v._v(" "),a("p",[v._v("完成复制后，"),a("code",[v._v("对象区域与空闲区域进行角色翻转")]),v._v("，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。")]),v._v(" "),a("p",[v._v("新生代只有1-8M，是故意设置这么小的。新生代设置大了，一次垃圾回收的时间就会变长。\n由于新生代中采用的 "),a("code",[v._v("Scavenge")]),v._v(" 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。")]),v._v(" "),a("p",[v._v("正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了"),a("code",[v._v("对象晋升策略")]),v._v("，也就是"),a("code",[v._v("经过两次垃圾回收依然还存活的对象，会被移动到老生区中")]),v._v("。")]),v._v(" "),a("h4",{attrs:{id:"主垃圾回收器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主垃圾回收器"}},[v._v("#")]),v._v(" 主垃圾回收器")]),v._v(" "),a("p",[v._v("主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。\n因此老生区中的对象有两个特点，一个是"),a("code",[v._v("对象占用空间大")]),v._v("，另一个是"),a("code",[v._v("对象存活时间长")]),v._v("。")]),v._v(" "),a("p",[v._v("由于老生区的对象比较大，若要在老生区中使用 "),a("code",[v._v("Scavenge")]),v._v(" 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用"),a("code",[v._v("标记 - 清除（Mark-Sweep）")]),v._v("的算法进行垃圾回收的。下面我们来看看该算法是如何工作的。")]),v._v(" "),a("ol",[a("li",[a("p",[v._v("首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。")])]),v._v(" "),a("li",[a("p",[v._v("接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：\n"),a("img",{attrs:{src:"/images/js/mark.png",alt:""}})])])]),v._v(" "),a("p",[v._v("对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——"),a("code",[v._v("标记 - 整理（Mark-Compact")]),v._v("），这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存\n"),a("img",{attrs:{src:"/images/js/compact.png",alt:""}})]),v._v(" "),a("h5",{attrs:{id:"全停顿"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全停顿"}},[v._v("#")]),v._v(" 全停顿")]),v._v(" "),a("p",[v._v("由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做"),a("code",[v._v("全停顿（Stop-The-World）")]),v._v("。\n"),a("img",{attrs:{src:"/images/js/stopWorld.png",alt:""}})]),v._v(" "),a("p",[v._v("在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了 200 毫秒，在这 200 毫秒内，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行的，这将会造成页面的"),a("code",[v._v("卡顿现象")]),v._v("。")]),v._v(" "),a("h6",{attrs:{id:"增量标记"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#增量标记"}},[v._v("#")]),v._v(" 增量标记")]),v._v(" "),a("p",[v._v("为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为"),a("code",[v._v("增量标记（Incremental Marking）")]),v._v("算法。如下图所示：\n"),a("img",{attrs:{src:"/images/js/incremental.png",alt:""}})]),v._v(" "),a("p",[v._v("使用"),a("code",[v._v("增量标记")]),v._v("算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。")])])}),[],!1,null,null,null);t.default=e.exports}}]);