(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{505:function(e,n,r){"use strict";r.r(n);var t=r(28),s=Object(t.a)({},(function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h3",{attrs:{id:"_01-整体流程概述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_01-整体流程概述"}},[e._v("#")]),e._v(" 01. 整体流程概述")]),e._v(" "),r("p",[e._v("架构体系体现如图所示：")]),e._v(" "),r("p",[r("img",{attrs:{src:"/images/react/%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png",alt:""}})]),e._v(" "),r("p",[e._v("workInProgress 代表当前已创建的 workInProgress fiber。")]),e._v(" "),r("p",[e._v("performUnitOfWork 方法会创建下一个 Fiber 节点并赋值给 workInProgress，并将 workInProgress 与已创建的 Fiber 节点连接起来构成 Fiber 树。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function performUnitOfWork(unitOfWork) {\n  var current = unitOfWork.alternate;\n  setCurrentFiber(unitOfWork);\n  var next;\n\n  if ( (unitOfWork.mode & ProfileMode) !== NoMode) {\n    startProfilerTimer(unitOfWork);\n    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n  } else {\n    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);\n  }\n\n  resetCurrentFiber();\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n\n  if (next === null) {\n    completeUnitOfWork(unitOfWork);\n  } else {\n    workInProgress = next;\n  }\n\n  ReactCurrentOwner$2.current = null;\n}\n\n")])])]),r("p",[e._v("我们知道 Fiber Reconciler 是从 Stack Reconciler 重构而来，通过遍历的方式实现可中断的递归，所以 performUnitOfWork 的工作可以分为两部分：“递”和“归”。")]),e._v(" "),r("p",[e._v("举例说明整个调用顺序")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('function App() {\n  return (\n    <div>\n      <span>wsh</span>\n      age: 18\n    </div>\n  )\n}\n\nReactDOM.render(<App />, document.getElementById("root"));\n')])])]),r("p",[r("img",{attrs:{src:"/images/react/render%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B.png",alt:""}})]),e._v(" "),r("p",[e._v("render 阶段执行顺序如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('rootFiber beginWork\nApp Fiber beginWork\ndiv Fiber beginWork\n"age: 18" Fiber beginWork beginWork\n"age: 18" Fiber completeWork\nspan Fiber completeWork\ndiv Fiber completeWork\nApp Fiber completeWork\nrootFiber Fiber completeWork\n')])])]),r("h3",{attrs:{id:"_02-递阶段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_02-递阶段"}},[e._v("#")]),e._v(" 02. 递阶段")]),e._v(" "),r("p",[e._v("首先从 RootFiber 开始向下深度优先遍历。为遍历到的每个 Fiber 节点调用 beginWork 方法。\n该方法会根据传入的 Fiber 节点创建子 Fiber 节点，并将这两个 Fiber 节点连接起来。\n当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段。")]),e._v(" "),r("p",[e._v("源码大致如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function beginWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n){\n  // ...\n}\n")])])]),r("ul",[r("li",[e._v("current：当前组件对应的 Fiber 节点在上一次更新时的 Fiber 节点，即 workInProgress.alternate")]),e._v(" "),r("li",[e._v("workInProgress：当前组件对应的 Fiber 节点")]),e._v(" "),r("li",[e._v("renderLanes：优先级相关，Scheduler 使用")])]),e._v(" "),r("p",[e._v("在 mount 首次渲染时，不存在当前组件对应的 Fiber 节点在上一次更新时的 Fiber 节点，current === null\n组件 update 时，current !== null。")]),e._v(" "),r("p",[e._v("通过【current === null】来区分组件是处于 mount 还是 update。")]),e._v(" "),r("p",[r("strong",[e._v("beginWork 的工作可以划分为两部分：")])]),e._v(" "),r("ol",[r("li",[r("p",[e._v("mount 时：除 fiberRootNode 以外，current === null。会根据 fiber.tag 不同，创建不同类型的子 Fiber 节点")])]),e._v(" "),r("li",[r("p",[e._v("update 时：如果 current 存在，在满足一定条件时可以复用 current 节点，这样就能 clone current.child 作为 workInProgress.child，而不需要新建 workInProgress.child。")])])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function beginWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes\n): Fiber | null {\n\n  // update时：如果current存在,可能存在优化路径，复用current（即上一次更新的Fiber节点）\n  if (current !== null) {\n    // ...省略\n\n    // 复用current\n    return bailoutOnAlreadyFinishedWork(\n      current,\n      workInProgress,\n      renderLanes,\n    );\n  } else {\n    didReceiveUpdate = false;\n  }\n\n  // mount时：根据tag不同，创建不同的子Fiber节点\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n      // ...省略\n      return mountIndeterminateComponent\n    case LazyComponent:\n      // ...省略\n      return mountLazyComponent\n    case FunctionComponent:\n      // ...省略\n      return updateFunctionComponent\n    case ClassComponent:\n      // ...省略\n      return updateClassComponent()\n    case HostRoot:\n      // ...省略\n      return updateHostRoot()\n    case HostComponent:\n      // ...省略\n    case HostText:\n      // ...省略\n      return updateHostText$1()\n  }\n}\n")])])]),r("h4",{attrs:{id:"update-时"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#update-时"}},[e._v("#")]),e._v(" update 时：")]),e._v(" "),r("ol",[r("li",[e._v("oldProps === newProps && workInProgress.type === current.type，即props与fiber.type不变")]),e._v(" "),r("li",[e._v("!includesSomeLane(renderLanes, updateLanes)，即当前Fiber节点优先级不够")]),e._v(" "),r("li",[e._v("didReceiveUpdate = false 可以直接复用前一次更新的子Fiber，不需要新建子Fiber")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("if (current !== null) {\n    const oldProps = current.memoizedProps;\n    const newProps = workInProgress.pendingProps;\n\n    if (\n      oldProps !== newProps ||\n      hasLegacyContextChanged() ||\n      (__DEV__ ? workInProgress.type !== current.type : false)\n    ) {\n      didReceiveUpdate = true;\n    } else if (!includesSomeLane(renderLanes, updateLanes)) {\n      didReceiveUpdate = false;\n      switch (workInProgress.tag) {\n        // ...\n      }\n      return bailoutOnAlreadyFinishedWork(\n        current,\n        workInProgress,\n        renderLanes,\n      );\n    } else {\n      didReceiveUpdate = false;\n    }\n  } else {\n    didReceiveUpdate = false;\n  }\n")])])]),r("h4",{attrs:{id:"mount时"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mount时"}},[e._v("#")]),e._v(" mount时：")]),e._v(" "),r("p",[e._v("当不满足路径优化时，我们会创建子fiber节点\n根据fiber.tag不同，进入不同类型Fiber的创建逻辑,"),r("a",{attrs:{href:"https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactWorkTags.js",target:"_blank",rel:"noopener noreferrer"}},[e._v("tag"),r("OutboundLink")],1)]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// mount时：根据tag不同，创建不同的Fiber节点\nswitch (workInProgress.tag) {\n  case IndeterminateComponent: \n    // ...省略\n  case LazyComponent: \n    // ...省略\n  case FunctionComponent: \n    // ...省略\n  case ClassComponent: \n    // ...省略\n  case HostRoot:\n    // ...省略\n  case HostComponent:\n    // ...省略\n  case HostText:\n    // ...省略\n  // ...省略其他类型\n}\n")])])]),r("p",[e._v("对于我们常见的组件类型，如（FunctionComponent/ClassComponent/HostComponent），最终会进入reconcileChildren方法。")]),e._v(" "),r("h4",{attrs:{id:"reconcilechildren"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#reconcilechildren"}},[e._v("#")]),e._v(" reconcileChildren")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("对于mount的组件，创建新的子Fiber节点")])]),e._v(" "),r("li",[r("p",[e._v("对于update的组件，会将当前组件与该组件在上次更新时对应的Fiber节点比较（Diff算法），将比较的结果生成新Fiber节点")])])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("export function reconcileChildren(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  nextChildren: any,\n  renderLanes: Lanes\n) {\n  if (current === null) {\n    // 对于mount的组件，不会为生成的Fiber节点带上effectTag属性\n    workInProgress.child = mountChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderLanes,\n    );\n  } else {\n    // 对于update的组件，为生成的Fiber节点带上effectTag属性\n    workInProgress.child = reconcileChildFibers(\n      workInProgress,\n      current.child,\n      nextChildren,\n      renderLanes,\n    );\n  }\n}\n")])])]),r("p",[e._v("通过代码可以看到 无论是mount或者update ，最终都是将新的子fiber节点赋值给workInProgress.child,作为本次beginWork的返回值，并作为下次performUnitOfWork执行时workInProgress的传参。\n其流程图下：")]),e._v(" "),r("p",[r("img",{attrs:{src:"/images/react/beginWork.png",alt:""}})]),e._v(" "),r("h3",{attrs:{id:"_03-归阶段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_03-归阶段"}},[e._v("#")]),e._v(" 03. 归阶段")]),e._v(" "),r("p",[e._v("在“归”阶段会调用 completeWork 处理 Fiber 节点。\n当某个 Fiber 节点执行完 completeWork，如果其存在兄弟 Fiber 节点（即 fiber.sibling !== null），会进入其兄弟 Fiber 的“递”阶段。\n如果不存在兄弟 Fiber，会进入父级 Fiber 的“归”阶段。\n“递”和“归”阶段会交错执行直到“归”到 rootFiber。至此，render 阶段的工作就结束了。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function completeWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n): Fiber | null {\n  const newProps = workInProgress.pendingProps;\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n    case LazyComponent:\n    case SimpleMemoComponent:\n    case FunctionComponent:\n    case ForwardRef:\n    case Fragment:\n    case Mode:\n    case Profiler:\n    case ContextConsumer:\n    case MemoComponent:\n      return null;\n    case ClassComponent: {\n      // ...省略\n      return null;\n    }\n    case HostRoot: {\n      // ...省略\n      updateHostContainer(workInProgress);\n      return null;\n    }\n    case HostComponent: {\n      // ...省略\n      return null;\n    }\n  // ...省略\n")])])]),r("p",[e._v("以HostComponent 为例：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("case HostComponent: {\n  popHostContext(workInProgress);\n  const rootContainerInstance = getRootHostContainer();\n  const type = workInProgress.type;\n  // workInProgress.stateNode != null 该Fiber节点是否存在对应的DOM节点\n  if (current !== null && workInProgress.stateNode != null) {\n    // update的情况\n  } else {\n    // mount的情况\n  }\n  return null;\n}\n")])])]),r("h4",{attrs:{id:"update"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#update"}},[e._v("#")]),e._v(" update")]),e._v(" "),r("p",[e._v("update，fiber节点山已经存在对应的DOM节点，所以不需要生成DOM节点，需要做的就是关注props的变化，比如：onClick等回调函数的注册，处理style props。\n主要逻辑如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("if (current !== null && workInProgress.stateNode != null) {\n  // update的情况\n  updateHostComponent(\n    current,\n    workInProgress,\n    type,\n    newProps,\n    rootContainerInstance,\n  );\n  if (current.ref !== workInProgress.ref) {\n    markRef(workInProgress);\n  }\n}\n\n")])])]),r("p",[e._v("updateHostComponent内部处理逻辑，被处理完的props会被赋值给workInProgress.updateQueue，并最终在commit阶段被渲染在页面。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const updatePayload = prepareUpdate(\n  instance,\n  type,\n  oldProps,\n  newProps,\n  rootContainerInstance,\n  currentHostContext,\n);\n// updatePayload 数据结构 为：[key1, value1, key2, value2]\nworkInProgress.updateQueue = (updatePayload: any);\n\n")])])]),r("h4",{attrs:{id:"mount"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mount"}},[e._v("#")]),e._v(" mount")]),e._v(" "),r("ul",[r("li",[e._v("为Fiber节点生成对应的DOM节点")]),e._v(" "),r("li",[e._v("将子孙DOM节点插入刚生成的DOM节点中")]),e._v(" "),r("li",[e._v("与update逻辑中的updateHostComponent类似的处理props的过程")])]),e._v(" "),r("p",[e._v("代码简化逻辑如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// mount的情况\n\nconst currentHostContext = getHostContext();\n// 为fiber创建对应DOM节点\nconst instance = createInstance(\n    type,\n    newProps,\n    rootContainerInstance,\n    currentHostContext,\n    workInProgress,\n  );\n// 将子孙DOM节点插入刚生成的DOM节点中\nappendAllChildren(instance, workInProgress, false, false);\n// DOM节点赋值给fiber.stateNode\nworkInProgress.stateNode = instance;\n\n// 与update逻辑中的updateHostComponent类似的处理props的过程\nif (\n  finalizeInitialChildren(\n    instance,\n    type,\n    newProps,\n    rootContainerInstance,\n    currentHostContext,\n  )\n) {\n  markUpdate(workInProgress);\n}\n")])])]),r("h4",{attrs:{id:"effectlist"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#effectlist"}},[e._v("#")]),e._v(" effectList")]),e._v(" "),r("p",[e._v("作为DOM操作的依据，commit阶段需要找到所有有effectTag的Fiber节点并依次执行effectTag对应操作。这个时候我们不需要再次深度遍历。因为\n在completeWork的上层函数"),r("a",{attrs:{href:"https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1744",target:"_blank",rel:"noopener noreferrer"}},[e._v("completeUnitOfWork"),r("OutboundLink")],1),e._v("中，每个执行完completeWork且存在effectTag的Fiber节点会被保存在一条被称为effectList的单向链表中。")]),e._v(" "),r("p",[e._v("effectList中第一个Fiber节点保存在fiber.firstEffect，最后一个元素保存在fiber.lastEffect。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("if (returnFiber.firstEffect === null) {\n  returnFiber.firstEffect = completedWork.firstEffect;\n}\nif (completedWork.lastEffect !== null) {\n  if (returnFiber.lastEffect !== null) {\n    returnFiber.lastEffect.nextEffect = completedWork.firstEffect;\n  }\n  returnFiber.lastEffect = completedWork.lastEffect;\n}\n")])])]),r("p",[e._v("在“归”阶段，所有有effectTag的Fiber节点都会被追加在effectList中，最终形成一条以rootFiber.firstEffect为起点的单向链表")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("                       nextEffect         nextEffect\nrootFiber.firstEffect -----------\x3e fiber -----------\x3e fiber\n")])])]),r("p",[e._v("hostComponet 归流程：")]),e._v(" "),r("p",[r("img",{attrs:{src:"/images/react/completeWork.png",alt:""}})])])}),[],!1,null,null,null);n.default=s.exports}}]);