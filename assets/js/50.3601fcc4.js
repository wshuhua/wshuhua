(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{503:function(t,a,v){"use strict";v.r(a);var e=v(28),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h3",{attrs:{id:"_1-js引擎"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-js引擎"}},[t._v("#")]),t._v(" 1. js引擎")]),t._v(" "),v("p",[t._v("JavaScript引擎分类：")]),t._v(" "),v("ul",[v("li",[t._v("SpiderMonkey: 第一款JavaScript引擎,由BrenDan Eich开发(也就是JavaScript作者)")]),t._v(" "),v("li",[t._v("Chakra: 微软开发,用于IE浏览器")]),t._v(" "),v("li",[t._v("JavaScriptCore: WebKit中的JavaScript引擎,Apple公司开发")]),t._v(" "),v("li",[t._v("V8: Google开发的强大JavaScript引擎,也帮助Chrome从众多浏览器中脱颖而出")])]),t._v(" "),v("h3",{attrs:{id:"_2-v8引擎的原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-v8引擎的原理"}},[t._v("#")]),t._v(" 2. V8引擎的原理")]),t._v(" "),v("p",[t._v("V8是用C++编写的Google开源高性能JavaScript和WebAssembly引擎,它用于Chrome和Node.js等.\n它实现ECMAScript和WebAssembly,并在Windows7或更高版本,MacOs10.12+和使用x64,IA-32,ARM或MISP处理器的Linux系统上运行。")]),t._v(" "),v("p",[v("img",{attrs:{src:"/images/js/V8%E5%BC%95%E6%93%8E.png",alt:""}})]),t._v(" "),v("p",[t._v("v8引擎通过Parse 进行词法分析，语法分析后转换成AST抽象语法树,再通过Ignition转换器将其转换成字节码。")]),t._v(" "),v("h3",{attrs:{id:"_3-v8引擎的架构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-v8引擎的架构"}},[t._v("#")]),t._v(" 3. V8引擎的架构")]),t._v(" "),v("ul",[v("li",[t._v("Parse：模块会将JavaScript代码转换成AST（抽象语法树），这是因为解释器并不认识JavaScript代码(如果函数没有被调用，那么是不会被转换成AST的)")]),t._v(" "),v("li",[t._v("Ignition：可以理解为解释器（转换器），将ast 转化为字节码，同时会收集TurboFan优化所需要的信息（比如函数参数的类型信息，有了类型才能进行真实的运算）,如果函数只调用一次，Ignition会执行解释执行ByteCode;")]),t._v(" "),v("li",[t._v("TurboFan：可以理解为编译器，可以将字节码编译为CPU可以直接执行的机器码；如果一个函数被多次调用，那么就会被标记为热点函数，那么就会经过TurboFan转换成优化的机器码，提高代码的执行性能")])]),t._v(" "),v("p",[t._v("特殊场景：机器码被还原为ByteCode，后续执行函数中，函数类型发生了变化（比如sum函数原来执行的是number类型，后来执行变成了string类型），之前优化的机器码并不能正确的处理运算，就会逆向的转换成字节码")]),t._v(" "),v("h3",{attrs:{id:"_4-v8引擎的解析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-v8引擎的解析"}},[t._v("#")]),t._v(" 4. V8引擎的解析")]),t._v(" "),v("p",[t._v("V8引擎的解析图\n"),v("img",{attrs:{src:"/images/js/V8%E5%BC%95%E6%93%8E%E7%9A%84%E8%A7%A3%E6%9E%90%E5%9B%BE.png",alt:""}})]),t._v(" "),v("ol",[v("li",[v("p",[t._v("Blink(浏览器内核)将js代码交给V8引擎,Stream获取到源码进行编码转换")])]),t._v(" "),v("li",[v("p",[t._v("Scanner会进行词法分析(lexical analysis),词法分析会将代码转换成tokens")])]),t._v(" "),v("li",[v("p",[t._v("tokens会被转换成AST树,经过Parser和PreParser")])])]),t._v(" "),v("ul",[v("li",[t._v("3.1 Parser就是直接将tokens转成AST树架构")]),t._v(" "),v("li",[t._v("3.2 PreParser预解析,什么时候进行预解析呢? 存在不必要的函数会进行预解析。为了提高网页的运行效率，v8引擎通过Lazy Parsing(延迟解析)，将不必要立即执行的函数进行预解析。")])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),v("p",[t._v("Webkit 渲染引擎有一个优化，当渲染进程接收 HTML 文件字节流时，会先开启一个预解析线程，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析线程会提前下载这些数据。当渲染进程接收 HTML 文件字节流时，会先开启一个预解析线程，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析线程会提前下载这些数据。")])]),t._v(" "),v("ol",{attrs:{start:"4"}},[v("li",[t._v("生成AST树后,会被Ignition转成字节码(bytecode),之后的过程就是代码的执行")])]),t._v(" "),v("h3",{attrs:{id:"_5-js代码执行过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-js代码执行过程"}},[t._v("#")]),t._v(" 5. js代码执行过程")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),v("ul",[v("li",[t._v("VO：Variable Object每一个执行上下文会被关联到一个变量对象称为AO")]),t._v(" "),v("li",[t._v("GO：Global Object")]),t._v(" "),v("li",[t._v("AO：Activation Object")]),t._v(" "),v("li",[t._v("ESC：执行上下文栈(Execution Context Stack,简称ECS),它是用于执行代码的调用栈")]),t._v(" "),v("li",[t._v("GEC：全局执行上下文（Global Execution Context） 全局的代码块为了执行构建的产物")]),t._v(" "),v("li",[t._v("FEC：函数执行上下文(Functional Execution Context）")])])]),t._v(" "),v("p",[t._v("js引擎会在执行代码之前,在堆内存中创建一个全局对象：GO")]),t._v(" "),v("ul",[v("li",[t._v("该对象所有的作用域(scope)都可以访问")]),t._v(" "),v("li",[t._v("里面会包含**Date,Array,String,Number,setTimeout,setInterval等等;")]),t._v(" "),v("li",[t._v("window属性指向自己")])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v('// GlobalObject\nvar globalObject = {\n   String: "类",\n   Date: "类",\n   setTimeout: "函数",\n   // ....\n   window: globalObject(指向本身),\n   name: undefined,\n   num1: undefined,\n   num2: undefined,\n   result: undefined\n}\n')])])]),v("h4",{attrs:{id:"执行上下文栈-调用栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文栈-调用栈"}},[t._v("#")]),t._v(" 执行上下文栈(调用栈)")]),t._v(" "),v("p",[t._v("js引擎内部有一个执行上下文栈(Execution Context Stack,简称ECS),它是用于执行代码(全局的代码块)的调用栈。")]),t._v(" "),v("p",[t._v("全局的代码块为了执行会构建一个Global Execution Context(GEC)\nGEC会被放入到ECS中执行。")]),t._v(" "),v("p",[t._v("GEC被放入到ECS中里面包含两部分内容:")]),t._v(" "),v("ol",[v("li",[t._v("在代码执行前,parser转成AST的过程中,会将全局定义的变量,函数等加入到GO中,但是并不会赋值(undefined)\n这个过程也称之为变量的作用域提升(hoisting)")]),t._v(" "),v("li",[t._v("在代码执行中,对变量赋值,或者执行其他的函数。")])]),t._v(" "),v("h4",{attrs:{id:"执行函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#执行函数"}},[t._v("#")]),t._v(" 执行函数")]),t._v(" "),v("p",[t._v("在执行的过程中执行到一个函数时,就会根据函数体创建一个函数执行上下文(Functional Execution Context/FEC),并且压入到EC Stack中.")]),t._v(" "),v("p",[t._v("FEC中包含三部分内容:")]),t._v(" "),v("ol",[v("li",[t._v("在解析函数成为AST树结构时,会创建一个Activation Object(AO):\nAO中包含形参,arguments,函数定义和指向函数对象,定义的变量")]),t._v(" "),v("li",[t._v("作用域链,由VO(在函数中就是AO对象)和父级VO组成,查找时会一层层查找")]),t._v(" "),v("li",[t._v("this绑定的值")])]),t._v(" "),v("p",[v("img",{attrs:{src:"/images/js/ECS.png",alt:""}})])])}),[],!1,null,null,null);a.default=s.exports}}]);