(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{501:function(t,e,a){"use strict";a.r(e);var n=a(28),r=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"_01-react中的事件处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_01-react中的事件处理"}},[t._v("#")]),t._v(" 01. react中的事件处理")]),t._v(" "),a("p",[t._v("在语法上：")]),t._v(" "),a("ul",[a("li",[t._v("React 事件的命名采用小驼峰式（camelCase），而不是纯小写。")]),t._v(" "),a("li",[t._v("使用 JSX 语法时需要传入一个函数作为事件处理函数，而不是一个字符串。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('传统：\n<button onclick="activateLasers()">\n  Activate Lasers\n</button>\nReact 中\n <button onClick={activateLasers}>\n  Activate Lasers\n</button>\n')])])]),a("ul",[a("li",[t._v("阻止默认事件执行：不能return false 来阻止默认行为，必须通过"),a("code",[t._v("preventDefault")]),t._v("来阻止")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('传统：\n<form onsubmit="console.log(\'You clicked submit.\'); return false">\n  <button type="submit">Submit</button>\n</form>\n\nreact 中\nfunction Form() {\n  function handleSubmit(e) {\n    // e 是一个合成事件\n    e.preventDefault();\n    console.log(\'You clicked submit.\');\n  }\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <button type="submit">Submit</button>\n    </form>\n  );\n}\n')])])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("通过 在回调中使用箭头函数绑定this，此语法问题在于每次渲染组件时都会创建不同的回调函数。如果该回调函数作为 prop 传入子组件时，这些组件可能会进行额外的重新渲染")]),t._v(" "),a("p",[t._v("<button onClick={() => this.handleClick()}>Click me")]),t._v(" "),a("p",[t._v("<button onClick={this.deleteRow.bind(this, id)}>Delete Row")])]),t._v(" "),a("h3",{attrs:{id:"_02-react-事件机制特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_02-react-事件机制特点"}},[t._v("#")]),t._v(" 02. react 事件机制特点")]),t._v(" "),a("p",[t._v("由于fiber机制的特点，生成一个fiber节点时，它对应的dom节点有可能还未挂载，onClick这样的事件处理函数作为fiber节点的prop，不能直接被绑定到真实的DOM节点上。所以React提供了一种“顶层注册，事件收集，统一触发”的事件机制。利用fiber树的层级关系来生成事件执行路径，进而模拟事件捕获和冒泡")]),t._v(" "),a("ul",[a("li",[t._v("顶层注册： 在root元素上绑定一个统一的事件处理函数")]),t._v(" "),a("li",[t._v("事件收集：事件触发时（实际上是root上的事件处理函数被执行），构造合成事件对象，按照冒泡或捕获的路径去组件中收集真正的事件处理函数")]),t._v(" "),a("li",[t._v("统一触发： 在收集过程之后，对所收集的事件逐一执行，并共享同一个合成事件对象。")])]),t._v(" "),a("h3",{attrs:{id:"_03-react事件注册机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_03-react事件注册机制"}},[t._v("#")]),t._v(" 03. react事件注册机制")]),t._v(" "),a("ul",[a("li",[t._v("事件注册 - 组件挂载阶段，根据组件内的声明的事件类型-onclick，onchange 等，给 root(17之前是添加到document) 上添加事件 -addEventListener，将事件绑定到root元素上")])]),t._v(" "),a("p",[t._v("事件监听器listener：是执行 "),a("code",[t._v("createEventListenerWrapperWithPriority")]),t._v("的调用结果，根据优先级和事件名的映射关系返回不同的事件。")]),t._v(" "),a("ul",[a("li",[t._v("事件存储 - 就是把 react 组件内的所有事件统一的存放到一个对象里，缓存起来，为了在触发事件的时候可以查找到对应的方法去执行。")])]),t._v(" "),a("h3",{attrs:{id:"_04-react事件合成机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_04-react事件合成机制"}},[t._v("#")]),t._v(" 04. react事件合成机制")]),t._v(" "),a("p",[t._v("合成事件对象： 经过React合成的SyntheticEvent对象")]),t._v(" "),a("ol",[a("li",[t._v("对原生事件的封装")]),t._v(" "),a("li",[t._v("对某些原生事件的升级和改造")]),t._v(" "),a("li",[t._v("不同浏览器事件兼容的处理")]),t._v(" "),a("li",[t._v("通过将事件 normalize 以让他们在不同浏览器中拥有一致的属性。")])]),t._v(" "),a("p",[t._v("如果一个节点上同时绑定了合成和原生事件，那么禁止冒泡后执行关系是怎样的？")]),t._v(" "),a("p",[t._v("因为合成事件的触发是基于浏览器的事件机制来实现的，通过冒泡机制冒泡到最顶层元素，然后再由 dispatchEvent统一去处理。")]),t._v(" "),a("ul",[a("li",[t._v("原生事件阻止冒泡肯定会阻止合成事件的触发。")]),t._v(" "),a("li",[t._v("合成事件的阻止冒泡不会影响原生事件。\n浏览器事件的执行需要经过三个阶段，捕获阶段-目标元素阶段-冒泡阶段。")])]),t._v(" "),a("p",[t._v("节点上的原生事件的执行是在目标阶段，合成事件的执行是在冒泡阶段，所以原生事件会先合成事件执行，然后再往父节点冒泡。")]),t._v(" "),a("p",[t._v("事件执行路径：当事件对象合成完毕，将事件收集到事件执行路径上，从触发事件的元素开始，依据fiber树的层级结构向上查找，累加上级元素中所有相同类型的事件，最终形成一个具有所有相同类型事件的数组。React自己模拟了一套事件捕获与冒泡的机制。")]),t._v(" "),a("p",[t._v("总结：\n由于fiber树的特点，一个组件如果含有事件的prop，那么将会在对应fiber节点的commit阶段绑定一个事件监听到root上，这个事件监听是持有优先级的，将它和优先级机制联系了起来，可以把合成事件机制当作一个协调者，负责去协调合成事件对象、收集事件、触发真正的事件处理函数这三个过程")])])}),[],!1,null,null,null);e.default=r.exports}}]);