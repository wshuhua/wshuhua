(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{486:function(e,t,s){"use strict";s.r(t);var a=s(28),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h3",{attrs:{id:"_01-初认next"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_01-初认next"}},[e._v("#")]),e._v(" 01. 初认Next")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("npm i -g @nestjs/cli\n$ nest new my-first-nest-project\n")])])]),s("p",[e._v("目录中包含几个核心文件")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("src\n ├── app.controller.spec.ts // 对于基本控制器的单元测试样例\n ├── app.controller.ts // 带有单个路由的基本控制器示例。\n ├── app.module.ts // 应用程序的根模块。\n ├── app.service.ts // 带有单个方法的基本服务\n └── main.ts // 应用程序入口文件。它使用 NestFactory 用来创建 Nest 应用实例。\n")])])]),s("h3",{attrs:{id:"_02-controllers"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_02-controllers"}},[e._v("#")]),e._v(" 02. Controllers")]),e._v(" "),s("p",[e._v("控制器负责处理传入的请求并将响应返回给客户端")]),e._v(" "),s("p",[s("img",{attrs:{src:"/images/nest/controller.png",alt:""}})]),e._v(" "),s("p",[e._v("控制器的目的是接收应用程序的特定请求。 "),s("code",[e._v("路由")]),e._v("机制控制哪个控制器接收哪个请求。 很多时候，每个控制器都有多个路由，不同的路由可以执行不同的操作。")]),e._v(" "),s("p",[e._v("为了创建一个基本的控制器，我们使用类和"),s("code",[e._v("装饰器")]),e._v("。 装饰器将类与所需的元数据相关联，并使 Nest 能够创建路由映射（将请求绑定到相应的控制器）。")]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("提示")]),e._v(" "),s("p",[e._v("为了快速创建带有内置验证的控制器，我们可以使用 CLI 的 命名：nest generate controller [name] 也可以使用 nest g co [name]。\n支持"),s("code",[e._v("\\")]),e._v("划分文件夹。\n比如我们想把某个控制器放在 src/module目录的wsh文件夹下，\n可以使用：\n"),s("code",[e._v("nest g co module/wsh")])]),e._v(" "),s("p",[e._v("应用程序的根模块会自定引入该控制器。\n不想要生成对应的测试文件可以追加 --no-spec")])]),e._v(" "),s("h4",{attrs:{id:"路由"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#路由"}},[e._v("#")]),e._v(" 路由")]),e._v(" "),s("p",[e._v("在下面的例子中，我们使用 @Controller() 装饰器定义一个基本的控制器。可选 路由路径前缀设置为 cats。在 @Controller() 装饰器中使用路径前缀可以使我们轻松地对一组相关的路由进行分组，并最大程度地减少重复代码。例如，我们可以选择将一组用于管理与 /customers 下的客户实体进行互动的路由进行分组。这样，我们可以在 @Controller() 装饰器中指定路径前缀 customers，这样就不必为文件中的每个路由重复路径的那部分。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("import { Controller, Get } from '@nestjs/common';\n\n@Controller('cats')\nexport class CatsController {\n  @Get()\n  findAll(): string {\n    return 'This action returns all cats';\n  }\n}\n\n")])])]),s("p",[s("code",[e._v("findAll()")]),e._v(" 方法之前的 "),s("code",[e._v("@Get()")]),e._v(" HTTP 请求方法装饰器告诉 Nest 为 HTTP 请求的特定端点创建处理程序。端点对应于 HTTP 请求方法（在本例中为 GET ）和路由路径（如 GET /cats ）。")]),e._v(" "),s("p",[e._v("什么是路由路径 ？ 一个处理程序的路由路径是通过连接为控制器 （Controller） 声明的（可选）前缀和请求装饰器中指定的任何路径来确定的。由于我们已经为每个 route（cats） 声明了一个前缀，并且没有在装饰器中添加任何路由信息，因此 Nest 会将 GET /cats 请求映射到此处理程序。如上所述，该路径包括可选的控制由路径前缀和请求方法装饰器中声明的任何路径字符串。例如，路径前缀 customers 与装饰器 @Get('profile') 组合会为 GET /customers/profile 请求生成路由映射。")]),e._v(" "),s("ul",[s("li",[e._v("Nest 使用两种不同的操作响应选项的概念")])]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("标准（推荐）")]),e._v(" "),s("th",[e._v("使用这个内置方法，当请求处理程序返回一个 JavaScript 对象或数组时，它将自动序列化为 JSON。但是，当它返回一个 JavaScript 基本类型（例如string、number、boolean）时， Nest 将只发送值，而不尝试序列化它。这使响应处理变得简单：只需要返回值，其余的由 Nest 负责。")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("类库特有的")]),e._v(" "),s("td",[e._v("我们可以在函数签名处通过 @Res() 注入类库特定的响应对象（例如， Express）。使用此方法，你就能使用由该响应对象暴露的原生响应处理函数。例如，使用 Express，您可以使用 response.status(200).send() 构建响应")])])])]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("注意")]),e._v(" "),s("p",[e._v("Nest 检测处理程序何时使用 "),s("code",[e._v("@Res()")]),e._v(" 或 "),s("code",[e._v("@Next()")]),e._v("，表明你选择了特定于库的选项。如果在一个处理函数上同时使用了这两个方法，那么此处的标准方式就是自动禁用此路由, 你将不会得到你想要的结果。如果需要在某个处理函数上同时使用这两种方法（例如，通过注入响应对象，单独设置 cookie / header，但把其余部分留给框架），你必须在装饰器 "),s("code",[e._v("@Res({ passthrough: true })")]),e._v("中将 "),s("code",[e._v("passthrough")]),e._v(" 选项设为 true")])]),e._v(" "),s("h4",{attrs:{id:"request"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#request"}},[e._v("#")]),e._v(" Request")]),e._v(" "),s("p",[e._v("处理程序有时需要访问客户端的请求细节。Nest 提供了对底层平台（默认为 Express）的请求对象（request）的访问方式。我们可以在处理函数的签名中使用 "),s("code",[e._v("@Req()")]),e._v(" 装饰器，指示 Nest 将请求对象注入处理程序。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("/* cats.controller.ts */\nimport { Controller, Get, Req } from '@nestjs/common';\nimport { Request } from 'express';\n@Controller('cats')\nexport class CatsController {\n  @Get()\n  findAll(@Req() request: Request): string {\n    return 'This action returns all cats';\n  }\n}\n")])])]),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("提示")]),e._v(" "),s("p",[e._v("为了在 express 中使用 Typescript （如 request: Request 上面的参数示例所示），请安装 @types/express 。")])]),e._v(" "),s("p",[s("code",[e._v("Request")]),e._v("对象代表 HTTP 请求，并具有查询字符串，请求参数参数，HTTP 标头（HTTP header） 和 正文（HTTP body）的属性。在多数情况下，不必手动获取它们。 我们可以使用专用的装饰器，比如开箱即用的 "),s("code",[e._v("@Body()")]),e._v("或"),s("code",[e._v("@Query()")]),e._v("。 下面是 Nest 提供的装饰器及其代表的底层平台特定对象的对照列表。")]),e._v(" "),s("pre",[e._v("@Request(), @Req()\treq\n@Response(), @Res()*\tres\n@Next()\tnext\n@Session()\treq.session\n@Param(key?: string)\treq.params / req.params[key]\n@Body(key?: string)\treq.body / req.body[key]\n@Query(key?: string)\treq.query / req.query[key]\n@Headers(name?: string)\treq.headers / req.headers[name]\n@Ip()\treq.ip\n@HostParam()\treq.hosts\n")]),e._v(" "),s("p",[e._v("为了与底层 HTTP 平台（例如，Express 和 Fastify）之间的类型兼容， Nest 提供了 @Res()和 @Response() 装饰器。@Res() 只是 @Response() 的别名。两者都直接暴露了底层平台的 response 对象接口。在使用它们时，还应该导入底层库的类型声明（如：@types/express）以充分利用它们。需要注意的是，在请求处理函数中注入 @Res()或 @Response() 时，会将 Nest 置于该处理函数的特定于库（Library-specific mode）的模式下，并负责管理响应。这样做时，必须通过调用 response 对象（例如，res.json(…) 或 res.send(…)）发出某种响应，否则 HTTP 服务器将挂起。")]),e._v(" "),s("h4",{attrs:{id:"资源"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#资源"}},[e._v("#")]),e._v(" 资源")]),e._v(" "),s("h4",{attrs:{id:"post-请求"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#post-请求"}},[e._v("#")]),e._v(" POST 请求")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("import { Controller, Get, Post } from '@nestjs/common';\n@Controller('cats')\nexport class CatsController {\n  @Post()\n  create(): string {\n    return 'This action adds a new cat';\n  }\n  @Get()\n  findAll(): string {\n    return 'This action returns all cats';\n  }\n}\n")])])]),s("p",[e._v("Nest 为所有标准的 HTTP 方法提供了相应的装饰器："),s("code",[e._v("@Put()、@Delete()、@Patch()、@Options()、以及 @Head()")]),e._v("。此外，"),s("code",[e._v("@All()")]),e._v(" 则用于定义一个用于处理所有 HTTP 请求方法的处理程序。")]),e._v(" "),s("h4",{attrs:{id:"路由通配符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#路由通配符"}},[e._v("#")]),e._v(" 路由通配符")]),e._v(" "),s("p",[e._v("支持模式匹配。例如，星号被用作通配符，将匹配任何字符组合。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("@Get('ab*cd')\nfindAll() {\n  return 'This route uses a wildcard';\n}\n")])])]),s("p",[e._v("路由路径 'ab*cd' 将匹配 abcd 、ab_cd 、abecd 等。字符 ? 、+ 、 * 以及 () 是它们的正则表达式对应项的子集。连字符（-） 和点（.）按字符串路径逐字解析.")]),e._v(" "),s("h4",{attrs:{id:"状态码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#状态码"}},[e._v("#")]),e._v(" 状态码")]),e._v(" "),s("p",[e._v("如前所述，默认情况下响应状态代码始终为 "),s("code",[e._v("200")]),e._v("，除了 "),s("code",[e._v("201")]),e._v(" 的 POST 请求。我们可以通过在处理程序级别添加 @HttpCode(...) 装饰器轻松更改此行为。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("@Post()\n@HttpCode(204)\ncreate() {\n  return 'This action adds a new cat';\n}\n")])])]),s("p",[e._v("通常，状态码不是固定的，而是取决于各种因素。在这种情况下，您可以使用类库特有（library-specific）的 response （通过@Res()注入 ）对象（或者在出现错误时，抛出异常）。")]),e._v(" "),s("h4",{attrs:{id:"headers"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#headers"}},[e._v("#")]),e._v(" Headers")]),e._v(" "),s("p",[e._v("要指定自定义响应标头，可以使用 "),s("code",[e._v("@Header()")]),e._v(" 装饰器或特定于库的响应对象（并直接调用 res.header() ）。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("@Post()\n@Header('Cache-Control', 'none')\ncreate() {\n  return 'This action adds a new cat';\n}\n")])])]),s("h4",{attrs:{id:"重定向"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重定向"}},[e._v("#")]),e._v(" 重定向")]),e._v(" "),s("p",[e._v("要将响应重定向到特定 URL，可以使用 "),s("code",[e._v("@Redirect()")]),e._v(" 装饰器或特定于库的响应对象（并直接调用 "),s("code",[e._v("res.redirect()")]),e._v(" ）。")]),e._v(" "),s("p",[s("code",[e._v("@Redirect()")]),e._v(" 接受一个必需的 url 参数和一个可选的 statusCode 参数。 如果省略，statusCode 默认为 302。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  @Get('redirect')\n  @Redirect('https://www.baidu.com', 301)\n")])])]),s("p",[e._v("有时可能希望动态确定 HTTP 状态代码或重定向 URL。 通过从以下的路由处理方法返回一个对象来做到这一点：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('{\n  "url": string,\n  "statusCode": number\n}\n')])])]),s("p",[e._v("返回的值将覆盖传递给 @Redirect()装饰器的所有参数。 例如")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("@Get('docs')\n@Redirect('https://www.baidu.com', 302)\ngetDocs(@Query('type') type) {\n  if (type === 'news') {\n    return { url: 'http://news.baidu.com/' };\n  }\n}\n")])])]),s("h4",{attrs:{id:"路由参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#路由参数"}},[e._v("#")]),e._v(" 路由参数")]),e._v(" "),s("p",[e._v("当需要接受动态数据作为请求的一部分时（例如，使用GET /cats/1 来获取 id 为 1 的 cat），带有静态路径的路由将无法工作。为了定义带参数的路由，我们可以在路由路径中添加路由参数标记以捕获请求 URL 中该位置的动态值。下面的 @Get() 装饰器示例中的路由参数标记演示了此用法。以这种方式声明的路由参数可以使用 @Param() 装饰器访问，该装饰器应添加到函数签名中。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("@Get(':id')\nfindOne(@Param() params): string {\n  console.log(params.id);\n  return `This action returns a #${params.id} cat`;\n}\n")])])]),s("p",[e._v("@Param() 用于修饰一个方法的参数（上面示例中的 params），并在该方法内将路由参数作为被修饰的方法参数的属性。如上面的代码所示，我们可以通过引用 params.id来访问（路由路径中的） id 参数。 您还可以将特定的参数标记传递给装饰器，然后在方法主体中按参数名称直接引用路由参数。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("@Get(':id')\nfindOne(@Param('id') id: string): string {\n  return `This action returns a #${id} cat`;\n}\n")])])]),s("h4",{attrs:{id:"子域路由"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#子域路由"}},[e._v("#")]),e._v(" 子域路由")]),e._v(" "),s("p",[e._v("@Controller 装饰器可以接受一个 host 选项，以要求传入请求的 HTTP 主机匹配某个特定值。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("@Controller({ host: 'admin.example.com' })\nexport class AdminController {\n  @Get()\n  index(): string {\n    return 'Admin page';\n  }\n}\n")])])]),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("提示")]),e._v(" "),s("p",[e._v("由于 Fastify 缺乏对嵌套路由器的支持，因此当使用子域路由时，应该改用（默认） Express 适配器（Express adapter）。")])]),e._v(" "),s("p",[e._v("与路由路径类似，hosts 选项可以使用标记来捕获主机名中该位置的动态值。下面的 @Controller() 装饰器示例中的主机参数标记演示了这种用法。可以使用 @HostParam() 装饰器访问以这种方式声明的主机参数，该装饰器应添加到方法签名中。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("@Controller({ host: ':account.example.com' })\nexport class AccountController {\n  @Get()\n  getInfo(@HostParam('account') account: string) {\n    return account;\n}\n")])])]),s("h4",{attrs:{id:"作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[e._v("#")]),e._v(" 作用域")]),e._v(" "),s("p",[e._v("对于来自不同编程语言背景的人来说，在 Nest 中得知几乎所有内容都是在传入请求之间共享的，这可能是出乎意料的。我们有一个到数据库的连接池、具有全局状态的单例服务等。请记住，Node.js 不遵循请求/响应多线程无状态模型，其中每个请求都由单独的线程处理。因此，使用单例实例对我们的应用程序来说是完全安全的。")]),e._v(" "),s("h4",{attrs:{id:"异步性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异步性"}},[e._v("#")]),e._v(" 异步性")]),e._v(" "),s("p",[e._v("每个异步函数都必须返回一个 Promise。这意味着可以返回 Nest 能够自行解析的延迟值。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("@Get()\nasync findAll(): Promise<any[]> {\n  return [];\n}\n")])])]),s("p",[e._v("这是完全有效的。此外，通过返回 RxJS observable 流，Nest 路由处理程序将更加强大。 Nest 将自动订阅下面的源并获取最后发出的值（在流完成后）。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("@Get()\nfindAll(): Observable<any[]> {\n  return of([]);\n}\n")])])]),s("h4",{attrs:{id:"请求负载"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#请求负载"}},[e._v("#")]),e._v(" 请求负载")]),e._v(" "),s("p",[e._v("如果使用 TypeScript，我们需要确定 DTO（数据传输对象）模式。"),s("code",[e._v("DTO")]),e._v(" 是一个定义数据如何通过网络发送的对象。我们可以使用 TypeScript 接口或简单的类来确定 DTO 模式。有趣的是，我们建议在这里使用类。为什么？类是 JavaScript ES6 标准的一部分，因此它们在编译后的 JavaScript 中被保留为真实实体。另一方面，由于 TypeScript 接口在转译过程中被移除，Nest 无法在运行时引用它们。这很重要，因为 Pipes 等功能在运行时可以访问变量的元类型时提供了额外的可能性。")]),e._v(" "),s("p",[e._v("创建 CreateCatDto 类：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("export class CreateCatDto {\n  readonly name: string;\n  readonly age: number;\n  readonly breed: string;\n}\n")])])]),s("h4",{attrs:{id:"处理错误"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#处理错误"}},[e._v("#")]),e._v(" 处理错误")]),e._v(" "),s("p",[e._v("该示例利用几个可用的装饰器来创建基本控制器。 该控制器暴露了几个访问和操作内部数据的方法。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("import { Controller, Get, Query, Post, Body, Put, Param, Delete } from '@nestjs/common';\nimport { CreateCatDto, UpdateCatDto, ListAllEntities } from './dto';\n@Controller('cats')\nexport class CatsController {\n  @Post()\n  create(@Body() createCatDto: CreateCatDto) {\n    return 'This action adds a new cat';\n  }\n  @Get()\n  findAll(@Query() query: ListAllEntities) {\n    return `This action returns all cats (limit: ${query.limit} items)`;\n  }\n  @Get(':id')\n  findOne(@Param('id') id: string) {\n    return `This action returns a #${id} cat`;\n  }\n  @Put(':id')\n  update(@Param('id') id: string, @Body() updateCatDto: UpdateCatDto) {\n    return `This action updates a #${id} cat`;\n  }\n  @Delete(':id')\n  remove(@Param('id') id: string) {\n    return `This action removes a #${id} cat`;\n  }\n}\n")])])]),s("h4",{attrs:{id:"准备运行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#准备运行"}},[e._v("#")]),e._v(" 准备运行")]),e._v(" "),s("p",[e._v("控制器已经准备就绪，可以使用，但是 Nest 依然不知道 "),s("code",[e._v("CatsController")]),e._v(" 是否存在，所以它不会创建这个类的一个实例。")]),e._v(" "),s("p",[e._v("控制器总是属于模块，这就是为什么我们在 "),s("code",[e._v("@Module()")]),e._v(" 装饰器中包含 controllers 数组的原因。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("/* app.module.ts */\nimport { Module } from '@nestjs/common';\nimport { CatsController } from './cats/cats.controller';\n@Module({\n  controllers: [CatsController],\n})\nexport class AppModule {}\n\n")])])]),s("p",[e._v("我们使用 "),s("code",[e._v("@Module()")]),e._v(" 装饰器将元数据附加到模块类中，现在，Nest 可以轻松反射出哪些控制器（controller）必须被使用。")]),e._v(" "),s("h4",{attrs:{id:"类库特有方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类库特有方式"}},[e._v("#")]),e._v(" 类库特有方式")]),e._v(" "),s("p",[e._v("到目前为止，我们已经讨论了 Nest 操作响应的标准方式。操作响应的第二种方法是使用类库特有的响应对象(Response)。为了注入特定的响应对象，我们需要使用 @Res() 装饰器。为了对比差异，让我们来重写 CatsController：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("/* cats.controller.ts */\nimport { Controller, Get, Post, Res, HttpStatus } from '@nestjs/common';\nimport { Response } from 'express';\n@Controller('cats')\nexport class CatsController {\n  @Post()\n  create(@Res() res: Response) {\n    res.status(HttpStatus.CREATED).send();\n  }\n  @Get()\n  findAll(@Res() res: Response) {\n    res.status(HttpStatus.OK).json([]);\n  }\n}\n")])])]),s("p",[e._v("尽管此方法有效，并且实际上通过提供对响应对象的完全控制（标头操作，特定于库的功能等）在某些方面提供了更大的灵活性，但应谨慎使用此种方法。通常来说，这种方式非常不清晰，并且有一些缺点。 主要的缺点是你的代码变得依赖于平台（因为不同的底层库在响应对象（Response）上可能具有不同的 API），并且更加难以测试（必须模拟响应对象等）。")]),e._v(" "),s("p",[e._v("而且，在上面的示例中，失去与依赖于 Nest 标准响应处理的 Nest 功能（例如，"),s("code",[e._v("拦截器（Interceptors）")]),e._v(" 和 "),s("code",[e._v("@HttpCode()/@Header() 装饰器）")]),e._v("的兼容性。要解决此问题，可以将 passthrough 选项设置为 true，如下所示：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("@Get()\nfindAll(@Res({ passthrough: true }) res: Response) {\n  res.status(HttpStatus.OK);\n  return [];\n}\n")])])]),s("p",[e._v("现在，就能与底层框架原生的响应对象（Response）进行交互（例如，根据特定条件设置 Cookie 或 HTTP 头），并将剩余的部分留给 Nest 处理。")]),e._v(" "),s("h3",{attrs:{id:"_03-providers"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_03-providers"}},[e._v("#")]),e._v(" 03.Providers")]),e._v(" "),s("p",[s("code",[e._v("Providers")]),e._v(" 是 Nest 的一个基本概念。许多基本的 Nest 类可能被视为 provider - service,repository, factory, helper 等等。 他们都可以通过 "),s("code",[e._v("constructor")]),e._v(" 注入依赖关系。 这意味着对象可以彼此创建各种关系，并且“连接”对象实例的功能在很大程度上可以委托给 Nest运行时系统。 Provider 只是一个用 "),s("code",[e._v("@Injectable()")]),e._v(" 装饰器注释的类。")]),e._v(" "),s("p",[s("img",{attrs:{src:"/images/nest/providers.png",alt:""}})]),e._v(" "),s("p",[e._v("控制器应处理 HTTP 请求并将更复杂的任务委托给 providers。Providers 是纯粹的 JavaScript 类，在其类声明之前带有 @Injectable()装饰器。")]),e._v(" "),s("h4",{attrs:{id:"services"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#services"}},[e._v("#")]),e._v(" Services")]),e._v(" "),s("p",[e._v("创建一个简单的 CatsService 开始。该服务将负责数据存储和检索，其由 CatsController 使用，因此把它定义为 provider，是一个很好的选择。因此，我们用 "),s("code",[e._v("@Injectable()")]),e._v(" 来装饰这个类 。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("import { Injectable } from '@nestjs/common';\nimport { Cat } from './interfaces/cat.interface';\n@Injectable()\nexport class CatsService {\n  private readonly cats: Cat[] = [];\n  create(cat: Cat) {\n    this.cats.push(cat);\n  }\n  findAll(): Cat[] {\n    return this.cats;\n  }\n}\n")])])]),s("p",[e._v("CatsService 具有一个属性和两个方法的基本类。唯一的新特点是它使用"),s("code",[e._v("@Injectable()")]),e._v(" 装饰器。该 @Injectable() 附加有元数据，因此 Nest 知道这个类是一个 Nest provider。需要注意的是，上面有一个 Cat 接口。看起来像这样：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("export interface Cat {\n  name: string;\n  age: number;\n  breed: string;\n}\n")])])]),s("p",[e._v("CatsService 是通过类构造函数注入的。注意这里使用了私有的只读语法。这意味着我们已经在同一位置创建并初始化了 catsService 成员。")]),e._v(" "),s("h4",{attrs:{id:"依赖注入"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#依赖注入"}},[e._v("#")]),e._v(" 依赖注入")]),e._v(" "),s("p",[e._v("Nest 是建立在强大的设计模式, 通常称为依赖注入。")]),e._v(" "),s("p",[e._v("在 Nest 中，借助 TypeScript 功能，管理依赖项非常容易，因为它们仅按类型进行解析。在下面的示例中，Nest 将 catsService 通过创建并返回一个实例来解析 CatsService（或者，在单例的正常情况下，如果现有实例已在其他地方请求，则返回现有实例）。解析此依赖关系并将其传递给控制器的构造函数（或分配给指定的属性）：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("constructor(private readonly catsService: CatsService) {}\n")])])]),s("h4",{attrs:{id:"作用域-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域-2"}},[e._v("#")]),e._v(" 作用域")]),e._v(" "),s("p",[e._v("Provider 通常具有与应用程序生命周期同步的生命周期（“作用域”）。在启动应用程序时，必须解析每个依赖项，因此必须实例化每个提供程序。同样，当应用程序关闭时，每个 provider 都将被销毁。但是，有一些方法可以改变 provider 生命周期的请求范围。")]),e._v(" "),s("h4",{attrs:{id:"自定义提供者"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自定义提供者"}},[e._v("#")]),e._v(" 自定义提供者")]),e._v(" "),s("p",[e._v('Nest 有一个内置的控制反转（"IoC"）容器，可以解决 providers 之间的关系。 此功能是上述依赖注入功能的基础，但要比上面描述的要强大得多。@Injectable() 装饰器只是冰山一角, 并不是定义 providers 的唯一方法。相反，可以使用普通值、类、异步或同步工厂。')]),e._v(" "),s("h4",{attrs:{id:"可选提供者"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#可选提供者"}},[e._v("#")]),e._v(" 可选提供者")]),e._v(" "),s("p",[e._v("有时，可能需要解决一些依赖项。例如，某个类可能依赖于一个配置对象，但如果没有传递，则应使用默认值。在这种情况下，关联变为可选的， provider 不会因为缺少配置导致错误。")]),e._v(" "),s("p",[e._v("要配置 provider 是可选的，需要在 constructor 的参数中使用 "),s("code",[e._v("@Optional()")]),e._v(" 装饰器。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("import { Injectable, Optional, Inject } from '@nestjs/common';\n@Injectable()\nexport class HttpService<T> {\n  constructor(\n    @Optional() @Inject('HTTP_OPTIONS') private readonly httpClient: T\n  ) {}\n}\n")])])]),s("h4",{attrs:{id:"基于属性的注入"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基于属性的注入"}},[e._v("#")]),e._v(" 基于属性的注入")]),e._v(" "),s("p",[e._v("目前使用的技术称为基于构造函数的注入，即通过构造函数方法注入 providers。在某些非常特殊的情况下，基于属性的注入可能会有用。例如，如果顶级类依赖于一个或多个 providers，那么通过从构造函数中调用子类中的 super() 来传递它们就会非常烦人了。因此，为了避免出现这种情况，可以在属性上使用 @Inject() 装饰器")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("import { Injectable, Inject } from '@nestjs/common';\n@Injectable()\nexport class HttpService<T> {\n  @Inject('HTTP_OPTIONS')\n  private readonly httpClient: T;\n}\n")])])]),s("h4",{attrs:{id:"注册提供者"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注册提供者"}},[e._v("#")]),e._v(" 注册提供者")]),e._v(" "),s("p",[e._v("在 Nest 中注册该服务CatsService，以便它可以执行注入。 为此，我们可以编辑模块文件（app.module.ts），然后将服务添加到@Module()装饰器的 providers 数组中。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("import { Module } from '@nestjs/common';\nimport { CatsController } from './cats/cats.controller';\nimport { CatsService } from './cats/cats.service';\n@Module({\n  controllers: [CatsController],\n  providers: [CatsService],\n})\nexport class AppModule {}\n")])])]),s("p",[e._v("目录结构：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("src\n├── cats\n│    ├──dto\n│    │   └──create-cat.dto.ts\n│    ├── interfaces\n│    │       └──cat.interface.ts\n│    ├──cats.service.ts\n│    └──cats.controller.ts\n├──app.module.ts\n└──main.ts\n")])])]),s("h4",{attrs:{id:"模块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模块"}},[e._v("#")]),e._v(" 模块")]),e._v(" "),s("p",[e._v("模块是具有 @Module() 装饰器的类。 @Module() 装饰器提供了元数据，Nest 用它来组织应用程序结构。\n"),s("img",{attrs:{src:"/images/nest/module.png",alt:""}})]),e._v(" "),s("p",[e._v("每个 Nest 应用程序至少有一个模块，即根模块。根模块是 Nest 开始安排应用程序树的地方。事实上，根模块可能是应用程序中唯一的模块，特别是当应用程序很小时，但是对于大型程序来说这是没有意义的。在大多数情况下，您将拥有多个模块，每个模块都有一组紧密相关的功能。")]),e._v(" "),s("p",[s("code",[e._v("@module()")]),e._v(" 装饰器接受一个描述模块属性的对象：")]),e._v(" "),s("ul",[s("li",[e._v("providers\t由 Nest 注入器实例化的提供者，并且可以至少在整个模块中共享")]),e._v(" "),s("li",[e._v("controllers\t必须创建的一组控制器")]),e._v(" "),s("li",[e._v("imports\t导入模块的列表，这些模块导出了此模块中所需提供者")]),e._v(" "),s("li",[e._v("exports\t由本模块提供并应在其他模块中可用的提供者的子集。")])]),e._v(" "),s("p",[e._v("默认情况下，该模块封装提供程序。这意味着无法注入既不是当前模块的直接组成部分，也不是从导入的模块导出的提供程序。因此，可以从模块导出的提供程序视为模块的公共接口或API。")]),e._v(" "),s("h4",{attrs:{id:"功能模块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#功能模块"}},[e._v("#")]),e._v(" 功能模块")]),e._v(" "),s("p",[e._v("CatsController 和 CatsService 属于同一个应用程序域。 应该考虑将它们移动到一个功能模块下，即 CatsModule。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// cats/cats.module.ts\nimport { Module } from '@nestjs/common';\nimport { CatsController } from './cats.controller';\nimport { CatsService } from './cats.service';\n@Module({\n  controllers: [CatsController],\n  providers: [CatsService],\n})\nexport class CatsModule {}\n")])])]),s("p",[e._v("创建了 cats.module.ts 文件，并把与这个模块相关的所有东西都移到了 cats 目录下。我们需要做的最后一件事是将这个模块导入根模块 (ApplicationModule)。")]),e._v(" "),s("p",[e._v("最新目录结构：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("src\n├──cats\n│    ├──dto\n│    │   └──create-cat.dto.ts\n│    ├──interfaces\n│    │     └──cat.interface.ts\n│    ├─cats.service.ts\n│    ├─cats.controller.ts\n│    └──cats.module.ts\n├──app.module.ts\n└──main.ts\n")])])]),s("h4",{attrs:{id:"共享模块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#共享模块"}},[e._v("#")]),e._v(" 共享模块")]),e._v(" "),s("p",[e._v("在 Nest 中，默认情况下，模块是单例，因此可以轻松地在多个模块之间共享同一个提供者实例。\n"),s("img",{attrs:{src:"/images/nest/sharedModule.png",alt:""}})]),e._v(" "),s("p",[e._v("实际上，每个模块都是一个共享模块。一旦创建就能被任意模块重复使用。假设我们将在几个模块之间共享 CatsService 实例。 我们需要把 CatsService 放到 exports 数组中，如下所示")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// cats.module.ts\nimport { Module } from '@nestjs/common';\nimport { CatsController } from './cats.controller';\nimport { CatsService } from './cats.service';\n@Module({\n  controllers: [CatsController],\n  providers: [CatsService],\n  exports: [CatsService]\n})\nexport class CatsModule {}\n")])])]),s("p",[e._v("每个导入 CatsModule 的模块都可以访问 CatsService ，并且它们将共享相同的 CatsService 实例。")]),e._v(" "),s("h4",{attrs:{id:"模块导出"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模块导出"}},[e._v("#")]),e._v(" 模块导出")]),e._v(" "),s("p",[e._v("模块可以导出他们的内部提供者。 而且，他们可以再导出自己导入的模块。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("@Module({\n  imports: [CommonModule],\n  exports: [CommonModule],\n})\nexport class CoreModule {}\n")])])]),s("h4",{attrs:{id:"依赖注入-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#依赖注入-2"}},[e._v("#")]),e._v(" 依赖注入")]),e._v(" "),s("p",[e._v("提供者也可以注入到模块(类)中（例如，用于配置目的）：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("import { Module } from '@nestjs/common';\nimport { CatsController } from './cats.controller';\nimport { CatsService } from './cats.service';\n@Module({\n  controllers: [CatsController],\n  providers: [CatsService],\n})\nexport class CatsModule {\n  constructor(private readonly catsService: CatsService) {}\n}\n")])])]),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("提示")]),e._v(" "),s("p",[e._v("由于循环依赖性，模块类不能注入到提供者中。")])]),e._v(" "),s("h4",{attrs:{id:"全局模块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#全局模块"}},[e._v("#")]),e._v(" 全局模块")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("import { Module, Global } from '@nestjs/common';\nimport { CatsController } from './cats.controller';\nimport { CatsService } from './cats.service';\n@Global()\n@Module({\n  controllers: [CatsController],\n  providers: [CatsService],\n  exports: [CatsService],\n})\nexport class CatsModule {}\n")])])]),s("p",[s("code",[e._v("@Global")]),e._v(" 装饰器使模块成为全局作用域。 全局模块应该只注册一次，最好由根或核心模块注册。 在上面的例子中，CatsService 组件将无处不在，而想要使用 CatsService 的模块则不需要在 imports 数组中导入 CatsModule")]),e._v(" "),s("h4",{attrs:{id:"动态模块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#动态模块"}},[e._v("#")]),e._v(" 动态模块")]),e._v(" "),s("p",[e._v("Nest 模块系统包括一个称为动态模块的强大功能。此功能可以轻松创建可自定义的模块，这些模块可以动态注册和配置提供程序。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("import { Module, DynamicModule } from '@nestjs/common';\nimport { createDatabaseProviders } from './database.providers';\nimport { Connection } from './connection.provider';\n@Module({\n  providers: [Connection],\n})\nexport class DatabaseModule {\n  static forRoot(entities = [], options?): DynamicModule {\n    const providers = createDatabaseProviders(options, entities);\n    return {\n      module: DatabaseModule,\n      providers: providers,\n      exports: providers,\n    };\n  }\n}\n")])])]),s("p",[e._v("forRoot() 可以同步或异步（Promise）返回动态模块。")]),e._v(" "),s("p",[e._v("此模块 Connection 默认情况下（在 @Module() 装饰器元数据中）定义提供程序，但此外-根据传递给方法的 entities 和 options 对象 forRoot() -公开提供程序的集合，例如存储库。请注意，动态模块返回的属性扩展（而不是覆盖）"),s("code",[e._v("@Module()")]),e._v(" 装饰器中定义的基本模块元数据。这就是从模块导出静态声明的 Connection 提供程序和动态生成的存储库提供程序的方式。")]),e._v(" "),s("p",[e._v("如果要在全局范围内注册动态模块，请将 "),s("code",[e._v("global")]),e._v(" 属性设置为 true")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("{\n  global: true,\n  module: DatabaseModule,\n  providers: providers,\n  exports: providers,\n}\n")])])]),s("p",[e._v("DatabaseModule 可以被导入，并且被配置以下列方式：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("import { Module } from '@nestjs/common';\nimport { DatabaseModule } from './database/database.module';\nimport { User } from './users/entities/user.entity';\n@Module({\n  imports: [DatabaseModule.forRoot([User])],\n})\nexport class AppModule {}\n")])])]),s("p",[e._v("如果要"),s("code",[e._v("依次重新导出")]),e._v("动态模块，则可以 forRoot() 在导出数组中省略方法调用：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("import { Module } from '@nestjs/common';\nimport { DatabaseModule } from './database/database.module';\nimport { User } from './users/entities/user.entity';\n@Module({\n  imports: [DatabaseModule.forRoot([User])],\n  exports: [DatabaseModule],\n})\nexport class AppModule {}\n")])])]),s("h3",{attrs:{id:"中间件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#中间件"}},[e._v("#")]),e._v(" 中间件")]),e._v(" "),s("p",[e._v("中间件是在路由处理程序 之前 调用的函数。 中间件函数可以访问请求和响应对象，以及应用程序请求响应周期中的 next() 中间件函数。 next() 中间件函数通常由名为 next 的变量表示。")]),e._v(" "),s("p",[s("img",{attrs:{src:"/images/nest/middleware.png",alt:""}})]),e._v(" "),s("p",[e._v("Nest 中间件实际上等价于 express 中间件。 下面是Express官方文档中所述的中间件功能：")]),e._v(" "),s("p",[e._v("中间件函数可以执行以下任务:")]),e._v(" "),s("ul",[s("li",[e._v("执行任何代码。")]),e._v(" "),s("li",[e._v("对请求和响应对象进行更改。")]),e._v(" "),s("li",[e._v("结束请求-响应周期。")]),e._v(" "),s("li",[e._v("调用堆栈中的下一个中间件函数。")]),e._v(" "),s("li",[e._v("如果当前的中间件函数没有结束请求-响应周期, 它必须调用 next() 将控制传递给下一个中间件函数。否则, 请求将被挂起。")])]),e._v(" "),s("p",[e._v("在函数中或在具有 "),s("code",[e._v("@Injectable()")]),e._v(" 装饰器的类中实现自定义 Nest中间件。 这个类应该实现 NestMiddleware 接口, 而函数没有任何特殊的要求。 让我们首先使用类方法实现一个简单的中间件功能。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// logger.middleware.ts\nimport { Injectable, NestMiddleware } from '@nestjs/common';\nimport { Request, Response, NextFunction } from 'express';\n@Injectable()\nexport class LoggerMiddleware implements NestMiddleware {\n  use(req: Request, res: Response, next: NextFunction) {\n    console.log('Request...');\n    next();\n  }\n}\n")])])]),s("h4",{attrs:{id:"依赖注入-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#依赖注入-3"}},[e._v("#")]),e._v(" 依赖注入")]),e._v(" "),s("p",[e._v("Nest中间件完全支持依赖注入。 就像提供者和控制器一样，它们能够注入属于同一模块的依赖项（通过 constructor ）")]),e._v(" "),s("h4",{attrs:{id:"应用中间件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用中间件"}},[e._v("#")]),e._v(" 应用中间件")]),e._v(" "),s("p",[e._v("中间件不能在 @Module() 装饰器中列出。我们必须使用模块类的 configure() 方法来设置它们。包含中间件的模块必须实现 NestModule 接口。我们将 LoggerMiddleware 设置在 ApplicationModule 层上。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("import { Module, NestModule, MiddlewareConsumer } from '@nestjs/common';\nimport { LoggerMiddleware } from './common/middleware/logger.middleware';\nimport { CatsModule } from './cats/cats.module';\n@Module({\n  imports: [CatsModule],\n})\nexport class AppModule implements NestModule {\n  configure(consumer: MiddlewareConsumer) {\n    consumer\n      .apply(LoggerMiddleware)\n      .forRoutes('cats');\n  }\n}\n")])])]),s("p",[e._v("我们还可以在配置中间件时将包含路由路径的对象和请求方法传递给forRoutes()方法。我们为之前在CatsController中定义的/cats路由处理程序设置了LoggerMiddleware。我们还可以在配置中间件时将包含路由路径的对象和请求方法传递给 forRoutes()方法，从而进一步将中间件限制为特定的请求方法。在下面的示例中，请注意我们导入了 RequestMethod来引用所需的请求方法类型。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("import { Module, NestModule, RequestMethod, MiddlewareConsumer } from '@nestjs/common';\nimport { LoggerMiddleware } from './common/middleware/logger.middleware';\nimport { CatsModule } from './cats/cats.module';\n@Module({\n  imports: [CatsModule],\n})\nexport class AppModule implements NestModule {\n  configure(consumer: MiddlewareConsumer) {\n    consumer\n      .apply(LoggerMiddleware)\n      .forRoutes({ path: 'cats', method: RequestMethod.GET });\n  }\n}\n")])])]),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("提示")]),e._v(" "),s("p",[e._v("可以使用 async/await来实现 configure()方法的异步化(例如，可以在 configure()方法体中等待异步操作的完成)。")])]),e._v(" "),s("h4",{attrs:{id:"路由通配符-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#路由通配符-2"}},[e._v("#")]),e._v(" 路由通配符")]),e._v(" "),s("p",[e._v("路由同样支持模式匹配。例如，星号被用作通配符，将匹配任何字符组合。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("forRoutes({ path: 'ab*cd', method: RequestMethod.ALL });\n")])])]),s("p",[e._v("以上路由地址将匹配 abcd 、 ab_cd 、 abecd 等。字符 ? 、 + 、 * 以及 () 是它们的正则表达式对应项的子集。连字符 (-) 和点 (.) 按字符串路径解析。")]),e._v(" "),s("h4",{attrs:{id:"中间件消费者"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#中间件消费者"}},[e._v("#")]),e._v(" 中间件消费者")]),e._v(" "),s("p",[s("code",[e._v("MiddlewareConsumer")]),e._v(" 是一个帮助类。它提供了几种内置方法来管理中间件。他们都可以被简单地链接起来。forRoutes() 可接受一个字符串、多个字符串、对象、一个控制器类甚至多个控制器类。在大多数情况下，我们可能只会传递一个由逗号分隔的控制器列表。以下是单个控制器的示例：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// app.module.ts\nimport { Module, NestModule, MiddlewareConsumer } from '@nestjs/common';\nimport { LoggerMiddleware } from './common/middleware/logger.middleware';\nimport { CatsModule } from './cats/cats.module';\nimport { CatsController } from './cats/cats.controller.ts';\n@Module({\n  imports: [CatsModule],\n})\nexport class AppModule implements NestModule {\n  configure(consumer: MiddlewareConsumer) {\n    consumer\n      .apply(LoggerMiddleware) // 该 apply() 方法可以使用单个中间件，也可以使用多个参数来指定多个多个中间件。\n      .forRoutes(CatsController);\n  }\n}\n")])])]),s("p",[e._v("有时我们想从应用中间件中排除某些路由。我们可以使用该 "),s("code",[e._v("exclude()")]),e._v(" 方法轻松排除某些路由。此方法可以采用一个字符串，多个字符串或一个 RouteInfo 对象来标识要排除的路由，如下所示：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("consumer\n  .apply(LoggerMiddleware)\n  .exclude(\n    { path: 'cats', method: RequestMethod.GET },\n    { path: 'cats', method: RequestMethod.POST },\n    'cats/(.*)',\n  )\n  .forRoutes(CatsController);\n")])])]),s("h4",{attrs:{id:"函数式中间件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#函数式中间件"}},[e._v("#")]),e._v(" 函数式中间件")]),e._v(" "),s("p",[e._v("把 logger 转换成函数：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// logger.middleware.ts\n\nexport function logger(req, res, next) {\n  console.log(`Request...`);\n  next();\n};\n")])])]),s("p",[e._v("在AppModule使用：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// app.module.ts\nconsumer\n  .apply(logger)\n  .forRoutes(CatsController);\n")])])]),s("h4",{attrs:{id:"多个中间件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多个中间件"}},[e._v("#")]),e._v(" 多个中间件")]),e._v(" "),s("p",[e._v("为了绑定顺序执行的多个中间件，我们可以在 apply() 方法内用逗号分隔它们。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("consumer.apply(cors(), helmet(), logger).forRoutes(CatsController);\n")])])]),s("h4",{attrs:{id:"全局中间件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#全局中间件"}},[e._v("#")]),e._v(" 全局中间件")]),e._v(" "),s("p",[e._v("一次性将中间件绑定到每个注册路由，我们可以使用由INestApplication实例提供的 use()方法")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const app = await NestFactory.create(AppModule);\napp.use(logger);\nawait app.listen(3000);\n")])])]),s("h3",{attrs:{id:"异常过滤器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异常过滤器"}},[e._v("#")]),e._v(" 异常过滤器")])])}),[],!1,null,null,null);t.default=r.exports}}]);