(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{510:function(e,n,i){"use strict";i.r(n);var r=i(28),l=Object(r.a)({},(function(){var e=this,n=e.$createElement,i=e._self._c||n;return i("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[i("h3",{attrs:{id:"_01-diff-算法时机"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_01-diff-算法时机"}},[e._v("#")]),e._v(" 01. diff 算法时机")]),e._v(" "),i("p",[e._v("是在render阶段 beginWork时，针对update组件，将当前组件与 当前组件上次更新时的对应的Fiber节点进行对比（也就是我们所说的diff算法），将对比结果生成新的Fiber节点。")]),e._v(" "),i("div",{staticClass:"custom-block tip"},[i("p",{staticClass:"custom-block-title"},[e._v("提示")]),e._v(" "),i("p",[e._v("一个DOM节点在某一时刻最多会有四个节点和他相关")]),e._v(" "),i("ol",[i("li",[i("strong",[e._v("current Fiber")]),e._v(": 如果该DOM节点已在页面中，current Fiber 代表该DOM 节点对应的Fiber节点。")]),e._v(" "),i("li",[e._v("workInProgress. Fiber 如果该DOM节点将在本次更新中渲染到页面中，workInProgress Fiber 代表该DOM节点对应的Fiber节点")]),e._v(" "),i("li",[e._v("DOM 节点本身")]),e._v(" "),i("li",[e._v("JSX对象。 ClassComponent的render方法的返回结果， 或者FunctionComponent的调用结果，JSX对象中包括描述DOM节点的信息。")])]),e._v(" "),i("p",[e._v("Diff 算法的本质是对比1，4，生成2")])]),e._v(" "),i("h3",{attrs:{id:"_02-diff的缺陷以及react的改进"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_02-diff的缺陷以及react的改进"}},[e._v("#")]),e._v(" 02. Diff的缺陷以及React的改进")]),e._v(" "),i("p",[e._v("由于前后将两棵树完全对比的算法的复杂程度为o（n3），n是树中元素的数量。")]),e._v(" "),i("p",[e._v("假设有1000个元素进行对比，那就需要10亿次的计算量。")]),e._v(" "),i("p",[e._v("为了降低这个复杂度，React的diff 设置了三个限制：")]),e._v(" "),i("ol",[i("li",[e._v("只对同级元素进行diff，如果一个DOM节点在前后两次更新中跨越了层级，那么react不会复用")]),e._v(" "),i("li",[e._v("两个不同类型的元素产生出不同的树，如果元素由div变为p，react会销毁div以及子孙节点，将新建p以及子孙节点")]),e._v(" "),i("li",[e._v("可以通过key prop来表示哪些元素可以在不同的渲染下保持稳定。")])]),e._v(" "),i("h3",{attrs:{id:"_03-diff-是如何实现的"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_03-diff-是如何实现的"}},[e._v("#")]),e._v(" 03. Diff 是如何实现的？")]),e._v(" "),i("p",[e._v("入口函数：reconcileChildFibers 该函数会根据newChild（即JSX对象）类型调用不同的处理函数")]),e._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[e._v("function reconcileChildFibers(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    newChild: any\n): Fiber | null {\n\n    const isObject = typeof newChild === 'Object'  && newChild !== null;\n    if (isObject) {\n       // Object 类型，可能是REACT_ELEMENT_TYPE 或者REACT_PORTAL_TYPE\n       switch (newChild.$$typeOf) {\n           case REACT_ELEMENT_TYPE:\n           // 调用reconclieSingleElement 处理\n       }\n    }\n\n    if (typeof newChild === 'string' || typeof newChild === 'number'){\n      // 调用reconclieSingNode处理\n    }\n\n    if (isArray(newChild)) {\n      // 调用reconclieChildFibers处理\n    }\n    // ...\n\n   // 都没有命中，就会删除节点\n   return deleteRemainingChildren(returnFiber, currentFistChild)\n}\n")])])]),i("p",[e._v("从同级的节点数量将Diff分为两类：")]),e._v(" "),i("ol",[i("li",[i("p",[e._v("当newChild类型为object、number、string，代表同级只有一个节点")])]),e._v(" "),i("li",[i("p",[e._v("当newChild类型为Array，同级有多个节点")])])]),e._v(" "),i("p",[i("img",{attrs:{src:"/images/react/diff%E6%B5%81%E7%A8%8B.png",alt:""}})]),e._v(" "),i("h3",{attrs:{id:"_04-单节点diff"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_04-单节点diff"}},[e._v("#")]),e._v(" 04. 单节点diff")]),e._v(" "),i("p",[e._v("单节点入口：reconcileSingleElement，以object为例：")]),e._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[e._v("if (typeof newChild === 'object' && newChild !== null) {\n    switch(newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return palceSingChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes))\n        // ...\n    }\n}\n")])])]),i("p",[e._v("reconcileSingleElement的作用是：会判断上次更新的Fiber节点是否存在对应的DOM节点 => DOM节点是否可以复用，最后会返回workInProgress fiber节点（可能是新生成的也可能是将上次更新的Fiber节点的副本作为本次新生成的的fiber节点）")]),e._v(" "),i("h4",{attrs:{id:"dom节点是否可以复用"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#dom节点是否可以复用"}},[e._v("#")]),e._v(" DOM节点是否可以复用？")]),e._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[e._v("function reconcileSingleElement (\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    element: ReactElement\n): Fiber {\n    const key = element.key;\n    let child = currentFirstchild;\n\n    // 1. 是否存在对应的DOM节点\n    while(child !== null) {\n      // 上一次存在更新的DOM节点\n\n      // 首先比较key是否相同\n      if (child.key === key) {\n          // key相同， 接下来比较type是否相同\n\n          if (elementType === REACT_FRAGMENT_TYPE) {\n            if (child.tag === Fragment) {\n              return _existing;\n            }\n          } else {\n            if (child.elementType === elementType) {\n              return _existing;\n            }\n          }\n          // key相同但是type不同\n          // 将该fiber及其兄弟fiber标记为删除\n          deleteRemainingChildren(returnFiber, child);\n      } else {\n          // key不同，将该fiber标记为删除\n          deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    // 根据类型，调用不同的生成逻辑 createFiberFromFragment ｜ createFiberFromElement ，返回。\n     \n}\n")])])]),i("h4",{attrs:{id:"deleteremainingchildren-deletechild-区别"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#deleteremainingchildren-deletechild-区别"}},[e._v("#")]),e._v(" deleteRemainingChildren | deleteChild 区别")]),e._v(" "),i("p",[e._v("在child ！== null时， key相同，而type不相同 表示我们已经找到本次更新的元素 对应的上次fiber节点，而type不相同，不能复用。\n而key不相同，只是说明当前fiber 不能被本次更新的元素 复用，后面还有兄弟fiber 咩有遍历到，所以在这个阶段只能标记当前fiber 删除。")]),e._v(" "),i("h3",{attrs:{id:"_05-多节点diff"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_05-多节点diff"}},[e._v("#")]),e._v(" 05. 多节点diff")]),e._v(" "),i("p",[e._v("ul > li*2 为例 ,返回值JSX对象的children属性不是单一节点，而是包含2个对象的数组。")]),e._v(" "),i("p",[e._v("调试如下：")]),e._v(" "),i("p",[i("img",{attrs:{src:"/images/react/debug.png",alt:""}})]),e._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[e._v("if (isArray(newChild)) {\n  return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);\n}\n")])])]),i("ul",[i("li",[i("p",[e._v("节点更新（节点属性变化 ｜ 节点类型更新）")])]),e._v(" "),i("li",[i("p",[e._v("节点新增或者减少")])]),e._v(" "),i("li",[i("p",[e._v("节点位置变化（顺序变化）")])])]),e._v(" "),i("p",[e._v("同级多个节点的diff 属于以上三种类型的一种或者多种。")]),e._v(" "),i("h4",{attrs:{id:"diff-思路"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#diff-思路"}},[e._v("#")]),e._v(" diff 思路")]),e._v(" "),i("div",{staticClass:"custom-block tip"},[i("p",{staticClass:"custom-block-title"},[e._v("提示")]),e._v(" "),i("p",[e._v("虽然本次更新的JSX对象 newChildren为数组形式，但是和newChildren中每个组件进行比较的是current fiber，同级的Fiber节点是由sibling指针链接形成的单链表，即不支持双指针遍历。")]),e._v(" "),i("p",[e._v("即 newChildren[0]与fiber比较，newChildren[1]与fiber.sibling比较。")]),e._v(" "),i("p",[e._v("所以无法使用双指针优化。")])]),e._v(" "),i("p",[e._v("diff 算法经历两轮遍历。")]),e._v(" "),i("ol",[i("li",[e._v("处理更新的节点。")]),e._v(" "),i("li",[e._v("处理剩下的不属于更新的节点")])]),e._v(" "),i("h4",{attrs:{id:"第一次遍历-处理更新的节点"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#第一次遍历-处理更新的节点"}},[e._v("#")]),e._v(" 第一次遍历： 处理更新的节点")]),e._v(" "),i("ol",[i("li",[i("p",[e._v("let i = 0，遍历newChildren，将newChildren[i]与oldFiber比较，判断DOM节点是否可复用。")])]),e._v(" "),i("li",[i("p",[e._v("如果可复用，i++，继续比较newChildren[i]与oldFiber.sibling，可以复用则继续遍历。")])]),e._v(" "),i("li",[i("p",[e._v("如果不可复用，分两种情况：")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("key不同导致不可复用，立即跳出整个遍历，第一轮遍历结束。")])]),e._v(" "),i("li",[i("p",[e._v("key相同type不同导致不可复用，会将oldFiber标记为DELETION，并继续遍历")])])])]),e._v(" "),i("li",[i("p",[e._v("如果newChildren遍历完（即i === newChildren.length - 1）或者oldFiber遍历完（即oldFiber.sibling === null），跳出遍历，第一轮遍历结束。")])])]),e._v(" "),i("p",[e._v("带着第一次遍历的结果进行第二次遍历。")]),e._v(" "),i("h4",{attrs:{id:"第二次遍历-处理剩下的不属于更新的节点"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#第二次遍历-处理剩下的不属于更新的节点"}},[e._v("#")]),e._v(" 第二次遍历：  处理剩下的不属于更新的节点")]),e._v(" "),i("ul",[i("li",[e._v("情况1: newChildren与oldFiber同时遍历完")])]),e._v(" "),i("p",[e._v("说明 在第一轮遍历进行组件更新。Diff结束")]),e._v(" "),i("ul",[i("li",[e._v("情况2: newChildren 没有遍历完，oldFiber遍历完")])]),e._v(" "),i("p",[e._v("说明有新节点插入。 我们只需要遍历剩下的newChildren为生成的workInProgress fiber依次标记Placement。")]),e._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[e._v("if (oldFiber === null) {\n  for (; newIdx < newChildren.length; newIdx++) {\n    const newFiber = createChild(returnFiber, newChildren[newIdx], lanes);\n    if (newFiber === null) {\n      continue;\n    }\n    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n    if (previousNewFiber === null) {\n      resultingFirstChild = newFiber;\n    } else {\n      previousNewFiber.sibling = newFiber;\n    }\n      previousNewFiber = newFiber;\n    }\n    return resultingFirstChild;\n}\n")])])]),i("ul",[i("li",[e._v("情况3: newChildren 遍历完，oldFiber没有遍历")])]),e._v(" "),i("p",[e._v("说明有节点被删除了。所以需要遍历剩下的oldFiber，依次标记Deletion。")]),e._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[e._v("if (newIdx === newChildren.length) {\n  //我们已经到了newChildren的尽头。 我们可以删除其余的节点\n  deleteRemainingChildren(returnFiber, oldFiber);\n  return resultingFirstChild;\n}\n")])])]),i("ul",[i("li",[e._v("情况4: newChildren和oldFiber都没有遍历")])]),e._v(" "),i("p",[e._v("说明有节点更新了位置")]),e._v(" "),i("p",[e._v("reconcileChildrenArray")]),e._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[e._v("    // 将所有子项添加到键映射以进行快速查找。\n    const existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n    for (; newIdx < newChildren.length; newIdx++) {\n      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);\n\n      if (_newFiber2 !== null) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber2.alternate !== null) {\n            // 新的fiber正在进行中，但是如果它已经在当前产生，这意味着我们可以复用这个fiber.我们需要从子列表中删除它，这样我们就不会添加到删除列表中\n            existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);\n          }\n        }\n        // 最后一个可复用的节点在oldFiber中的位置索引\n        lastPlacedIndex = (_newFiber2, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber2;\n        } else {\n          previousNewFiber.sibling = _newFiber2;\n        }\n\n        previousNewFiber = _newFiber2;\n      }\n    }\n")])])]),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[e._v("  function mapRemainingChildren(returnFiber, currentFirstChild) {\n    var existingChildren = new Map();\n    var existingChild = currentFirstChild;\n\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n\n      existingChild = existingChild.sibling;\n    }\n\n    return existingChildren;\n  }\n")])])]),i("h4",{attrs:{id:"处理移动的节点"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#处理移动的节点"}},[e._v("#")]),e._v(" 处理移动的节点")]),e._v(" "),i("ul",[i("li",[e._v("oldIndex： 遍历到的可复用节点在oldFiber中的位置索引")]),e._v(" "),i("li",[e._v("lastPlaceIndex：最后一个可复用的节点在oldFiber中的位置索引")])]),e._v(" "),i("p",[e._v("lastIndex是不断更新的，表示访问过的节点在集合中的最右的位置。若当前访问节点在旧集合中的位置比lastPlaceIndex大，即靠右，说明它不会影响其他元素的位置，因此不用添加到差异队列中，不执行移动操作，反之则进行移动操作。")]),e._v(" "),i("ul",[i("li",[e._v("如果oldIndex < lastPlacedIndex，代表本次更新该节点需要向右移动。")]),e._v(" "),i("li",[e._v("lastPlacedIndex初始为0，每遍历一个可复用的节点，如果oldIndex >= lastPlacedIndex，则lastPlacedIndex = oldIndex。")])]),e._v(" "),i("p",[i("img",{attrs:{src:"/images/react/diff%E8%8A%82%E7%82%B9%E7%A7%BB%E5%8A%A8.png",alt:""}})])])}),[],!1,null,null,null);n.default=l.exports}}]);