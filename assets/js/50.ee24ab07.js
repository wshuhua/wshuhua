(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{503:function(v,t,_){"use strict";_.r(t);var a=_(28),i=Object(a.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h3",{attrs:{id:"_1-js引擎"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-js引擎"}},[v._v("#")]),v._v(" 1. js引擎")]),v._v(" "),_("p",[v._v("JavaScript引擎分类：")]),v._v(" "),_("ul",[_("li",[v._v("SpiderMonkey: 第一款JavaScript引擎,由BrenDan Eich开发(也就是JavaScript作者)")]),v._v(" "),_("li",[v._v("Chakra: 微软开发,用于IE浏览器")]),v._v(" "),_("li",[v._v("JavaScriptCore: WebKit中的JavaScript引擎,Apple公司开发")]),v._v(" "),_("li",[v._v("V8: Google开发的强大JavaScript引擎,也帮助Chrome从众多浏览器中脱颖而出")])]),v._v(" "),_("h3",{attrs:{id:"_2-v8引擎的原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-v8引擎的原理"}},[v._v("#")]),v._v(" 2. V8引擎的原理")]),v._v(" "),_("p",[v._v("V8是用C++编写的Google开源高性能JavaScript和WebAssembly引擎,它用于Chrome和Node.js等.\n它实现ECMAScript和WebAssembly,并在Windows7或更高版本,MacOs10.12+和使用x64,IA-32,ARM或MISP处理器的Linux系统上运行。")]),v._v(" "),_("p",[_("img",{attrs:{src:"/images/js/V8%E5%BC%95%E6%93%8E.png",alt:""}})]),v._v(" "),_("p",[v._v("v8引擎通过Parse 进行词法分析，语法分析后转换成AST抽象语法树,再通过Ignition转换器将其转换成字节码。")]),v._v(" "),_("h3",{attrs:{id:"_3-v8引擎的架构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-v8引擎的架构"}},[v._v("#")]),v._v(" 3. V8引擎的架构")]),v._v(" "),_("ul",[_("li",[v._v("Parse：模块会将JavaScript代码转换成AST（抽象语法树），这是因为解释器并不认识JavaScript代码(如果函数没有被调用，那么是不会被转换成AST的)")]),v._v(" "),_("li",[v._v("Ignition：可以理解为解释器（转换器），将ast 转化为字节码，同时会收集TurboFan优化所需要的信息（比如函数参数的类型信息，有了类型才能进行真实的运算）,如果函数只调用一次，Ignition会执行解释执行ByteCode;")]),v._v(" "),_("li",[v._v("TurboFan：可以理解为编译器，可以将字节码编译为CPU可以直接执行的机器码；如果一个函数被多次调用，那么就会被标记为热点函数，那么就会经过TurboFan转换成优化的机器码，提高代码的执行性能")])]),v._v(" "),_("p",[v._v("特殊场景：机器码被还原为ByteCode，后续执行函数中，函数类型发生了变化（比如sum函数原来执行的是number类型，后来执行变成了string类型），之前优化的机器码并不能正确的处理运算，就会逆向的转换成字节码")]),v._v(" "),_("h3",{attrs:{id:"_4-v8引擎的解析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-v8引擎的解析"}},[v._v("#")]),v._v(" 4. V8引擎的解析")]),v._v(" "),_("p",[v._v("V8引擎的解析图\n"),_("img",{attrs:{src:"/images/js/V8%E5%BC%95%E6%93%8E%E7%9A%84%E8%A7%A3%E6%9E%90%E5%9B%BE.png",alt:""}})]),v._v(" "),_("ol",[_("li",[_("p",[v._v("Blink(浏览器内核)将js代码交给V8引擎,Stream获取到源码进行编码转换")])]),v._v(" "),_("li",[_("p",[v._v("Scanner会进行词法分析(lexical analysis),词法分析会将代码转换成tokens")])]),v._v(" "),_("li",[_("p",[v._v("tokens会被转换成AST树,经过Parser和PreParser")])])]),v._v(" "),_("ul",[_("li",[v._v("3.1 Parser就是直接将tokens转成AST树架构")]),v._v(" "),_("li",[v._v("3.2 PreParser预解析,什么时候进行预解析呢? 存在不必要的函数会进行预解析。为了提高网页的运行效率，v8引擎通过Lazy Parsing(延迟解析)，将不必要立即执行的函数进行预解析。")])]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("提示")]),v._v(" "),_("p",[v._v("Webkit 渲染引擎有一个优化，当渲染进程接收 HTML 文件字节流时，会先开启一个预解析线程，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析线程会提前下载这些数据。当渲染进程接收 HTML 文件字节流时，会先开启一个预解析线程，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析线程会提前下载这些数据。")])]),v._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[v._v("生成AST树后,会被Ignition转成字节码(bytecode),之后的过程就是代码的执行")])]),v._v(" "),_("h3",{attrs:{id:"_5-js代码执行过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-js代码执行过程"}},[v._v("#")]),v._v(" 5. js代码执行过程")]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("提示")]),v._v(" "),_("ul",[_("li",[v._v("VO：Variable Object每一个执行上下文会被关联到一个变量对象称为AO")]),v._v(" "),_("li",[v._v("GO：Global Object")]),v._v(" "),_("li",[v._v("AO：Activation Object")]),v._v(" "),_("li",[v._v("ESC：执行上下文栈(Execution Context Stack,简称ECS),它是用于执行代码的调用栈")]),v._v(" "),_("li",[v._v("GEC：全局执行上下文（Global Execution Context） 全局的代码块为了执行构建的产物")]),v._v(" "),_("li",[v._v("FEC：函数执行上下文(Functional Execution Context）")])])]),v._v(" "),_("p",[v._v("js引擎会在执行代码之前,在堆内存中创建一个全局对象：GO")]),v._v(" "),_("ul",[_("li",[v._v("该对象所有的作用域(scope)都可以访问")]),v._v(" "),_("li",[v._v("里面会包含**Date,Array,String,Number,setTimeout,setInterval等等;")]),v._v(" "),_("li",[v._v("window属性指向自己")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v('// GlobalObject\nvar globalObject = {\n   String: "类",\n   Date: "类",\n   setTimeout: "函数",\n   // ....\n   window: globalObject(指向本身),\n   name: undefined,\n   num1: undefined,\n   num2: undefined,\n   result: undefined\n}\n')])])]),_("h4",{attrs:{id:"执行上下文栈-调用栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文栈-调用栈"}},[v._v("#")]),v._v(" 执行上下文栈(调用栈)")]),v._v(" "),_("p",[v._v("js引擎内部有一个执行上下文栈(Execution Context Stack,简称ECS),它是用于执行代码(全局的代码块)的调用栈。")]),v._v(" "),_("p",[v._v("全局的代码块为了执行会构建一个Global Execution Context(GEC)\nGEC会被放入到ECS中执行。")]),v._v(" "),_("p",[v._v("GEC被放入到ECS中里面包含两部分内容:")]),v._v(" "),_("ol",[_("li",[v._v("在代码执行前,parser转成AST的过程中,会将全局定义的变量,函数等加入到GO中,但是并不会赋值(undefined)\n这个过程也称之为变量的作用域提升(hoisting)")]),v._v(" "),_("li",[v._v("在代码执行中,对变量赋值,或者执行其他的函数。")])]),v._v(" "),_("h4",{attrs:{id:"执行函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#执行函数"}},[v._v("#")]),v._v(" 执行函数")]),v._v(" "),_("p",[v._v("在执行的过程中执行到一个函数时,就会根据函数体创建一个函数执行上下文(Functional Execution Context/FEC),并且压入到EC Stack中.")]),v._v(" "),_("p",[v._v("FEC中包含三部分内容:")]),v._v(" "),_("ol",[_("li",[v._v("在解析函数成为AST树结构时,会创建一个Activation Object(AO):\nAO中包含形参,arguments,函数定义和指向函数对象,定义的变量")]),v._v(" "),_("li",[v._v("作用域链,由VO(在函数中就是AO对象)和父级VO组成,查找时会一层层查找")]),v._v(" "),_("li",[v._v("this绑定的值")])]),v._v(" "),_("p",[_("img",{attrs:{src:"/images/js/ECS.png",alt:""}})]),v._v(" "),_("h3",{attrs:{id:"_6-垃圾回收"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-垃圾回收"}},[v._v("#")]),v._v(" 6. 垃圾回收")]),v._v(" "),_("p",[v._v("JavaScript 中的数据是如何存储？")]),v._v(" "),_("ul",[_("li",[v._v("原始数据类型是存储在栈空间中的，引用类型的数据是存储在堆空间中的。")])]),v._v(" "),_("h4",{attrs:{id:"栈垃圾回收"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#栈垃圾回收"}},[v._v("#")]),v._v(" 栈垃圾回收：")]),v._v(" "),_("p",[v._v("当函数执行结束，JS引擎通过向下移动"),_("code",[v._v("ESP")]),v._v("（extended stack pointer）指针（记录调用栈当前执行状态的指针），来销毁该函数保存在栈中的执行上下文（变量环境、词法环境、this、outer）。")]),v._v(" "),_("h4",{attrs:{id:"堆垃圾回收"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆垃圾回收"}},[v._v("#")]),v._v(" 堆垃圾回收:")]),v._v(" "),_("h5",{attrs:{id:"代际假说"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#代际假说"}},[v._v("#")]),v._v(" 代际假说")]),v._v(" "),_("p",[v._v("特点：")]),v._v(" "),_("ul",[_("li",[v._v("1、大部分对象存活时间很短")]),v._v(" "),_("li",[v._v("2、不被销毁的对象，会活的更久\n分类：\nV8 中会把堆分为"),_("code",[v._v("新生代")]),v._v("和"),_("code",[v._v("老生代")]),v._v("两个区域。")])]),v._v(" "),_("p",[_("code",[v._v("新生代")]),v._v("和"),_("code",[v._v("老生代")]),v._v("划分区别：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("时间上：新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象，占用空间大。")])]),v._v(" "),_("li",[_("p",[v._v("容量上：新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。")])]),v._v(" "),_("li",[_("p",[v._v("副垃圾回收器，主要负责新生代的垃圾回收。")])]),v._v(" "),_("li",[_("p",[v._v("主垃圾回收器，主要负责老生代的垃圾回收。")])])]),v._v(" "),_("h5",{attrs:{id:"垃圾回收器的工作流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收器的工作流程"}},[v._v("#")]),v._v(" 垃圾回收器的工作流程")]),v._v(" "),_("ul",[_("li",[v._v("三、新生代\n"),_("ul",[_("li",[v._v("算法：Scavenge 算法")]),v._v(" "),_("li",[v._v("原理：")]),v._v(" "),_("li",[v._v("1、把新生代空间对半划分为两个区域，一半是"),_("code",[v._v("对象区域")]),v._v("，一半是"),_("code",[v._v("空闲区域")]),v._v("。")]),v._v(" "),_("li",[v._v("2、新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。")]),v._v(" "),_("li",[v._v("3、先对对象区域中的垃圾做标记，标记完成之后，把这些存活的对象复制到空闲区域中")]),v._v(" "),_("li",[v._v("4、完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。")]),v._v(" "),_("li",[v._v("对象晋升策略： 经过两次垃圾回收依然还存活的对象，会被移动到老生区中。")])])]),v._v(" "),_("li",[v._v("四、老生代 算法：标记 - 清除（Mark-Sweep）算法\n"),_("ul",[_("li",[v._v("原理：")]),v._v(" "),_("li",[v._v("1、标记：标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。")]),v._v(" "),_("li",[v._v("2、清除：将垃圾数据进行清除。\n"),_("ul",[_("li",[v._v("碎片： 对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存。")])])]),v._v(" "),_("li",[v._v("算法：标记 - 整理（Mark-Compact）算法 原理：\n"),_("ul",[_("li",[v._v("1、标记：和标记 - 清除的标记过程一样，从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素标记为活动对象。")]),v._v(" "),_("li",[v._v("2、整理：让所有存活的对象都向内存的一端移动")]),v._v(" "),_("li",[v._v("3、清除：清理掉端边界以外的内存")]),v._v(" "),_("li",[v._v("优化算法：增量标记（Incremental Marking）算法 原理：\n"),_("ul",[_("li",[v._v("1、为了降低老生代的垃圾回收而造成的卡顿")]),v._v(" "),_("li",[v._v("2、V8把一个完整的垃圾回收任务拆分为很多小的任务 1、让垃圾回收标记和 JavaScript 应用逻辑交替进行")])])])])])])])])])}),[],!1,null,null,null);t.default=i.exports}}]);