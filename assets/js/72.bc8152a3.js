(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{525:function(s,n,a){"use strict";a.r(n);var e=a(28),t=Object(e.a)({},(function(){var s=this,n=s.$createElement,a=s._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p",[s._v("🍑宝 network 面板加载资源的形式：\n"),a("img",{attrs:{src:"/images/cache/cache15.png",alt:""}})]),s._v(" "),a("p",[a("strong",[s._v("刷新页面或再次访问时大部分资源都命中了强缓存，唯独率先加载的 HTML 资源走了协商缓存")])]),s._v(" "),a("p",[s._v("像 JS、CSS 等资源经过像 webpack 这样的打包工具打包后可以自动生成 hash 文件名，每次部署到服务器上后发生变化的资源 hash 名会更新，浏览器会当作一个新的资源去向服务器请求，没有更新的资源便会优先读取浏览器缓存。")]),s._v(" "),a("p",[s._v("而 HTML 不同，其文件名不会改变，我们期望浏览器每次加载时都应该向服务器询问是否更新，否则会出现新版本发布后浏览器读取缓存 HTML 文件导致页面空白报错（旧资源被删除）或应用没有更新（读取了旧资源）的问题。")]),s._v(" "),a("p",[s._v("根据 HTTP 缓存的规则最终可以总结出如下缓存方案：")]),s._v(" "),a("ul",[a("li",[s._v("频繁变动的资源，比如 HTML， 采用协商缓存")]),s._v(" "),a("li",[s._v("CSS、JS、图片资源等采用强缓存，使用 hash 命名")])]),s._v(" "),a("p",[s._v("那么关于如何让 HTML 文件走协商缓存，前提得先让浏览器强缓存失效，可以设置如下服务器响应报头：")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("Cache-Control: max-age=0\nLast-Modified: Sat, 04 Sep 2021 08:59:40 GMT\n")])])]),a("p",[s._v("在资源 0 秒就失效的情况下存在协商缓存触发条件的 Last-Modified 标识，这样每次访问加载的 HTML 资源就会确保是最新的，解决了 HTML 怕被浏览器强缓存的烦恼。")]),s._v(" "),a("h2",{attrs:{id:"webpack-中的-hash-模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack-中的-hash-模式"}},[s._v("#")]),s._v(" Webpack 中的 Hash 模式")]),s._v(" "),a("p",[s._v("在 webpack 中 hash 可以分为三种类型：hash、chunkhash、contenthash，每一种类型 hash 的生成规则和作用也不同")]),s._v(" "),a("h3",{attrs:{id:"hash"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash"}},[s._v("#")]),s._v(" hash")]),s._v(" "),a("p",[s._v("hash 属于项目级别的 hash，意思就是整个项目中只要有文件改变该 hash 值就会变化，同时所有文件也都共用该 hash 值。")]),s._v(" "),a("p",[s._v("webpack 的简单配置如下：")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("module.exports = {    \n    output: {\n        path: config.build.assetsRoot,\n        filename: utils.assetsPath('js/[name].[hash:8].js'),\n        chunkFilename: utils.assetsPath('js/[name].[hash:8].min.js'),\n    },\n    plugins:[ \n        // 将 js 中引入的 css 进行分离\n        new ExtractTextPlugin({ filename: utils.assetsPath('css/[name].[hash:8].css'), allChunks: true }),\n    ]\n}    \n")])])]),a("h3",{attrs:{id:"chunkhash"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#chunkhash"}},[s._v("#")]),s._v(" chunkhash")]),s._v(" "),a("p",[s._v("chunkhash 与 hash 不同，其属于入口文件级别的 hash，会根据入口文件（entry）的依赖进行打包，同时为了避免一些公共库、插件被打包至入口文件中，我们可以借助 CommonsChunkPlugin 插件进行公共模块的提取：")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("module.exports = {\n    entry: utils.getEntries(),\n    output: {\n        path: config.build.assetsRoot,\n        filename: utils.assetsPath('js/[name].[chunkhash:8].js'),\n        chunkFilename: utils.assetsPath('js/[name].[chunkhash:8].min.js'),\n    },\n    plugins:[ \n        // 将 js 中引入的 css 进行分离\n        new ExtractTextPlugin({ filename: utils.assetsPath('css/[name].[chunkhash:8].css') }),\n        // 分离公共 js 到 vendor 中\n        new webpack.optimize.CommonsChunkPlugin({\n            name: 'vendor', //文件名\n            minChunks: function(module, count) {\n                // 声明公共的模块来自 node_modules 文件夹，把 node_modules、common 文件夹以及使用了2次依赖的都抽出来\n                return (\n                    module.resource &&\n                    (/\\.js$/.test(module.resource) || /\\.vue$/.test(module.resource)) &&\n                    (module.resource.indexOf(path.join(__dirname, '../node_modules')) === 0 || module.resource.indexOf(path.join(__dirname, '../src/common')) === 0 || count >= 2)\n                );\n            }\n        }),\n        // 将运行时代码提取到单独的 manifest 文件中，防止其影响 vendor.js\n        new webpack.optimize.CommonsChunkPlugin({\n            name: 'runtime',\n            chunks: ['vendor']\n        })\n    ]\n}\n")])])]),a("p",[s._v("上述配置我们将需要抽离的公共模块提取到了 vendor.js 中，同时也将 webpack 运行文件提取到了 runtime.js 中，这些公共模块一般除了升级版本外永远不会改动，我们希望浏览器能够将其存入强缓存中，不受其他业务模块的修改导致文件 chunkhash 名称变动的影响。")]),s._v(" "),a("p",[s._v("最终我们打包出的模块拥有不同的 chunkhash 名称，重新打包只会影响有变动的模块重新生成 chunkhash。")]),s._v(" "),a("h3",{attrs:{id:"contenthash"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#contenthash"}},[s._v("#")]),s._v(" contenthash")]),s._v(" "),a("p",[s._v("contenthash 是属于文件内容级别的 hash，其会根据文件内容的变化而变化，一般用于解决以下问题：\n比如某个js 中单独引入了.css 文件，那么当 js 文件被修改后，就算 css 文件并没有被修改，由于该模块发生了改变，同样会导致 css 文件也被重复构建。此时，针对 css 使用 contenthash 后，只要其内容不变就不会被重复构建。")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("module.exports = {    \n    output: {\n        path: config.build.assetsRoot,\n        filename: utils.assetsPath('js/[name].[chunkhash:8].js'),\n        chunkFilename: utils.assetsPath('js/[name].[chunkhash:8].min.js'),\n    },\n    plugins:[ \n        // 将 js 中引入的 css 进行分离，使用 contenthash 判断内容的改变\n        new ExtractTextPlugin({ filename: utils.assetsPath('css/[name].[contenthash:8].css'), allChunks: true }),\n    ]\n}\n")])])])])}),[],!1,null,null,null);n.default=t.exports}}]);