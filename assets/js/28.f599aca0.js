(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{479:function(e,n,a){"use strict";a.r(n);var t=a(28),s=Object(t.a)({},(function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h3",{attrs:{id:"schedulerr"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#schedulerr"}},[e._v("#")]),e._v(" schedulerr")]),e._v(" "),a("p",[e._v("scheduler主要包括两个功能：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("时间切片")])]),e._v(" "),a("li",[a("p",[e._v("优先级调度")])])]),e._v(" "),a("h4",{attrs:{id:"时间切片原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#时间切片原理"}},[e._v("#")]),e._v(" 时间切片原理")]),e._v(" "),a("p",[e._v("Scheduler的时间切片功能是通过task（宏任务）实现的。\n常见的tast就是setTimout，但是有个task比setTimeout执行时机更靠前，"),a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel",target:"_blank",rel:"noopener noreferrer"}},[e._v("MessageChannel"),a("OutboundLink")],1),e._v("允许我们创建一个新的消息通道，并通过它的两个MessagePort 属性发送数据。")]),e._v(" "),a("p",[e._v("所以Scheduler将需要被执行的回调函数作为MessageChannel的回调执行。如果当前宿主环境不支持MessageChannel，再使用setTimeout。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("requestHostCallback = function(cb) {\n  if (_callback !== null) {\n    // Protect against re-entrancy.\n    setTimeout(requestHostCallback, 0, cb);\n  } else {\n    _callback = cb;\n    setTimeout(_flushCallback, 0);\n  }\n};\n")])])]),a("p",[e._v("在React的render阶段，开启Concurrent Mode时，每次遍历前，都会通过Scheduler提供的shouldYield方法判断是否需要中断遍历，使浏览器有时间渲染\n是否中断的依据：每个任务的剩余时间是否用完。在Schdeduler中，为任务分配的初始剩余时间为5ms")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function workLoopConcurrent() {\n  while (workInProgress !== null && !shouldYield()) {\n    performUnitOfWork(workInProgress);\n  }\n}\n")])])]),a("p",[e._v("通过fps动态调整分配给任务的可执行时间")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("forceFrameRate = function(fps) {\n    //fps: 每秒传输速率，不支持强速帧 \n    if (fps < 0 || fps > 125) {\n      return;\n    }\n    if (fps > 0) {\n      yieldInterval = Math.floor(1000 / fps);\n    } else {\n      // 重置初始值\n      yieldInterval = 5;\n    }\n};\n\n")])])]),a("h4",{attrs:{id:"优先级调度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优先级调度"}},[e._v("#")]),e._v(" 优先级调度")]),e._v(" "),a("p",[e._v("Scheduler是独立于React的包，所以它的优先级（存在5种优先级）也是独立于React的优先级的。对外暴露了一个方法 "),a("code",[e._v("unstable_runWithPriority")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function unstable_runWithPriority(priorityLevel, eventHandler) {\n  switch (priorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n    case LowPriority:\n    case IdlePriority:\n      break;\n    default:\n      priorityLevel = NormalPriority;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n}\n")])])]),a("p",[e._v("不同优先级意味着不同时长的任务过期时间")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// Times out immediately\nvar IMMEDIATE_PRIORITY_TIMEOUT = -1;\n// Eventually times out\nvar USER_BLOCKING_PRIORITY_TIMEOUT = 250;\nvar NORMAL_PRIORITY_TIMEOUT = 5000;\nvar LOW_PRIORITY_TIMEOUT = 10000;\n// Never times out\nvar IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;\n\n\nvar timeout;\nswitch (priorityLevel) {\n  case ImmediatePriority:\n    timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n    break;\n  case UserBlockingPriority:\n    timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n    break;\n  case IdlePriority:\n    timeout = IDLE_PRIORITY_TIMEOUT;\n    break;\n  case LowPriority:\n    timeout = LOW_PRIORITY_TIMEOUT;\n    break;\n  case NormalPriority:\n  default:\n    timeout = NORMAL_PRIORITY_TIMEOUT;\n    break;\n}\n\nvar expirationTime = startTime + timeout;\n")])])]),a("p",[e._v("如果一个任务的优先级是ImmediatePriority，对应IMMEDIATE_PRIORITY_TIMEOUT为-1，那么该任务的过期时间比当前时间还短，表示它已经过期了，需要立即被执行。")]),e._v(" "),a("h4",{attrs:{id:"不同优先级的排序任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不同优先级的排序任务"}},[e._v("#")]),e._v(" 不同优先级的排序任务")]),e._v(" "),a("p",[e._v("Scueduler 存在两个队列")]),e._v(" "),a("ul",[a("li",[e._v("timerQueue：保存未就绪任务")]),e._v(" "),a("li",[e._v("taskQueue：保存已就绪任务\n每当有新的未就绪的任务被注册，我们将其插入到timerQueue，并根据开始时间重新排序。\n当timerQueue中有任务就绪（currentTime >= startTime）,取出加入到taskQueue。\n取出taskQueue中最早过期的任务并执行他。Scheduler使用小顶堆实现了优先级队列。")])]),e._v(" "),a("p",[a("code",[e._v("小顶堆")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("每个结点的值都小于或等于其左右孩子结点的值\narr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]\n")])])]),a("p",[e._v("取出taskQueue最早过期任务：注册的回调函数执行后的返回值continuationCallback为function，会将continuationCallback作为当前任务的回调函数，如果不是funtion，则将当前被执行的任务清除taskQueue。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const continuationCallback = callback(didUserCallbackTimeout);\ncurrentTime = getCurrentTime();\nif (typeof continuationCallback === 'function') {\n  // continuationCallback是函数\n  currentTask.callback = continuationCallback;\n  markTaskYield(currentTask, currentTime);\n} else {\n  if (enableProfiling) {\n    markTaskCompleted(currentTask, currentTime);\n    currentTask.isQueued = false;\n  }\n  if (currentTask === peek(taskQueue)) {\n    // 将当前任务清除\n    pop(taskQueue);\n  }\n}\nadvanceTimers(currentTime);\n")])])]),a("h3",{attrs:{id:"lane模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lane模型"}},[e._v("#")]),e._v(" lane模型")]),e._v(" "),a("p",[e._v("lane模型使用31位的二进制表示31条赛道，位数越小的赛道优先级越高，某些相邻的赛道拥有相同优先级。")]),e._v(" "),a("p",[e._v("优先级逐步降低.")]),e._v(" "),a("p",[e._v("代表批处理的lanes： 同时占据好几个赛道")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("export const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000;\nexport const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000;\n\nexport const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000001;\nexport const SyncBatchedLane: Lane = /*                 */ 0b0000000000000000000000000000010;\n\nexport const InputDiscreteHydrationLane: Lane = /*      */ 0b0000000000000000000000000000100;\nconst InputDiscreteLanes: Lanes = /*                    */ 0b0000000000000000000000000011000;\n\nconst InputContinuousHydrationLane: Lane = /*           */ 0b0000000000000000000000000100000;\nconst InputContinuousLanes: Lanes = /*                  */ 0b0000000000000000000000011000000;\n\nexport const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000100000000;\nexport const DefaultLanes: Lanes = /*                   */ 0b0000000000000000000111000000000;\n\nconst TransitionHydrationLane: Lane = /*                */ 0b0000000000000000001000000000000;\nconst TransitionLanes: Lanes = /*                       */ 0b0000000001111111110000000000000;\n\nconst RetryLanes: Lanes = /*                            */ 0b0000011110000000000000000000000;\n\nexport const SomeRetryLane: Lanes = /*                  */ 0b0000010000000000000000000000000;\n\nexport const SelectiveHydrationLane: Lane = /*          */ 0b0000100000000000000000000000000;\n\nconst NonIdleLanes = /*                                 */ 0b0000111111111111111111111111111;\n\nexport const IdleHydrationLane: Lane = /*               */ 0b0001000000000000000000000000000;\nconst IdleLanes: Lanes = /*                             */ 0b0110000000000000000000000000000;\n\nexport const OffscreenLane: Lane = /*                   */ 0b1000000000000000000000000000000;\n")])])]),a("p",[e._v("InputDiscreteLanes 是“用户交互”触发更新会拥有的优先级范围。")]),e._v(" "),a("p",[e._v("DefaultLanes是“请求数据返回后触发更新”拥有的优先级范围。")]),e._v(" "),a("p",[e._v("TransitionLanes是Suspense、useTransition、useDeferredValue拥有的优先级范围。")]),e._v(" "),a("h3",{attrs:{id:"位与运算"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#位与运算"}},[e._v("#")]),e._v(" 位与运算：")]),e._v(" "),a("ul",[a("li",[e._v("前置知识：")])]),e._v(" "),a("p",[e._v("正数的原码，反码，补码不变\n负数的反码是对其原码按位取反，符号位不变\n补码是在其反码基础上+1")]),e._v(" "),a("p",[e._v("例如：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let lanes =  0b011 -> 00000011\n   -lanes = -0b011 -> 10000011(原码) ->11111100(反码) -> 11111101(补码)\n   lanes & -lanes = 00000011 &  11111101 -> 00000001 -> 1\n")])])]),a("p",[e._v("位合并位运算：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("export function mergeLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {\n  return a | b;\n}\n")])])]),a("p",[e._v("lane存在交集：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("export function includesSomeLane(a: Lanes | Lane, b: Lanes | Lane) {\n  return (a & b) !== NoLane;\n}\n")])])]),a("p",[e._v("subSet是set的子集：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("export function isSubsetOfLanes(set: Lanes, subset: Lanes | Lane) {\n  return (set & subset) === subset;\n}\n")])])]),a("p",[e._v("将subset从set移除：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("export function removeLanes(set: Lanes, subset: Lanes | Lane): Lanes {\n  return set & ~subset;\n}\n")])])]),a("h3",{attrs:{id:"异步可中断"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步可中断"}},[e._v("#")]),e._v(" 异步可中断")])])}),[],!1,null,null,null);n.default=s.exports}}]);