(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{515:function(e,n,t){"use strict";t.r(n);var a=t(28),s=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h3",{attrs:{id:"类型断言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类型断言"}},[e._v("#")]),e._v(" 类型断言")]),e._v(" "),t("p",[e._v("ts是强类型，在声明变量的时候，我们必须给他一个类型\n具体类型：\nTypeScript允许你覆盖它的推断，并且能以你任何你想要的方式分析它。类型断言有两种语法，as语法和尖括号语法。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const p: unknown = 'a,b,c';\np.split(','); // 报错：Object is of type 'unknown'.\n")])])]),t("p",[e._v("unknown类型的p直接这样写会报错，可以使用类型断言：")]),e._v(" "),t("ul",[t("li",[e._v("写法一：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("(p as string).split(',');\n")])])]),t("ul",[t("li",[e._v("写法二：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("(<string>m).split(',');\n\n\n注意：\n在使用TypeScript和JSX的时候，只有as语法可以用，在APP.tsx中尝试使用(<string>m).split(',');会报错： \nProperty 'string' does not exist on type 'JSX.IntrinsicElements'.\nJSX element 'string' has no corresponding closing tag.\n因为<string>被当成HTML元素来处理了，但是有没有找到对应的元素。 \n\n")])])]),t("h3",{attrs:{id:"类型声明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类型声明"}},[e._v("#")]),e._v(" 类型声明")]),e._v(" "),t("p",[e._v("interface、type、declare、class都可以声明类型")]),e._v(" "),t("h4",{attrs:{id:"interface-type"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#interface-type"}},[e._v("#")]),e._v(" interface/type")]),e._v(" "),t("p",[e._v("interface侧重于描述数据结构，type侧重于描述类型\n区别：")]),e._v(" "),t("ul",[t("li",[e._v("type alias 可以重命名原始类型，interface不可以：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("type Num = number;\n// interface 不行\n")])])]),t("ul",[t("li",[e._v("interface可以进行声明合并， type alias不可以：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("interface Mammal {\n    genus: string\n}\n\ninterface Mammal {\n    breed: string\n}\n\n// 前面两个interface被合并成一个同时具有genus和breed属性的类型\nconst animal: Mammal = {\n    genus: \"1234\",\n    // Fails because breed has to be a string\n    breed: '2'\n}\n\ntype Reptile = {\n    genus: string\n}\n\n// type一旦被声明，不能再加新属性\ntype Reptile = {\n    breed?: string\n}\n")])])]),t("h4",{attrs:{id:"extends-implements"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#extends-implements"}},[e._v("#")]),e._v(" extends/implements")]),e._v(" "),t("p",[e._v("extends")]),e._v(" "),t("ul",[t("li",[e._v("extends 类似于 es6 class 对应的extends")]),e._v(" "),t("li",[e._v("实现类的继承  class Son extends Father {}")]),e._v(" "),t("li",[e._v("实现和接口的继承")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("interface ISon extends IFather {\n  sonValue: number; // ISon上除了从IFather继承的属性，还增加了sonValue\n}\n")])])]),t("p",[e._v("implements")]),e._v(" "),t("ul",[t("li",[e._v("类与类之间 class Son implements Father {} // 用于类之间，此时没有继承的效果，而是要求Son上要有定义Father类的属性和方法")]),e._v(" "),t("li",[e._v("类与接口之间： class Son implements IFather {} //用接口去规范class，要求Son上的属性和方法按照IFather接口中定义来\n示例:")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("interface ManLike {\n  speak(): void;\n  leg: number;\n  hand: number;\n}\nclass Human implements ManLike {\n  leg: number = 2;\n  hand: number = 2;\n  speak() {\n    console.log('i can speak');\n  }\n}\ninterface Chinese extends Human {\n  country: string;\n}\n\n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);