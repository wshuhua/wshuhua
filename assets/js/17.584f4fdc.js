(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{470:function(t,a,_){"use strict";_.r(a);var s=_(28),v=Object(s.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h3",{attrs:{id:"_01-为什么要异步i-o"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_01-为什么要异步i-o"}},[t._v("#")]),t._v(" 01. 为什么要异步I/O")]),t._v(" "),_("p",[t._v("在跨网络的结构下，并发已经是现代编程的标准配备。主要从用户体验与资源分配这两个方面说起。")]),t._v(" "),_("h4",{attrs:{id:"用户体验"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#用户体验"}},[t._v("#")]),t._v(" 用户体验")]),t._v(" "),_("p",[t._v("由于浏览器中JavaScript在单线程上执行，并且与UI渲染共用一个进程。这表示着JavaScript在执行的时候UI渲染和响应是处于停滞状态的。在《高性能JavaScript》-书中总提到过，如果脚本的执行事件超过100ms, 用户就会感到页面卡顿。在B/S模型中，网络速度的限制给网页的实时体验造成很大的麻烦。\n如果网页临时需要获取网页资源，通过同步的方式获取，在js等待资源期间，ui停顿，不响应用户的交互行为。")]),t._v(" "),_("p",[t._v("采用异步请求，在下载资源期间，JavaScript和UI的执行都不会处于等待状态，可以继续响应用户交互行为。")]),t._v(" "),_("p",[t._v("前端可以通过异步消除UI阻塞的现象，但是前端获取资源的速度取决于后端的响应速度。假如一个资源来自于两个不同位置的数据返回，第一个资源需要M ms的耗时，第二个资源需要N ms的耗时。如果采用同步方式。总耗时：SUM(M,N)")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("// 消费时间为M\ngetData('from_db');\n// 消费时间为N\ngetData('from_remote_api'); \n")])])]),_("p",[t._v("采用异步的方式，第一个资源的获取不会阻塞第二个资源，我们可以享受并发的优势。总耗时：MAX(M,N)")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("// 消费时间为M\ngetData('from_db');\n// 消费时间为N\ngetData('from_remote_api'); \n")])])]),_("p",[t._v("从CPU一级缓存到网络的数据访问所需要的开销")]),t._v(" "),_("p",[_("img",{attrs:{src:"/images/node/%E4%B8%8D%E5%90%8CIO%E7%B1%BB%E5%9E%8B%E5%BC%80%E9%94%80.png",alt:""}})]),t._v(" "),_("h4",{attrs:{id:"资源分配"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#资源分配"}},[t._v("#")]),t._v(" 资源分配")]),t._v(" "),_("p",[t._v("计算机在发展过程中将组件进行了抽象，分为 "),_("code",[t._v("I/O设备")]),t._v(" 和"),_("code",[t._v("计算设备")]),t._v("。")]),t._v(" "),_("p",[t._v("假设业务场景中有一组互不相关的任务需要完成，现行的主要方法有一下两种：")]),t._v(" "),_("ul",[_("li",[t._v("单线程串行依次完成")]),t._v(" "),_("li",[t._v("多线程并行完成\n如果创建多线程的开销小于并行执行，那么多线程的方式是首选。多线程的代价在于创建线程和执行期线程上下文切换的开销较大。另外，在复杂的业务中，多线程编程经常面临锁，状态同步等问题，这是多线程被垢病的主要原因。但是多线程在多核CPU上能够提升CPU的利用率。")])]),t._v(" "),_("p",[t._v("单线程顺序执行任务的方式比较符合编程人员按顺序思考的思维方式。它依然是最主流的编程方式，因为它易于表达。但是串行执行的缺点在于性能，任意一个略慢点任务都会导致后续执行代码被阻塞。在计算机资源中，通常I/O与CPU计算之间是可以并行进行的。但是同步编程模型导致的问题是，I/O 的进行会让后续任务等待，这造成资源不能被更好地利用。")]),t._v(" "),_("p",[t._v("操作系统会将CPU的时间分配给其余进程，以公告而有效利用资源。基于这一点，有的服务器未了提高响应性能，会通过启动多个工作进程来更多的用户服务。但是对于这一组任务而言，它无法分发任务到多个进程上，所以依然高效利用资源，结束所有任务所需的时间将会较长。")]),t._v(" "),_("p",[t._v("添加硬件资源是一种提升服务质量的方式，但它不是唯一的方式。")]),t._v(" "),_("p",[t._v("单线程同步编程模型会因阻塞I/O导致硬件资源得不到更优的使用。多线程编程模型也因为编程中的死锁，状态同步等问题让开发人员头疼。")]),t._v(" "),_("p",[t._v("Node在两者之间给出了方案： "),_("code",[t._v("利用单单程，远离多线程死锁，状态同步等问题,利用异步I/O，在单线程远离阻塞，以更好的使用CPU")]),t._v("。\n未了弥补单线程无法利用多核CPU的缺点，Node提供了类似前端浏览器中Web Workers的子进程，该子进程可以通过工作进程高效的利用CPU和I/O。")]),t._v(" "),_("p",[t._v("异步I/O的提出是期望I/O的调用不在乎阻塞后续运算，将原有等待I/O完成的这边时间分配给其他需要的业务去执行。")]),t._v(" "),_("p",[_("img",{attrs:{src:"/images/node/%E5%BC%82%E6%AD%A5IO%E7%9A%84%E8%B0%83%E7%94%A8.png",alt:""}})]),t._v(" "),_("h3",{attrs:{id:"_02-异步i-o-与非阻塞i-o"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_02-异步i-o-与非阻塞i-o"}},[t._v("#")]),t._v(" 02. 异步I/O 与非阻塞I/O")]),t._v(" "),_("p",[t._v("从实际效果看，异步与非阻塞都达到了我们并行I/O的目的。但是从计算机内核而言，异步/同步和阻塞/非阻塞实际是两回事。")]),t._v(" "),_("p",[t._v("操作系统内核对于I/O只有两种方式：阻塞与非阻塞。在调用阻塞I/O时，应用程序需要等待I/O完成才返回结果。如下图所示：\n"),_("img",{attrs:{src:"/images/node/%E8%B0%83%E7%94%A8%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E7%9A%84%E8%BF%87%E7%A8%8B.png",alt:""}})]),t._v(" "),_("p",[t._v("阻塞I/O的一个特点是调用之后一定要等到系统内核层面完成所有操作后，调用才结束。以读取磁盘上的一段文件为例，系统内核在完成磁盘寻道，读取数据，复制数据道内存之后，这个调用才结束。")]),t._v(" "),_("p",[t._v("阻塞I/O造成CPU等待I/O，浪费等待时间，CPU的处理能力不能得到充分利用。为了提高性能，内核提供了非阻塞I/O。非阻塞I/O与阻塞I/O的差别为调用之后会立即返回。")]),t._v(" "),_("p",[_("img",{attrs:{src:"/images/node/%E8%B0%83%E7%94%A8%E9%98%BB%E5%A1%9EIO%E8%BF%87%E7%A8%8B.png",alt:""}})]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),_("p",[t._v("操作系统对计算机进行了抽象，将所有输入输出设备抽象为文件。内核在进行文件I/O操作时，通过文件描述符进行管理，而文件描述符类似于应用程序与系统内核的凭证。应用程序如果需要I/O调用，需要先打开文件描述符，然后再根据文件描述符去实现文件的数据读写。此处非阻塞I/O与阻塞I/O完成整个获取数据的过程，而非阻塞I/O不带入数据直接返回，要获取数据，需要通过文件描述符再次进行读取。")])]),t._v(" "),_("p",[t._v("非阻塞I/O返回后，CPU时间可以用来处理其他事物，性能得到提升。")]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("非阻塞I/O存在的问题")]),t._v(" "),_("p",[t._v("由于完整的I/O没有完成，立即返回的不是业务层期望的数据，而仅仅是当前调用的状态。为了获取完整的数据，应用程序需要重复调用I/O操作来确认是否完成。这种重复调用判断操作是否完成的技术称为"),_("code",[t._v("轮训")]),t._v("。\n阻塞I/O造成CPU等待浪费。非阻塞I/O的问题是需要轮询去确认是否完全完成数据获取，他会让CPU处理状态判断，是对CPU的浪费。")])]),t._v(" "),_("p",[t._v("轮询技术主要有以下几种：")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("read: 最原始，性能最低的一种。通过重复调用来检查I/O的状态来完成完整数据的读取。在得到最终数据前，CPU一直耗用在等待上。\n"),_("img",{attrs:{src:"/images/node/%E9%80%9A%E8%BF%87read%E8%BF%9B%E8%A1%8C%E8%BD%AE%E8%AF%A2.png",alt:""}})])]),t._v(" "),_("li",[_("p",[t._v("select。在read基础上改进的一个方案。通过对文件描述符上的事件状态来进行判断。\nselect轮询具有一个较弱的限制。由于它采用一个1024长度的数组来存储状态。所以它最多可以同时检查1024个文件描述符。\n"),_("img",{attrs:{src:"/images/node/%E9%80%9A%E8%BF%87select%E8%BF%9B%E8%A1%8C%E8%BD%AE%E8%AF%A2.png",alt:""}})])]),t._v(" "),_("li",[_("p",[t._v("poll: 在select方案上进行改进，采用链表的方式避免数组长度的限制，其次它能避免不需要的检查。但是当文件描述符较多的时候，性能比较低下。\n"),_("img",{attrs:{src:"/images/node/%E9%80%9A%E8%BF%87poll%E5%AE%9E%E7%8E%B0%E8%BD%AE%E8%AF%A2.png",alt:""}})])]),t._v(" "),_("li",[_("p",[t._v("epoll: 该方案是linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查道I/O事件，将会进行休眠，直到事件发生将它唤醒。它是真实利用到了事件通知，执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高。\n"),_("img",{attrs:{src:"/images/node/%E9%80%9A%E8%BF%87epoll%E5%AE%9E%E7%8E%B0%E8%BD%AE%E8%AF%A2.png",alt:""}})])]),t._v(" "),_("li",[_("p",[t._v("kqueue：与epoll类似。在FreeBSD系统下存在。")])])]),t._v(" "),_("p",[t._v("轮询技术满足了非阻塞I/O确保获取完整数据的需求。但是对于应用程序而言，它仍然只能算是一种状态同步，因为应用程序仍然需要等待I/O完全返回，依旧花费了很多时间来等待。等待期间，CPU 不是用户遍历文件描述符的状态，就是用于休眠等待事件发生。")]),t._v(" "),_("h4",{attrs:{id:"非阻塞i-o-理想下"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#非阻塞i-o-理想下"}},[t._v("#")]),t._v(" 非阻塞I/O（理想下）")]),t._v(" "),_("p",[t._v("尽管epoll通过事件来降低CPU的消耗，但是休眠期CPU几乎是闲置的，对于当前线程利用率不高。\n理想中的完美异步I/O是应用阻塞发起非阻塞调用，无须通过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务，只需要在I/O完成后通过信号或回调将数据传递给应用程序。")]),t._v(" "),_("p",[_("img",{attrs:{src:"/images/node/%E7%90%86%E6%83%B3%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5IO.png",alt:""}})]),t._v(" "),_("p",[t._v("只有在linux下存在这样一种方式，它原生提供的一种异步I/O方式（AIO）就是通过信号或回调来传递数据的。存在缺陷：AIO仅支持内核I/O中的O_DIRECT方式读取，导致无法利用系统缓存。")]),t._v(" "),_("h4",{attrs:{id:"异步i-o-现实"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#异步i-o-现实"}},[t._v("#")]),t._v(" 异步I/O（现实）")]),t._v(" "),_("p",[t._v("假设场景：\n在单线程下，多线程的方式会是另外一种风景。通过让部分线程进行阻塞I/O或者非I/O加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I/O得到的数据进行传递。如图所示：")]),t._v(" "),_("p",[_("img",{attrs:{src:"/images/node/%E5%BC%82%E6%AD%A5IO.png",alt:""}})]),t._v(" "),_("p",[t._v("在Node中采用libuv作为抽象封装层，使得所有平台兼容性的判断都有这一层判断，并保证了上层的Node与下层自定义线程池及IOCP之间各自独立。\nNode在编译期间会判断平台条件，选择性编译unix目录还是win目录喜爱的源文件到目标程序中。\n架构图如下；\n"),_("img",{attrs:{src:"/images/node/%E5%9F%BA%E4%BA%8Elibvu%E7%9A%84%E6%9E%B6%E6%9E%84%E5%9B%BE.png",alt:""}})]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),_("ol",[_("li",[t._v("这里的I/O不仅仅只限于磁盘文件的读写。*nix将计算机抽象了一番，磁盘文件、硬件等几乎所有计算机资源都被抽象成了文件。因此，这里描述的阻塞与非阻塞的情况同样适用于套接字。")]),t._v(" "),_("li",[t._v("Node是单线程，这里的单线程仅仅只是JavaScript执行在单线程中的。在Node中，无论是*nix还是windows平台，内部完成I/O任务的另有线程池。")])])]),t._v(" "),_("h3",{attrs:{id:"_03-nodejs的异步i-o"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_03-nodejs的异步i-o"}},[t._v("#")]),t._v(" 03. NodeJs的异步I/O")]),t._v(" "),_("p",[t._v("在Node中如何实现异步I/？")]),t._v(" "),_("h4",{attrs:{id:"事件循环"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事件循环"}},[t._v("#")]),t._v(" 事件循环")]),t._v(" "),_("p",[t._v("Node自身的执行模型 - "),_("code",[t._v("事件循环")]),t._v("，正是它使得回调函数十分普遍。")]),t._v(" "),_("p",[t._v("在进程启动时，Node会创建一个类似于while(true)的循环，每执行一次循环体的人过程我们称为"),_("code",[t._v("Tick")]),t._v(".\n每个"),_("code",[t._v("Tick")]),t._v("的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。\n然后进入下一个循环，如果不再有事件处理，就退出进程。")]),t._v(" "),_("p",[_("img",{attrs:{src:"/images/node/Tick%E6%B5%81%E7%A8%8B%E5%9B%BE.png",alt:""}})]),t._v(" "),_("h3",{attrs:{id:"_04-非i-o的异步api"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_04-非i-o的异步api"}},[t._v("#")]),t._v(" 04. 非I/O的异步API")]),t._v(" "),_("h3",{attrs:{id:"_05-事件驱动与高性能服务器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_05-事件驱动与高性能服务器"}},[t._v("#")]),t._v(" 05. 事件驱动与高性能服务器")])])}),[],!1,null,null,null);a.default=v.exports}}]);