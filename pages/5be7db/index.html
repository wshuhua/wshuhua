<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器原理 | Wsh&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/images/logo.png">
    <meta name="description" content="web前端技术博客,专注web前端学习与总结。JavaScript,js,ES6,TypeScript,vue,React,python,css3,html5,Node,git,github等技术文章。">
    
    <link rel="preload" href="/assets/css/0.styles.bc63fb2f.css" as="style"><link rel="preload" href="/assets/js/app.abd80959.js" as="script"><link rel="preload" href="/assets/js/2.dc8a2400.js" as="script"><link rel="preload" href="/assets/js/49.4fd36a66.js" as="script"><link rel="prefetch" href="/assets/js/10.57255fdd.js"><link rel="prefetch" href="/assets/js/11.9356ed36.js"><link rel="prefetch" href="/assets/js/12.3ad835bb.js"><link rel="prefetch" href="/assets/js/13.7c8ea0da.js"><link rel="prefetch" href="/assets/js/14.1380d324.js"><link rel="prefetch" href="/assets/js/15.b6956ee1.js"><link rel="prefetch" href="/assets/js/16.8f6a30d6.js"><link rel="prefetch" href="/assets/js/17.5612ad75.js"><link rel="prefetch" href="/assets/js/18.ac170b7c.js"><link rel="prefetch" href="/assets/js/19.7c7f3690.js"><link rel="prefetch" href="/assets/js/20.699f5758.js"><link rel="prefetch" href="/assets/js/21.77977f4f.js"><link rel="prefetch" href="/assets/js/22.342bf844.js"><link rel="prefetch" href="/assets/js/23.95dae306.js"><link rel="prefetch" href="/assets/js/24.5568dd6d.js"><link rel="prefetch" href="/assets/js/25.c41a6580.js"><link rel="prefetch" href="/assets/js/26.63382b0b.js"><link rel="prefetch" href="/assets/js/27.9d4203cc.js"><link rel="prefetch" href="/assets/js/28.c082e439.js"><link rel="prefetch" href="/assets/js/29.a96448c6.js"><link rel="prefetch" href="/assets/js/3.81312ee3.js"><link rel="prefetch" href="/assets/js/30.17f62e20.js"><link rel="prefetch" href="/assets/js/31.66c21430.js"><link rel="prefetch" href="/assets/js/32.515aab89.js"><link rel="prefetch" href="/assets/js/33.f39584f5.js"><link rel="prefetch" href="/assets/js/34.eeaa6001.js"><link rel="prefetch" href="/assets/js/35.c915dec5.js"><link rel="prefetch" href="/assets/js/36.906ff609.js"><link rel="prefetch" href="/assets/js/37.af997daa.js"><link rel="prefetch" href="/assets/js/38.58e38c72.js"><link rel="prefetch" href="/assets/js/39.2fb6607a.js"><link rel="prefetch" href="/assets/js/4.c704e751.js"><link rel="prefetch" href="/assets/js/40.fd291033.js"><link rel="prefetch" href="/assets/js/41.757263ff.js"><link rel="prefetch" href="/assets/js/42.27aef523.js"><link rel="prefetch" href="/assets/js/43.701d1cb6.js"><link rel="prefetch" href="/assets/js/44.03138205.js"><link rel="prefetch" href="/assets/js/45.dc1f978e.js"><link rel="prefetch" href="/assets/js/46.1905c7db.js"><link rel="prefetch" href="/assets/js/47.b5964080.js"><link rel="prefetch" href="/assets/js/48.a441d1b6.js"><link rel="prefetch" href="/assets/js/5.2db75e05.js"><link rel="prefetch" href="/assets/js/50.f35dadce.js"><link rel="prefetch" href="/assets/js/51.696b743e.js"><link rel="prefetch" href="/assets/js/52.cb5a5cfb.js"><link rel="prefetch" href="/assets/js/53.142fe0b6.js"><link rel="prefetch" href="/assets/js/54.64b5e305.js"><link rel="prefetch" href="/assets/js/55.84c16fee.js"><link rel="prefetch" href="/assets/js/56.bff4129c.js"><link rel="prefetch" href="/assets/js/57.f78352c2.js"><link rel="prefetch" href="/assets/js/58.2b95d0cf.js"><link rel="prefetch" href="/assets/js/59.f5e8f3ca.js"><link rel="prefetch" href="/assets/js/6.9073f8bb.js"><link rel="prefetch" href="/assets/js/60.33f2c7e7.js"><link rel="prefetch" href="/assets/js/61.89f06a7a.js"><link rel="prefetch" href="/assets/js/62.8c20bcf9.js"><link rel="prefetch" href="/assets/js/63.ccdd8c78.js"><link rel="prefetch" href="/assets/js/64.3a985679.js"><link rel="prefetch" href="/assets/js/65.d129cacf.js"><link rel="prefetch" href="/assets/js/66.3cb45d28.js"><link rel="prefetch" href="/assets/js/67.a1c6a016.js"><link rel="prefetch" href="/assets/js/68.62d560f2.js"><link rel="prefetch" href="/assets/js/69.e3fddf31.js"><link rel="prefetch" href="/assets/js/7.733f78a6.js"><link rel="prefetch" href="/assets/js/70.c233638a.js"><link rel="prefetch" href="/assets/js/71.cc057214.js"><link rel="prefetch" href="/assets/js/72.b37c39f9.js"><link rel="prefetch" href="/assets/js/73.03f9ceb9.js"><link rel="prefetch" href="/assets/js/74.ac2174bc.js"><link rel="prefetch" href="/assets/js/75.393c0e48.js"><link rel="prefetch" href="/assets/js/76.dedded4f.js"><link rel="prefetch" href="/assets/js/77.94ba6b26.js"><link rel="prefetch" href="/assets/js/78.a13524be.js"><link rel="prefetch" href="/assets/js/79.e69e51e9.js"><link rel="prefetch" href="/assets/js/8.77d48f5d.js"><link rel="prefetch" href="/assets/js/9.84cabc87.js">
    <link rel="stylesheet" href="/assets/css/0.styles.bc63fb2f.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/images/1.gif" alt="Wsh's blog" class="logo"> <span class="site-name can-hide">Wsh's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="知识👖" class="dropdown-title"><a href="/note/" class="link-title">知识👖</a> <span class="title" style="display:none;">知识👖</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/cache/" class="nav-link">《前端缓存》</a></li><li class="dropdown-item"><!----> <a href="/note/react/" class="nav-link">《React》</a></li><li class="dropdown-item"><!----> <a href="/note/typescript/" class="nav-link">《typescript》</a></li><li class="dropdown-item"><!----> <a href="/note/javascript/" class="nav-link">《javascript》</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工程🌹" class="dropdown-title"><a href="/tool/" class="link-title">工程🌹</a> <span class="title" style="display:none;">工程🌹</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/tool/node/" class="nav-link">node</a></li><li class="dropdown-item"><!----> <a href="/tool/webpack/" class="nav-link">webpack</a></li></ul></div></div><div class="nav-item"><a href="/note/algorithm/" class="nav-link">轻松一刻😉</a></div><div class="nav-item"><a href="/pages/ca0c25/" class="nav-link">宝库📰</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引🔒" class="dropdown-title"><a href="/archives/" class="link-title">索引🔒</a> <span class="title" style="display:none;">索引🔒</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div><div class="nav-item"><a href="https://blog.fudenglong.site" target="_blank" rel="noopener noreferrer" class="nav-link external">
  龙哥的大🐂之路
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/wshuhua" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/images/avatar.gif"> <div class="blogger-info"><h3>wsh</h3> <span>热爱前端的程序媛</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="知识👖" class="dropdown-title"><a href="/note/" class="link-title">知识👖</a> <span class="title" style="display:none;">知识👖</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/cache/" class="nav-link">《前端缓存》</a></li><li class="dropdown-item"><!----> <a href="/note/react/" class="nav-link">《React》</a></li><li class="dropdown-item"><!----> <a href="/note/typescript/" class="nav-link">《typescript》</a></li><li class="dropdown-item"><!----> <a href="/note/javascript/" class="nav-link">《javascript》</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工程🌹" class="dropdown-title"><a href="/tool/" class="link-title">工程🌹</a> <span class="title" style="display:none;">工程🌹</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/tool/node/" class="nav-link">node</a></li><li class="dropdown-item"><!----> <a href="/tool/webpack/" class="nav-link">webpack</a></li></ul></div></div><div class="nav-item"><a href="/note/algorithm/" class="nav-link">轻松一刻😉</a></div><div class="nav-item"><a href="/pages/ca0c25/" class="nav-link">宝库📰</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引🔒" class="dropdown-title"><a href="/archives/" class="link-title">索引🔒</a> <span class="title" style="display:none;">索引🔒</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div><div class="nav-item"><a href="https://blog.fudenglong.site" target="_blank" rel="noopener noreferrer" class="nav-link external">
  龙哥的大🐂之路
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/wshuhua" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/pages/b26575/" class="sidebar-link">浏览器概述</a></li><li><a href="/pages/5be7db/" aria-current="page" class="active sidebar-link">浏览器原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/5be7db/#_1-宏观视角下的浏览器" class="sidebar-link">1. 宏观视角下的浏览器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/5be7db/#_1-1-chrome架构演变史" class="sidebar-link">1.1 Chrome架构演变史</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/5be7db/#_2-tcp协议" class="sidebar-link">2. TCP协议</a></li><li class="sidebar-sub-header level2"><a href="/pages/5be7db/#_3-http请求流程" class="sidebar-link">3. HTTP请求流程</a></li><li class="sidebar-sub-header level2"><a href="/pages/5be7db/#_4-导航流程" class="sidebar-link">4. 导航流程</a></li><li class="sidebar-sub-header level2"><a href="/pages/5be7db/#_5-渲染流程" class="sidebar-link">5. 渲染流程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/5be7db/#_5-1-构建-dom-树" class="sidebar-link">5.1 构建 DOM 树</a></li><li class="sidebar-sub-header level3"><a href="/pages/5be7db/#_5-2-样式计算-recalculate-style" class="sidebar-link">5.2 样式计算（Recalculate Style）</a></li><li class="sidebar-sub-header level3"><a href="/pages/5be7db/#_5-3-布局阶段" class="sidebar-link">5.3 布局阶段</a></li><li class="sidebar-sub-header level3"><a href="/pages/5be7db/#_5-4-分层" class="sidebar-link">5.4 分层</a></li><li class="sidebar-sub-header level3"><a href="/pages/5be7db/#_5-5-图层绘制" class="sidebar-link">5.5 图层绘制</a></li><li class="sidebar-sub-header level3"><a href="/pages/5be7db/#_5-6-栅格化-raster-操作" class="sidebar-link">5.6 栅格化（raster）操作</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/5be7db/#_6-浏览器下的执行机制" class="sidebar-link">6. 浏览器下的执行机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/5be7db/#_6-1-变量提升" class="sidebar-link">6.1 变量提升</a></li><li class="sidebar-sub-header level3"><a href="/pages/5be7db/#_6-2-调用栈" class="sidebar-link">6.2 调用栈</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/5be7db/#_7-页面循环系统" class="sidebar-link">7. 页面循环系统</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/5be7db/#_7-1-消息队列和事件循环" class="sidebar-link">7.1 消息队列和事件循环</a></li><li class="sidebar-sub-header level3"><a href="/pages/5be7db/#_7-2-settimeout实现原理" class="sidebar-link">7.2 setTimeout实现原理</a></li><li class="sidebar-sub-header level3"><a href="/pages/5be7db/#_7-3-xmlhttprequest实现原理" class="sidebar-link">7.3 XMLHttpRequest实现原理</a></li><li class="sidebar-sub-header level3"><a href="/pages/5be7db/#_7-4-宏任务和微任务" class="sidebar-link">7.4 宏任务和微任务</a></li><li class="sidebar-sub-header level3"><a href="/pages/5be7db/#_7-5-async-await" class="sidebar-link">7.5 async/await</a></li></ul></li></ul></li><li><a href="/pages/4bb833/" class="sidebar-link">v8引擎</a></li><li><a href="/pages/82425d/" class="sidebar-link">requestIdleCallback/requestAnimationFrame 区别</a></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper bg-style-6"><div class="articleInfo-wrap" data-v-0c557b5e><div class="articleInfo" data-v-0c557b5e><ul class="breadcrumbs" data-v-0c557b5e><li data-v-0c557b5e><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-0c557b5e></a></li> <li data-v-0c557b5e><a href="/categories/?category=%E3%80%8Ajavascript%E3%80%8B%E7%AC%94%E8%AE%B0" title="分类" data-v-0c557b5e>《javascript》笔记</a></li></ul> <div class="info" data-v-0c557b5e><!----> <div title="创建时间" class="date iconfont icon-riqi" data-v-0c557b5e><a href="javascript:;" data-v-0c557b5e>2022-05-31</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">浏览器原理<!----></h1> <!----> <div class="theme-vdoing-content content__default"><h2 id="_1-宏观视角下的浏览器"><a href="#_1-宏观视角下的浏览器" class="header-anchor">#</a> 1. 宏观视角下的浏览器</h2> <h3 id="_1-1-chrome架构演变史"><a href="#_1-1-chrome架构演变史" class="header-anchor">#</a> 1.1 Chrome架构演变史</h3> <h4 id="单进程浏览器时代"><a href="#单进程浏览器时代" class="header-anchor">#</a> 单进程浏览器时代：</h4> <p>单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等</p> <p>如此多的功能模块运行在一个进程里，导致单进程浏览器不稳定、不流畅和不安全的一个主要因素。</p> <ul><li>不稳定</li></ul> <p>早期浏览器需要借助于插件来实现诸如 Web 视频、Web 游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。</p> <p>除了插件之外，渲染引擎模块也是不稳定的，通常一些复杂的 JavaScript 代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃。</p> <ul><li>不流畅</li></ul> <p>所有页面的渲染模块、JavaScript 执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。</p> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token keyword">function</span> <span class="token function">freeze</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;freeze&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">freeze</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果让这个脚本运行在一个单进程浏览器的页面里 会导致什么？</p> <p>因为浏览器中所有的页面都运行在该线程中，所以这些页面都没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。</p> <p>除了上述脚本或者插件会让单进程浏览器变卡顿外，页面的内存泄漏也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢。</p> <ul><li>不安全</li></ul> <p>插件可以使用 C/C++ 等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也就意味着这个插件能完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。至于页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。</p> <h4 id="多进程浏览器时代"><a href="#多进程浏览器时代" class="header-anchor">#</a> 多进程浏览器时代</h4> <p>早期多进程架构：</p> <p><img src="/images/js/chrome1.png" alt=""></p> <p>Chrome早期多进程架构，由插件进程、渲染进程和主进程组成，进程之间由 IPC进行通信</p> <ul><li>由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就解决了页面或者插件的崩溃会导致整个浏览器崩溃。</li></ul> <div class="custom-block tip"><p class="custom-block-title">多进程架构也会出现一个页面崩溃影响到其他页面的情况</p> <p>通常情况下是一个页面使用一个进程，但是，有一种情况，叫&quot;同一站点(same-site)&quot;。</p> <p>具体地讲，我们将“同一站点”定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：</p> <ul><li>https://time.geekbang.org</li> <li>https://www.geekbang.org</li> <li>https://www.geekbang.org:8080</li></ul> <p>都是属于同一站点，因为它们的协议都是https，而根域名也都是geekbang.org。</p> <p>Chrome的默认策略是：每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫<code>process-per-site-instance</code>。 直白的讲，就是如果几个页面符合同一站点，那么他们将被分配到一个渲染进程里面去。 所以，这种情况下，一个页面崩溃了，会导致同一站点的页面同时崩溃，因为他们使用了同一个渲染进程。 为什么要让他们跑在一个进程里面呢？ 因为在一个渲染进程里面，他们就会共享JS的执行环境，也就是说A页面可以直接在B页面中执行脚本。因为是同一家的站点，所以是有这个需求的。</p></div> <div class="custom-block tip"><p class="custom-block-title">同一站点和同源策略区别</p></div> <ul><li><p>内存泄漏的解决方法: 因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。</p></li> <li><p>安全问题解决：使用安全沙箱。可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</p></li></ul> <h4 id="目前多进程架构"><a href="#目前多进程架构" class="header-anchor">#</a> 目前多进程架构</h4> <p><img src="/images/js/chrome2.png" alt=""></p> <p>最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。</p> <ul><li><p>浏览器主进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</p></li> <li><p>渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，<code>排版引擎 Blink</code> 和 <code>JavaScript 引擎 V8</code> 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</p></li> <li><p>GPU进程：Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</p></li> <li><p>网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</p></li> <li><p>插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</p></li></ul> <h4 id="优点-缺点"><a href="#优点-缺点" class="header-anchor">#</a> 优点/缺点</h4> <p>多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：</p> <ul><li>更高的资源占用。因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。</li> <li>更复杂的体系架构。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。</li></ul> <p>对于上面这两个问题，Chrome 团队一直在寻求一种弹性方案，既可以解决资源占用高的问题，也可以解决复杂的体系架构的问题。</p> <h4 id="未来面向服务的架构"><a href="#未来面向服务的架构" class="header-anchor">#</a> 未来面向服务的架构</h4> <p>为了解决这些问题，在 2016 年，Chrome 官方团队使用“面向服务的架构”（Services Oriented Architecture，简称 SOA）的思想设计了新的 Chrome 架构。也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、高速、安全的目标。</p> <p>通俗来说就是以前是每个页面需要若干进程完成各自的工作，现在是将各个页面通用的功能（视频、网络、渲染等）发布为系统服务，页面在需要的时候与相应的服务通信完成需要的功能。这起码把进程间的耦合从页面中分离出去了。</p> <p>Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务</p> <p><img src="/images/js/chrome3.png" alt=""></p> <p>Chrome 还提供灵活的弹性架构，在强大性能设备上会以多进程的方式运行基础服务，但是如果在资源受限的设备上（如下图），Chrome 会将很多服务整合到一个进程中，从而节省内存占用。</p> <ul><li>在资源不足的设备上，将服务合并到浏览器进程中</li></ul> <p><img src="/images/js/chrome4.png" alt=""></p> <p>早期浏览器：
不稳定（单独进程）
不流畅（单独进程）
不安全（沙箱）</p> <p>早期多进程架构：
主进程 渲染进程 插件进程</p> <p>现代多进程架构：
主进程 渲染进程 插件进程 GPU进程 网络进程</p> <p>未来：
面向服务架构</p> <h2 id="_2-tcp协议"><a href="#_2-tcp协议" class="header-anchor">#</a> 2. TCP协议</h2> <p>性能指标:</p> <ul><li><ol><li>FP(First Paint):从开始加载到浏览器首次绘制像素到屏幕上的时间,也就是页面在屏幕上首次发生视觉变化的时间。</li></ol></li> <li><ol start="2"><li>FCP（First Contentful Paint）:浏览器首次绘制来自 DOM 的内容的时间。这是用户第一次开始看到页面内容，但仅仅有内容，并不意味着它是有用的内容（例如 Header、导航栏等），也不意味着有用户要消费的内容。</li></ol></li> <li><ol start="3"><li>FMP（First Meaningful Paint）:页面的主要内容绘制到屏幕上的时间。主要内容的定义因页面而异，例如对于博客文章，它的主要内容是标题和摘要，对于搜索页面，它的主要内容是搜索结果，对于电商的页面，图片则是主要内容。</li></ol></li> <li><ol start="4"><li>FSP（First Screen Paint）:页面从开始加载到首屏内容全部绘制完成的时间，用户可以看到首屏的全部内容。</li></ol></li> <li><ol start="5"><li>TTI（Time to Interactive）:表示网页第一次完全达到可交互状态的时间点，浏览器已经可以持续性的响应用户的输入。</li></ol></li></ul> <p>互联网中的数据是通过数据包来传输的。如果发送的数据很大，那么该数据就会被拆分为很多小数据包来传输。比如你现在听的音频数据，是拆分成一个个小的数据包来传输的，并不是一个大的文件一次传输过来的。</p> <ul><li>IP：把数据包送达目的主机</li></ul> <p>IP协议把数据分解为数据包，打包时加上本机的Ip地址，称为<code>ip头数据</code>，通过物理底层传输出去。数据包的构成：<code>数据部分+IP头部分</code>。
<img src="/images/js/ip.png" alt=""></p> <ol><li>上层将含有“极客时间”的数据包交给网络层；</li> <li>网络层再将 IP 头附加到数据包上，组成新的 IP 数据包，并交给底层；</li> <li>底层通过物理网络将数据包传输给主机 B；</li> <li>数据包被传输到主机 B 的网络层，在这里主机 B 拆开数据包的 IP 头信息，并将拆开来的数据部分交给上层；</li> <li>最终，含有“极客时间”信息的数据包就到达了主机 B 的上层了。</li></ol> <h4 id="udp-把数据包送达应用程序"><a href="#udp-把数据包送达应用程序" class="header-anchor">#</a> UDP：把数据包送达应用程序</h4> <p>“用户数据包协议（User Datagram Protocol）”，简称 UDP。</p> <p>UDP 中一个最重要的信息是端口号，端口号其实就是一个数字，每个想访问网络的程序都需要绑定一个端口号。通过端口号 <code>UDP</code> 就能把指定的数据包发送给指定的程序了，所以 <code>IP</code> 通过 <code>IP</code> 地址信息把数据包发送给指定的电脑，而 <code>UDP</code> 通过端口号把数据包分发给正确的程序。和 <code>IP</code> 头一样，端口号会被装进<code>UDP</code> 头里面，<code>UDP</code> 头再和原始数据包合并组成新的 <code>UDP</code> 数据包。<code>UDP</code> 头中除了目的端口，还有源端口号等信息。</p> <p><img src="/images/js/udp.png" alt=""></p> <ul><li>上层将含有“极客时间”的数据包交给传输层；</li> <li>传输层会在数据包前面附加上 UDP 头，组成新的 UDP 数据包，再将新的 UDP 数据包交给网络层；</li> <li>网络层再将 IP 头附加到数据包上，组成新的 IP 数据包，并交给底层；</li> <li>数据包被传输到主机 B 的网络层，在这里主机 B 拆开 IP 头信息，并将拆开来的数据部分交给传输层；</li> <li>在传输层，数据包中的 UDP 头会被拆开，并根据 UDP 中所提供的端口号，把数据部分交给上层的应用程序；</li> <li>最终，含有“极客时间”信息的数据包就旅行到了主机 B 上层应用程序这里。</li></ul> <h4 id="udp优-缺点"><a href="#udp优-缺点" class="header-anchor">#</a> UDP优/缺点</h4> <p>在使用 UDP 发送数据时，有各种因素会导致数据包出错，虽然 UDP 可以校验数据是否正确，但是对于错误的数据包，UDP 并不提供<code>重发机制</code>，只是丢弃当前的包，而且 UDP 在发送之后也无法知道是否能达到目的地。</p> <p>UDP 不能保证数据可靠性，但是传输速度却非常快，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。</p> <h4 id="tcp-把数据完整地送达应用程序"><a href="#tcp-把数据完整地送达应用程序" class="header-anchor">#</a> TCP：把数据完整地送达应用程序</h4> <p>UDP缺点：</p> <ul><li>数据包在传输过程中容易丢失；</li> <li>大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件。</li></ul> <p><code>TCP</code>（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。相对于 UDP，TCP 有下面两个特点:</p> <ul><li>对于数据包丢失的情况，TCP 提供<code>重传机制</code>；</li> <li>TCP 引入了<code>数据包排序机制</code>，用来保证把乱序的数据包组合成一个完整的文件。</li></ul> <p>和UDP 头一样，TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。</p> <p><img src="/images/js/TCP.png" alt=""></p> <p>与UDP不同的地方在于，通过 TCP 头的信息保证了一块大的数据传输的完整性。</p> <p>互联网中的数据是通过数据包来传输的，数据包在传输过程中容易丢失或出错。IP 负责把数据包送达目的主机。
UDP 负责把数据包送达具体应用。
而 TCP 保证了数据完整地传输，它的连接可分为三个阶段：建立连接、传输数据和断开连接 三个阶段。</p> <div class="custom-block tip"><p class="custom-block-title">TCP传送数据时 浏览器端就做渲染处理了么？如果前面数据包丢了 后面数据包先来是要等么？类似的那种实时渲染怎么处理？针对数据包的顺序性？</p> <p>接收到http响应头中的content-type类型时就开始准备渲染进程了，响应体数据一旦接受到便开始做DOM解析了！基于http不用担心数据包丢失的问题，因为丢包和重传都是在tcp层解决的。http能保证数据按照顺序接收的（也就是说，从tcp到http的数据就已经是完整的了，即便是实时渲染，如果发生丢包也得在重传后才能开始渲染）</p></div> <h2 id="_3-http请求流程"><a href="#_3-http请求流程" class="header-anchor">#</a> 3. HTTP请求流程</h2> <p><code>HTTP</code> 是一种允许浏览器向服务器获取资源的协议，是 <code>Web</code> 的基础，通常由浏览器发起请求，用来获取不同类型的文件，例如 <code>HTML</code> 文件、<code>CSS</code> 文件、<code>JavaScript</code> 文件、图片、视频等。此外，HTTP 也是浏览器使用最广的协议。</p> <h4 id="浏览器端发起-http-请求流程"><a href="#浏览器端发起-http-请求流程" class="header-anchor">#</a> 浏览器端发起 HTTP 请求流程</h4> <p>如果在浏览器地址栏里输入某个网站的地址，浏览器会完成哪些动作呢？</p> <ol><li>构建请求
浏览器构建请求行信息（如下所示），构建好后，浏览器准备发起网络请求。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>GET /index.html HTTP1.1
</code></pre></div><ol start="2"><li><p>查找缓存
当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。</p></li> <li><p>准备 IP 地址和端口</p></li></ol> <p>浏览器使用 HTTP 协议作为应用层协议，用来封装请求的文本信息；并使用 TCP/IP 作传输层协议将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。也就是说 HTTP 的内容是通过 TCP 的传输数据阶段来实现的</p> <p><img src="/images/js/tcp+http.png" alt=""></p> <ul><li>DNS解析</li></ul> <ol start="4"><li><ol start="4"><li>等待 TCP 队列</li></ol></li></ol> <p>Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。</p> <div class="language- extra-class"><pre class="language-text"><code>http/1.1: 一个tcp同时只能处理一个请求，浏览器会为每个域名维护6个tcp连接！ 但是每个tcp连接是可以复用的，也就是处理完一个请求之后，不断开这个tcp连接，可以用来处理下个http请求！ 
http2: 可以并行请求资源的，所以如果使用http2，浏览器只会为每个域名维护一个tcp连接
</code></pre></div><ol start="5"><li><p>建立 TCP 连接</p></li> <li><p>发送 HTTP 请求</p></li></ol> <p>浏览器会向服务器发送请求行，它包括了请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议。</p> <h4 id="服务器端处理-http-请求流程"><a href="#服务器端处理-http-请求流程" class="header-anchor">#</a> 服务器端处理 HTTP 请求流程</h4> <ol><li>返回请求</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>curl <span class="token operator">-</span>i  https<span class="token operator">:</span><span class="token operator">/</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">time.geekbang.org</span><span class="token regex-delimiter">/</span></span>
</code></pre></div><p><img src="/images/js/data.png" alt=""></p> <p>服务器会返回响应行，包括协议版本和状态码。</p> <ol start="2"><li>断开连接</li></ol> <p>通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">Connection</span><span class="token operator">:</span>Keep<span class="token operator">-</span>Alive 
</code></pre></div><p>那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。</p> <ol start="3"><li>重定向</li></ol> <div class="language- extra-class"><pre class="language-text"><code>curl -I geekbang.org
</code></pre></div><p>状态码301，从响应头的Location内容中取出重定向地址。</p> <p><img src="/images/js/location.png" alt=""></p> <p>-I表示只需要获取响应头和响应行数据，而不需要获取响应体的数据
-i是为了返回响应行、响应头和响应体的数据</p> <p>HTTP 请求示意图:
<img src="/images/js/httpLoop.png" alt=""></p> <p>浏览器中的 HTTP 请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备 IP 和端口(DNS)、等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器返回请求和断开连接。</p> <h2 id="_4-导航流程"><a href="#_4-导航流程" class="header-anchor">#</a> 4. 导航流程</h2> <p>从输入URL到页面展示，这中间发生了什么？</p> <p><img src="/images/js/render.png" alt=""></p> <ul><li><p>浏览器主要负责用户交互，子进程管理和文件存储等功能。</p></li> <li><p>网络进程是面向渲染进程和浏览器进程等提供网络下载功能。</p></li> <li><p>渲染进程的主要职责是把从网络下载的HTML，JavaScript，CSS，图片等资源解析为可以显示和交互的页面。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信息的。所以chrome采用安全沙箱模式。</p></li> <li><p>首先，浏览器进程接收到用户输入的 URL 请求，浏览器进程便将该 URL 转发给网络进程。</p></li> <li><p>然后，在网络进程中发起真正的 URL 请求。</p></li> <li><p>接着网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。</p></li> <li><p>浏览器进程接收到网络进程的响应头数据之后，发送“提交导航 (CommitNavigation)”消息到渲染进程；</p></li> <li><p>渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立<code>数据管道</code>；</p></li> <li><p>最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”。浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态。</p></li></ul> <ol><li>从输入 URL 到页面展示</li></ol> <p>当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的 URL。如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。如果判断输入内容符合 URL 规则，比如输入的是 <code>time.geekbang.org</code>，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL.</p> <p>当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 <code>beforeunload</code> 事件的机会，(beforeunload事件可以在跳转前执行一些逻辑，或者取消跳转)</p> <ol start="2"><li>URL 请求过程</li></ol> <p>接下来，便进入了页面资源请求过程。这时，浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程</p> <ul><li><p>首先，网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。这请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。</p></li> <li><p>然后利用 IP 地址和服务器建立 TCP 连接（如果请求协议是 HTTPS，那么还需要建立 TLS 连接）。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。</p></li> <li><p>服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了</p></li> <li><p>（1）重定向</p></li></ul> <p>在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 <code>301</code> 或者 <code>302</code>，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。</p> <div class="custom-block tip"><p class="custom-block-title">301/302区别</p> <p>301:永久改变的资源位置， 302:暂时改变的资源位置</p></div> <ul><li>（2）响应数据类型处理</li></ul> <p>Content-Type。Content-Type 是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。</p> <ol start="3"><li>准备渲染进程</li></ol> <p>默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中（同一站点, iframe级别的渲染进程分配）。</p> <p>打开一个新页面采用的渲染进程策略就是：</p> <p>通常情况下，打开新的页面都会使用单独的渲染进程；如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。</p> <ol start="4"><li>提交文档
所谓提交文档，就是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程，具体流程是这样的：</li></ol> <ul><li>首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；</li> <li>渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；</li> <li>等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；</li> <li>浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。</li></ul> <div class="custom-block tip"><p class="custom-block-title">形象描述</p> <ul><li>大哥大(<code>浏览器进程</code>)接收到小弟(<code>网络进程</code>)响应头数据后，通知小弟(<code>渲染进程</code>)(提交文档)，让其与网络进程建立管道通讯，</li> <li>收到大哥大的命令，小弟(<code>渲染进程</code>)赶紧与小弟（<code>网络进程</code>）建立数据管道</li> <li>渲染进程接收完网络进程的数据后，赶紧给大哥大<code>(浏览器进程)</code>汇报（确认提交）</li> <li>大哥大知道小弟处理好琐事了，开始做小弟们做不了的事，更新<code>浏览器界面状态</code> - 安全状态 - 地址栏 URL - 前进后退的历史状态 - 更新 Web 页面</li></ul></div> <ol start="5"><li>渲染阶段</li></ol> <p>一旦文档被提交，渲染进程便开始页面解析和子资源加载了。</p> <ul><li>服务器可以根据响应头来控制浏览器的行为，如跳转、网络数据类型判断。</li> <li>Chrome 默认采用每个标签对应一个渲染进程，但是如果两个页面属于同一站点，那这两个标签会使用同一个渲染进程。</li> <li>浏览器的导航过程涵盖了从用户发起请求到提交文档给渲染进程的中间所有阶段。</li></ul> <p>从输入 URL 到页面展示，这中间发生了什么 ？</p> <ol><li>用户输入url并回车</li> <li>浏览器进程检查url，组装协议，构成完整的url</li> <li>浏览器进程通过进程间通信（IPC）把url请求发送给网络进程</li> <li>网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程</li> <li>如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下：</li></ol> <ul><li>5.1 进行DNS解析，获取服务器ip地址，端口</li> <li>5.2 利用ip地址和服务器建立tcp连接</li> <li>5.3 构建请求头信息</li> <li>5.4 发送请求头信息</li> <li>5.5 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容</li></ul> <ol start="6"><li>网络进程解析响应流程；</li></ol> <ul><li>6.1 检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步,如果是200，则继续处理请求。</li> <li>6.2 200响应处理：
检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行
后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。</li></ul> <ol start="7"><li>准备渲染进程</li></ol> <ul><li>7.1 浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程</li></ul> <ol start="8"><li>传输数据、更新状态</li></ol> <ul><li>8.1 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”</li> <li>8.2 渲染进程接收完数据后，向浏览器发送“确认提交”</li> <li>8.3 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面。</li></ul> <h2 id="_5-渲染流程"><a href="#_5-渲染流程" class="header-anchor">#</a> 5. 渲染流程</h2> <p>由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线</p> <ul><li>按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成</li></ul> <h3 id="_5-1-构建-dom-树"><a href="#_5-1-构建-dom-树" class="header-anchor">#</a> 5.1 构建 DOM 树</h3> <p>这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。</p> <p>构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由 <code>HTML</code> 解析器解析，最终输出树状结构的<code>DOM</code>。</p> <h3 id="_5-2-样式计算-recalculate-style"><a href="#_5-2-样式计算-recalculate-style" class="header-anchor">#</a> 5.2 样式计算（Recalculate Style）</h3> <ol><li>把 CSS 转换为浏览器能够理解的结构
CSS 样式来源主要有三种：</li></ol> <ul><li>通过 link 引用的外部 CSS 文件</li> <li></li> <li>元素的 style 属性内嵌的 CSS</li></ul> <p>当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets(cssom树)。</p> <h3 id="_5-3-布局阶段"><a href="#_5-3-布局阶段" class="header-anchor">#</a> 5.3 布局阶段</h3> <p>Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。</p> <ul><li>创建布局树
<ul><li>遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；</li> <li>而不可见的节点会被布局树忽略掉</li></ul></li> <li>布局计算</li></ul> <h3 id="_5-4-分层"><a href="#_5-4-分层" class="header-anchor">#</a> 5.4 分层</h3> <p>渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）</p> <p>通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层</p> <p>渲染引擎为特定的节点创建新的图层:</p> <p>渲染引擎会为节点创建新的图层：</p> <ol><li>拥有层叠上下文属性的元素 层叠上下文属性：明确定位属性的元素，定义透明属性的元素，使 用css滤镜元素，设置z-index属性的元素</li> <li>需要裁剪的地方</li></ol> <h3 id="_5-5-图层绘制"><a href="#_5-5-图层绘制" class="header-anchor">#</a> 5.5 图层绘制</h3> <p>可以打开“开发者工具”的“Layers”标签，选择“document”层，来实际体验下绘制列表，如下图所示：</p> <p><img src="/images/js/layer.png" alt=""></p> <p>区域 1 就是 document 的绘制列表，拖动区域 2 中的进度条可以重现列表的绘制过程。</p> <h3 id="_5-6-栅格化-raster-操作"><a href="#_5-6-栅格化-raster-操作" class="header-anchor">#</a> 5.6 栅格化（raster）操作</h3> <p>绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。你可以结合下图来看下渲染主线程和合成线程之间的关系：
<img src="/images/js/raster.png" alt=""></p> <p>当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程</p> <p>在有些情况下，有的图层可以很大，比如有的页面要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要</p> <p>基于这个原因，合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512</p> <p><img src="/images/js/tile.png" alt=""></p> <ul><li>合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行。</li> <li>栅格化：指讲图块转化为位图；</li> <li>图块是栅格化的最小单位，渲染进程维护了一个栅格化线程池，所有的图块栅格化都是在栅格化线程池内执行；
<img src="/images/js/raster1.png" alt=""></li></ul> <p>栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。
<img src="/images/js/GPU_raster.png" alt=""></p> <h4 id="_5-7-合成和显示"><a href="#_5-7-合成和显示" class="header-anchor">#</a> 5.7 合成和显示</h4> <p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——<code>DrawQuad</code>，然后将该命令提交给浏览器进程。</p> <p>浏览器进程里面有一个叫 <code>viz</code> 的组件，用来接收合成线程发过来的 <code>DrawQuad</code> 命令，然后根据 <code>DrawQuad</code>命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p> <p>整体渲染：
<img src="/images/js/render_all.png" alt=""></p> <ul><li>渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。</li> <li>渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。</li> <li>创建布局树，并计算元素的布局信息。对布局树进行分层，并生成分层树。</li> <li>为每个图层生成绘制列表，并将其提交到合成线程。</li> <li>合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</li> <li>合成线程发送绘制图块命令 DrawQuad 给浏览器进程。</li> <li>浏览器进程根据 <code>DrawQuad</code> 消息生成页面，并显示到显示器上。</li></ul> <p>“重排”“重绘”和“合成”:</p> <p><strong>重排</strong>: 更新元素的几何属性,重排需要更新完整的渲染流水线
<strong>重绘</strong>: 更新元素的绘制属性,重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。
<strong>合成</strong>: CSS3 transform,避开重排和重绘阶段，直接在非主线程上执行合成动画操作,相对于重绘和重排，合成能大大提升绘制效率。</p> <p>减少重排重绘, 方法如下：</p> <ol><li>使用 class 操作样式，而不是频繁操作 style</li> <li>避免使用 table 布局</li> <li>批量dom 操作，例如 createDocumentFragment，或者使用框架，例如 React</li> <li>Debounce window resize 事件</li> <li>对 dom 属性的读写要分离</li> <li>will-change: transform 做优化</li></ol> <h2 id="_6-浏览器下的执行机制"><a href="#_6-浏览器下的执行机制" class="header-anchor">#</a> 6. 浏览器下的执行机制</h2> <h3 id="_6-1-变量提升"><a href="#_6-1-变量提升" class="header-anchor">#</a> 6.1 变量提升</h3> <ul><li><p>JavaScript 代码的执行流程</p></li> <li><p>1.编译阶段： JS代码在正式执行前会先进行编译，在此过程中会生成执行上下文和可执行代码。所谓执行上下文就是一段JS代码的执行环境。在执行上下文中会创建一个变量环境对象，JS引擎在遇到var声明的变量或者function声明的函数时，会在该环境对象中创建一个与变量或函数同名的属性保存undefined或函数在堆中的地址。其他声明以外的代码，JS引擎会将其编译为字节码。（对于let声明的变量保存在执行上下文的词法环境中） 。
函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量赋值之后覆盖。</p></li> <li><p>2.执行阶段： 按照顺序一行一行的执行可执行代码，遇到变量或者函数，会去变量环境对象中去查找，当执行过程中遇到变量赋值则会将结果更新到环境对象中。</p></li></ul> <h3 id="_6-2-调用栈"><a href="#_6-2-调用栈" class="header-anchor">#</a> 6.2 调用栈</h3> <ul><li>每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码。</li> <li>如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。</li> <li>当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。</li> <li>当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。</li></ul> <h2 id="_7-页面循环系统"><a href="#_7-页面循环系统" class="header-anchor">#</a> 7. 页面循环系统</h2> <h3 id="_7-1-消息队列和事件循环"><a href="#_7-1-消息队列和事件循环" class="header-anchor">#</a> 7.1 消息队列和事件循环</h3> <ul><li><ol><li>第一版线程模型</li></ol></li></ul> <p>如果有一些确定好的任务，可以使用一个单线程来按照顺序处理这些任务</p> <ul><li><ol start="2"><li>第二版线程模型
在线程中引入事件循环</li></ol></li></ul> <p><img src="/images/js/eventLoop.png" alt=""></p> <p>处理其他线程发送过来的任务</p> <p><img src="/images/js/eventLoop2.png" alt=""></p> <p>渲染主线程会频繁接收到来自于 <code>IO</code> 线程的一些任务，接收到这些任务之后，渲染进程就需要着手处理，比如接收到资源加载完成的消息后，渲染进程就要着手进行 DOM 解析了；接收到鼠标点击的消息后，渲染主线程就要开始执行相应的 JavaScript 脚本来处理该点击事件。</p> <ul><li><ol start="3"><li>第三版线程模型</li></ol> <p>消息队列:</p></li></ul> <p><img src="/images/js/messageQueue.png" alt=""></p> <p>队列+线程模型：</p> <p><img src="/images/js/eventLoop3.png" alt=""></p> <ol><li>添加一个消息队列；</li> <li>IO 线程中产生的新任务添加进消息队列尾部；</li> <li>渲染主线程会循环地从消息队列头部中读取任务，执行任务。</li></ol> <p>单一主进程多个子进程操作同一个消息队列在I/O任务时候需要加上同步锁避免出错。</p> <ul><li>跨进程之间的任务
<img src="/images/js/eventLoop4.png" alt=""></li></ul> <p>渲染进程专门有一个 <code>IO</code> 线程用来接收其他进程传进来的消息，接收到消息之后，会将这些消息组装成任务发送给渲染主线程。</p> <ul><li>消息队列中的任务类型</li></ul> <p>有很多内部消息类型，如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。
除此之外，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。</p> <p>以上这些事件都是在主线程中执行的，所以在编写 Web 应用时，还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题。</p> <h3 id="_7-2-settimeout实现原理"><a href="#_7-2-settimeout实现原理" class="header-anchor">#</a> 7.2 setTimeout实现原理</h3> <p><strong>浏览器页面是由消息队列和事件循环系统来驱动的。</strong></p> <h4 id="浏览器怎么实现-settimeout"><a href="#浏览器怎么实现-settimeout" class="header-anchor">#</a> 浏览器怎么实现 setTimeout</h4> <p>渲染进程中所有运行在主线程上的任务都需要先添加到消息队列，然后事件循环系统再按照顺序执行消息队列中的任务。</p> <p>要执行一段异步任务，需要先将任务添加到消息队列中。不过通过定时器设置回调函数有点特别，它们需要在指定的时间间隔内被调用，但消息队列中的任务是按照顺序执行的，所以为了保证回调函数能在指定时间内执行，不能将定时器的回调函数直接添加到消息队列中。</p> <p>在 Chrome 中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。所以当通过 JavaScript 创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中。</p> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token keyword">void</span> <span class="token function">ProcessTimerTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">//从delayed_incoming_queue中取出已经到期的定时器任务</span>
  <span class="token comment">//依次执行这些任务</span>
<span class="token punctuation">}</span>

TaskQueue task_queue；
<span class="token keyword">void</span> <span class="token function">ProcessTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
bool keep_running <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">MainTherad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//执行消息队列中的任务</span>
    Task task <span class="token operator">=</span> task_queue<span class="token punctuation">.</span><span class="token function">takeTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ProcessTask</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">//执行延迟队列中的任务</span>
    <span class="token function">ProcessDelayTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>keep_running<span class="token punctuation">)</span> <span class="token comment">//如果设置了退出标志，那么直接退出线程循环</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span> 
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>执行时机：处理完消息队列中的一个任务之后，就开始执行 <code>ProcessDelayTask</code> 函数。<code>ProcessDelayTask</code> 函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。等到期的任务执行完成之后，再继续下一个循环过程。通过这样的方式，一个完整的定时器就实现了。</p> <p>setTimeout 注意事项：</p> <ol><li>如果当前任务执行时间过久，会影响定时器任务的执行</li> <li>如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token keyword">function</span> <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>cb<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span>cb<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ol start="3"><li>未激活的页面，setTimeout 执行最小间隔是 1000 毫秒</li> <li>延时执行时间有最大值</li></ol> <p>Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被立即执行。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;极客时间&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> timerID <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>showName<span class="token punctuation">,</span><span class="token number">2147483648</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//会被理解调用执行</span>
</code></pre></div><h3 id="_7-3-xmlhttprequest实现原理"><a href="#_7-3-xmlhttprequest实现原理" class="header-anchor">#</a> 7.3 XMLHttpRequest实现原理</h3> <h4 id="回调函数-vs-系统调用栈"><a href="#回调函数-vs-系统调用栈" class="header-anchor">#</a> 回调函数 VS 系统调用栈</h4> <p>将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是回调函数。</p> <p>回调函数 callback 是在主函数 doWork 返回之前执行的，我们把这个回调过程称为<code>同步回调</code>。</p> <p>回调函数在主函数外部执行的过程称为<code>异步回调</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">callback</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'i am do homework'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token parameter">cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'start do work'</span><span class="token punctuation">)</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span>cb<span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>   
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'end do work'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">doWork</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span>
</code></pre></div><p>浏览器页面是通过事件循环机制来驱动的，每个渲染进程都有一个消息队列，页面主线程按照顺序来执行消息队列中的事件，如执行 JavaScript 事件、解析 DOM 事件、计算布局事件、用户输入事件等等，如果页面有新的事件产生，那新的事件将会追加到事件队列的尾部。所以消息队列和主线程循环机制保证了页面有条不紊地运行。</p> <p>当循环系统在执行一个任务的时候，都要为这个任务维护一个<code>系统调用栈</code>。这个系统调用栈类似于 JavaScript 的调用栈。每次执行一个任务，这个栈就会重新创建。</p> <ul><li>消息循环系统调用栈记录
<img src="/images/js/%E6%B6%88%E6%81%AF%E5%BE%AA%E7%8E%AF%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%A0%88%E8%AE%B0%E5%BD%95.png" alt="">
这幅图记录了一个 <code>Parse HTML</code> 的任务执行过程，其中黄色的条目表示执行 JavaScript 的过程，其他颜色的条目表示浏览器内部系统的执行过程。</li></ul> <p>Parse HTML 任务在执行过程中会遇到一系列的子过程，比如在解析页面的过程中遇到了 JavaScript 脚本，那么就暂停解析过程去执行该脚本，等执行完成之后，再恢复解析过程。然后又遇到了样式表，这时候又开始解析样式表……直到整个任务执行完成。</p> <p>异步回调是指回调函数在主函数之外执行，一般有两种方式：
第一种是把异步函数做成一个任务，添加到信息队列尾部；
第二种是把异步函数添加到微任务队列中，这样就可以在当前任务的末尾处执行微任务了。</p> <h5 id="xmlhttprequest-运作机制"><a href="#xmlhttprequest-运作机制" class="header-anchor">#</a> XMLHttpRequest 运作机制</h5> <p><img src="/images/js/XMLHttpRequest.png" alt=""></p> <div class="language-js extra-class"><pre class="language-js"><code>
 <span class="token keyword">function</span> <span class="token function">GetWebData</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">URL</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">/**
     * 1:新建XMLHttpRequest请求对象
     */</span>
    <span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">/**
     * 2:注册相关事件回调处理函数 
     */</span>
    xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">switch</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState<span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span> <span class="token comment">//请求未初始化</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;请求未初始化&quot;</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token constant">OPENED</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;OPENED&quot;</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token constant">HEADERS_RECEIVED</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;HEADERS_RECEIVED&quot;</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token constant">LOADING</span>  
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;LOADING&quot;</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token keyword">case</span> <span class="token number">4</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token constant">DONE</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">200</span><span class="token operator">||</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">304</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;DONE&quot;</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    xhr<span class="token punctuation">.</span><span class="token function-variable function">ontimeout</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'ontimeout'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    xhr<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'onerror'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 3:打开请求
     */</span>
    xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'Get'</span><span class="token punctuation">,</span> <span class="token constant">URL</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建一个Get请求,采用异步</span>


    <span class="token comment">/**
     * 4:配置参数
     */</span>
    xhr<span class="token punctuation">.</span>timeout <span class="token operator">=</span> <span class="token number">3000</span> <span class="token comment">//设置xhr请求的超时时间</span>
    xhr<span class="token punctuation">.</span>responseType <span class="token operator">=</span> <span class="token string">&quot;text&quot;</span> <span class="token comment">//设置响应返回的数据格式</span>
    xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">&quot;X_TEST&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;time.geekbang&quot;</span><span class="token punctuation">)</span>

    <span class="token comment">/**
     * 5:发送请求
     */</span>
    xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol><li>创建 <code>XMLHttpRequest</code> 对象。当执行到let xhr = new XMLHttpRequest()后，JavaScript 会创建一个 XMLHttpRequest 对象 xhr，用来执行实际的网络请求操作。</li> <li>为 xhr 对象注册回调函数。
因为网络请求比较耗时，所以要注册回调函数，这样后台任务执行完成之后就会通过调用回调函数来告诉其执行结果。</li> <li>配置基础的请求信息。</li> <li>发起请求。</li></ol> <p>渲染进程会将请求发送给网络进程，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用 <code>IPC</code>来通知渲染进程；
渲染进程接收到消息之后，会将<code>xhr</code>的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数。</p> <h3 id="_7-4-宏任务和微任务"><a href="#_7-4-宏任务和微任务" class="header-anchor">#</a> 7.4 宏任务和微任务</h3> <h4 id="宏任务"><a href="#宏任务" class="header-anchor">#</a> 宏任务</h4> <ul><li>渲染事件（如解析 DOM、计算布局、绘制）；</li> <li>用户交互事件（如鼠标点击、滚动页面、放大缩小等）；</li> <li>JavaScript 脚本执行事件；</li> <li>网络请求完成、文件读写完成事件。</li></ul> <p>为了协调这些任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个 for 循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为宏任务。</p> <h5 id="事件循环机制"><a href="#事件循环机制" class="header-anchor">#</a> 事件循环机制</h5> <ul><li>先从多个消息队列中选出一个最老的任务，这个任务称为 oldestTask；</li> <li>然后循环系统记录任务开始执行的时间，并把这个 oldestTask 设置为当前正在执行的任务；</li> <li>当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个 oldestTask；</li> <li>最后统计执行完成的时长等信息。</li></ul> <h4 id="微任务"><a href="#微任务" class="header-anchor">#</a> 微任务</h4> <p>当 JavaScript 执行一段脚本的时候：</p> <ol><li>渲染主线程执JS脚本</li> <li>JS脚本的执行是一个宏任务</li> <li>宏任务中存在微任务队列</li></ol> <h4 id="微任务产生的时机和执行微任务队列的时机"><a href="#微任务产生的时机和执行微任务队列的时机" class="header-anchor">#</a> 微任务产生的时机和执行微任务队列的时机</h4> <p>产生微任务有两种方式:</p> <ul><li>MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。</li> <li>使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。</li></ul> <p>通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。</p> <p>如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。</p> <div class="custom-block tip"><p class="custom-block-title">宏任务和微任务之间的关系</p> <p>因为在微任务中产生的宏任务也是要插入到消息队列或者是延迟队列的末尾的，这肯定是需要下一次事件循环才有可能被执行的，而微任务在这一次的事件循环之前就会被执行</p></div> <h3 id="_7-5-async-await"><a href="#_7-5-async-await" class="header-anchor">#</a> 7.5 async/await</h3> <h4 id="生成器-vs-协程"><a href="#生成器-vs-协程" class="header-anchor">#</a> 生成器 VS 协程</h4> <p>生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的。</p> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">genDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;开始执行第一段&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">yield</span> <span class="token string">'generator 2'</span>

    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;开始执行第二段&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">yield</span> <span class="token string">'generator 2'</span>

    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;开始执行第三段&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">yield</span> <span class="token string">'generator 2'</span>

    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;执行结束&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token string">'generator 2'</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'main 0'</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> gen <span class="token operator">=</span> <span class="token function">genDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'main 1'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'main 2'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'main 3'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'main 4'</span><span class="token punctuation">)</span>
</code></pre></div><p>函数 genDemo 并不是一次执行完的，全局代码和 genDemo 函数交替执行。其实这就是生成器函数的特性，可以<code>暂停执行</code>，也可以<code>恢复执行</code>。</p> <p>在生成器函数内部执行一段代码，如果遇到 yield 关键字，那么 JavaScript 引擎将返回关键字后面的内容给外部，并暂停该函数的执行。外部函数可以通过 <code>next</code> 方法恢复函数的执行。</p> <p>协程是一种比线程更加轻量级的存在。可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程，比如当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。</p> <p><img src="/images/js/gen.png" alt=""></p> <ul><li>通过调用生成器函数 genDemo 来创建一个协程 gen，创建之后，gen 协程并没有立即执行。</li> <li>要让 gen 协程执行，需要通过调用 gen.next。</li> <li>当协程正在执行的时候，可以通过 yield 关键字来暂停 gen 协程的执行，并返回主要信息给父协程。</li> <li>如果协程在执行期间，遇到了 return 关键字，那么 JavaScript 引擎会结束当前协程，并将 return 后面的内容返回给父协程。</li></ul> <div class="custom-block tip"><p class="custom-block-title">提示</p> <ol><li><p>gen 协程和父协程是在主线程上交互执行的，并不是并发执行的，它们之前的切换是通过 yield 和 gen.next 来配合完成的。</p></li> <li><p>当在 gen 协程中调用了 yield 方法时，JavaScript 引擎会保存 gen 协程当前的调用栈信息，并恢复父协程的调用栈信息。同样，当在父协程中执行 gen.next 时，JavaScript 引擎会保存父协程的调用栈信息，并恢复 gen 协程的调用栈信息。</p></li></ol></div> <h4 id="async-await"><a href="#async-await" class="header-anchor">#</a> async/await</h4> <ol><li>async
async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">2</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// Promise {&lt;resolved&gt;: 2}</span>
</code></pre></div><ol start="2"><li>await</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token number">100</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
</code></pre></div><p>async/await 执行流程图:</p> <p><img src="/images/js/async-await.png" alt=""></p> <ul><li><p>首选： 执行console.log(0)这个语句，打印出来 0。</p></li> <li><p>接着就是执行 foo 函数，由于 foo 函数是被 async 标记过的，所以当进入该函数的时候，JavaScript 引擎会保存当前的调用栈等信息，然后执行 foo 函数中的console.log(1)语句，并打印出 1。</p></li> <li><p>然后就执行到 foo 函数中的await 100这个语句了。当执行到await 100时，会默认创建一个 Promise 对象，</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token keyword">let</span> promise_ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>在这个 promise_ 对象创建的过程中，JavaScript 引擎会将该任务提交给微任务队列。</p> <p>然后 <code>JavaScript</code> 引擎会暂停当前<code>协程</code>的执行，将主线程的控制权转交给<code>父协程</code>执行，同时会将 <code>promise_</code> 对象返回给父协程。</p> <p>主线程的控制权已经交给父协程了，这时候父协程要做的一件事是调用 <code>promise_.then</code> 来监控 <code>promise</code> 状态的改变。</p> <p>接下来继续执行父协程的流程，这里执行<code>console.log(3)</code>，并打印出来</p> <p>随后父协程将执行结束，在结束之前，会进入微任务的检查点，然后执行微任务队列，微任务队列中有<code>resolve(100)</code>的任务等待执行，执行到这里的时候，会触发 <code>promise_.then</code> 中的回调函数</p> <div class="language-js extra-class"><pre class="language-js"><code>
promise_<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
   <span class="token comment">//回调函数被激活后</span>
  <span class="token comment">//将主线程控制权交给foo协程，并将vaule值传给协程</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>该回调函数被激活以后，会将主线程的控制权交给 <code>foo</code> 函数的协程，并同时将 <code>value</code> 值传给该协程。</p> <p><code>foo</code> 协程激活之后，会把刚才的 <code>value</code> 值赋给了变量 a，然后 foo 协程继续执行后续语句，执行完成之后，将控制权归还给父协程。</p></div></div> <!----> <div class="page-edit"><!----> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/b26575/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">浏览器概述</div></a> <a href="/pages/4bb833/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">v8引擎</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/b26575/" class="prev">浏览器概述</a></span> <span class="next"><a href="/pages/4bb833/">v8引擎</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/54d1ec/"><div>
            打包原理
            <!----></div></a> <span class="date">05-30</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/dc2646/"><div>
            构建速度和体积优化
            <!----></div></a> <span class="date">05-29</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/d74c8e/"><div>
            打包组件和基础库
            <!----></div></a> <span class="date">05-29</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:1730129114@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/wshuhua" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/my/m/music/playlist?id=7141103351" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2022-2022
    <span>Wsh  | <a href="https://github.com/wshuhua" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.abd80959.js" defer></script><script src="/assets/js/2.dc8a2400.js" defer></script><script src="/assets/js/49.4fd36a66.js" defer></script>
  </body>
</html>
