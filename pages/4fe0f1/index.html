<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>内存控制 | Wsh&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/images/logo.png">
    <meta name="description" content="web前端技术博客,专注web前端学习与总结。JavaScript,js,ES6,TypeScript,vue,React,python,css3,html5,Node,git,github等技术文章。">
    
    <link rel="preload" href="/assets/css/0.styles.bc63fb2f.css" as="style"><link rel="preload" href="/assets/js/app.1c80f441.js" as="script"><link rel="preload" href="/assets/js/2.dc8a2400.js" as="script"><link rel="preload" href="/assets/js/29.a96448c6.js" as="script"><link rel="prefetch" href="/assets/js/10.57255fdd.js"><link rel="prefetch" href="/assets/js/11.9356ed36.js"><link rel="prefetch" href="/assets/js/12.3ad835bb.js"><link rel="prefetch" href="/assets/js/13.7c8ea0da.js"><link rel="prefetch" href="/assets/js/14.1380d324.js"><link rel="prefetch" href="/assets/js/15.b6956ee1.js"><link rel="prefetch" href="/assets/js/16.8f6a30d6.js"><link rel="prefetch" href="/assets/js/17.5612ad75.js"><link rel="prefetch" href="/assets/js/18.ac170b7c.js"><link rel="prefetch" href="/assets/js/19.7c7f3690.js"><link rel="prefetch" href="/assets/js/20.699f5758.js"><link rel="prefetch" href="/assets/js/21.77977f4f.js"><link rel="prefetch" href="/assets/js/22.342bf844.js"><link rel="prefetch" href="/assets/js/23.95dae306.js"><link rel="prefetch" href="/assets/js/24.5568dd6d.js"><link rel="prefetch" href="/assets/js/25.c41a6580.js"><link rel="prefetch" href="/assets/js/26.63382b0b.js"><link rel="prefetch" href="/assets/js/27.9d4203cc.js"><link rel="prefetch" href="/assets/js/28.c082e439.js"><link rel="prefetch" href="/assets/js/3.81312ee3.js"><link rel="prefetch" href="/assets/js/30.17f62e20.js"><link rel="prefetch" href="/assets/js/31.66c21430.js"><link rel="prefetch" href="/assets/js/32.515aab89.js"><link rel="prefetch" href="/assets/js/33.f39584f5.js"><link rel="prefetch" href="/assets/js/34.eeaa6001.js"><link rel="prefetch" href="/assets/js/35.c915dec5.js"><link rel="prefetch" href="/assets/js/36.906ff609.js"><link rel="prefetch" href="/assets/js/37.af997daa.js"><link rel="prefetch" href="/assets/js/38.58e38c72.js"><link rel="prefetch" href="/assets/js/39.2fb6607a.js"><link rel="prefetch" href="/assets/js/4.c704e751.js"><link rel="prefetch" href="/assets/js/40.fd291033.js"><link rel="prefetch" href="/assets/js/41.757263ff.js"><link rel="prefetch" href="/assets/js/42.27aef523.js"><link rel="prefetch" href="/assets/js/43.701d1cb6.js"><link rel="prefetch" href="/assets/js/44.03138205.js"><link rel="prefetch" href="/assets/js/45.dc1f978e.js"><link rel="prefetch" href="/assets/js/46.1905c7db.js"><link rel="prefetch" href="/assets/js/47.b5964080.js"><link rel="prefetch" href="/assets/js/48.a441d1b6.js"><link rel="prefetch" href="/assets/js/49.a9238394.js"><link rel="prefetch" href="/assets/js/5.2db75e05.js"><link rel="prefetch" href="/assets/js/50.6f2278bb.js"><link rel="prefetch" href="/assets/js/51.696b743e.js"><link rel="prefetch" href="/assets/js/52.cb5a5cfb.js"><link rel="prefetch" href="/assets/js/53.142fe0b6.js"><link rel="prefetch" href="/assets/js/54.64b5e305.js"><link rel="prefetch" href="/assets/js/55.84c16fee.js"><link rel="prefetch" href="/assets/js/56.bff4129c.js"><link rel="prefetch" href="/assets/js/57.f78352c2.js"><link rel="prefetch" href="/assets/js/58.2b95d0cf.js"><link rel="prefetch" href="/assets/js/59.f5e8f3ca.js"><link rel="prefetch" href="/assets/js/6.9073f8bb.js"><link rel="prefetch" href="/assets/js/60.33f2c7e7.js"><link rel="prefetch" href="/assets/js/61.89f06a7a.js"><link rel="prefetch" href="/assets/js/62.8c20bcf9.js"><link rel="prefetch" href="/assets/js/63.ccdd8c78.js"><link rel="prefetch" href="/assets/js/64.3a985679.js"><link rel="prefetch" href="/assets/js/65.d129cacf.js"><link rel="prefetch" href="/assets/js/66.3cb45d28.js"><link rel="prefetch" href="/assets/js/67.a1c6a016.js"><link rel="prefetch" href="/assets/js/68.62d560f2.js"><link rel="prefetch" href="/assets/js/69.e3fddf31.js"><link rel="prefetch" href="/assets/js/7.733f78a6.js"><link rel="prefetch" href="/assets/js/70.c233638a.js"><link rel="prefetch" href="/assets/js/71.cc057214.js"><link rel="prefetch" href="/assets/js/72.b37c39f9.js"><link rel="prefetch" href="/assets/js/73.03f9ceb9.js"><link rel="prefetch" href="/assets/js/74.ac2174bc.js"><link rel="prefetch" href="/assets/js/75.393c0e48.js"><link rel="prefetch" href="/assets/js/76.dedded4f.js"><link rel="prefetch" href="/assets/js/77.94ba6b26.js"><link rel="prefetch" href="/assets/js/78.a13524be.js"><link rel="prefetch" href="/assets/js/79.e69e51e9.js"><link rel="prefetch" href="/assets/js/8.77d48f5d.js"><link rel="prefetch" href="/assets/js/9.84cabc87.js">
    <link rel="stylesheet" href="/assets/css/0.styles.bc63fb2f.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/images/1.gif" alt="Wsh's blog" class="logo"> <span class="site-name can-hide">Wsh's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="知识👖" class="dropdown-title"><a href="/note/" class="link-title">知识👖</a> <span class="title" style="display:none;">知识👖</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/cache/" class="nav-link">《前端缓存》</a></li><li class="dropdown-item"><!----> <a href="/note/react/" class="nav-link">《React》</a></li><li class="dropdown-item"><!----> <a href="/note/typescript/" class="nav-link">《typescript》</a></li><li class="dropdown-item"><!----> <a href="/note/javascript/" class="nav-link">《javascript》</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工程🌹" class="dropdown-title"><a href="/tool/" class="link-title">工程🌹</a> <span class="title" style="display:none;">工程🌹</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/tool/node/" class="nav-link">node</a></li><li class="dropdown-item"><!----> <a href="/tool/webpack/" class="nav-link">webpack</a></li></ul></div></div><div class="nav-item"><a href="/note/algorithm/" class="nav-link">轻松一刻😉</a></div><div class="nav-item"><a href="/pages/ca0c25/" class="nav-link">宝库📰</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引🔒" class="dropdown-title"><a href="/archives/" class="link-title">索引🔒</a> <span class="title" style="display:none;">索引🔒</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div><div class="nav-item"><a href="https://blog.fudenglong.site" target="_blank" rel="noopener noreferrer" class="nav-link external">
  龙哥的大🐂之路
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/wshuhua" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/images/avatar.gif"> <div class="blogger-info"><h3>wsh</h3> <span>热爱前端的程序媛</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="知识👖" class="dropdown-title"><a href="/note/" class="link-title">知识👖</a> <span class="title" style="display:none;">知识👖</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/cache/" class="nav-link">《前端缓存》</a></li><li class="dropdown-item"><!----> <a href="/note/react/" class="nav-link">《React》</a></li><li class="dropdown-item"><!----> <a href="/note/typescript/" class="nav-link">《typescript》</a></li><li class="dropdown-item"><!----> <a href="/note/javascript/" class="nav-link">《javascript》</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工程🌹" class="dropdown-title"><a href="/tool/" class="link-title">工程🌹</a> <span class="title" style="display:none;">工程🌹</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/tool/node/" class="nav-link">node</a></li><li class="dropdown-item"><!----> <a href="/tool/webpack/" class="nav-link">webpack</a></li></ul></div></div><div class="nav-item"><a href="/note/algorithm/" class="nav-link">轻松一刻😉</a></div><div class="nav-item"><a href="/pages/ca0c25/" class="nav-link">宝库📰</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引🔒" class="dropdown-title"><a href="/archives/" class="link-title">索引🔒</a> <span class="title" style="display:none;">索引🔒</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div><div class="nav-item"><a href="https://blog.fudenglong.site" target="_blank" rel="noopener noreferrer" class="nav-link external">
  龙哥的大🐂之路
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/wshuhua" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span> 深入浅出node</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/2586cb/" class="sidebar-link">node介绍</a></li><li><a href="/pages/5d2c54/" class="sidebar-link">模块机制</a></li><li><a href="/pages/1b14a3/" class="sidebar-link">异步I/O操作</a></li><li><a href="/pages/ec8dfa/" class="sidebar-link">异步编程</a></li><li><a href="/pages/4fe0f1/" aria-current="page" class="active sidebar-link">内存控制</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/84c133/" class="sidebar-link">理解Buffer</a></li><li><a href="/pages/5d721b/" class="sidebar-link">网络编程</a></li><li><a href="/pages/a95428/" class="sidebar-link">进程</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span> nest框架</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>koa</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper bg-style-6"><div class="articleInfo-wrap" data-v-0c557b5e><div class="articleInfo" data-v-0c557b5e><ul class="breadcrumbs" data-v-0c557b5e><li data-v-0c557b5e><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-0c557b5e></a></li> <li data-v-0c557b5e><a href="/tool/node/#node" data-v-0c557b5e>node</a></li><li data-v-0c557b5e><a href="/tool/node/# 深入浅出node" data-v-0c557b5e> 深入浅出node</a></li></ul> <div class="info" data-v-0c557b5e><!----> <div title="创建时间" class="date iconfont icon-riqi" data-v-0c557b5e><a href="javascript:;" data-v-0c557b5e>2022-05-03</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">内存控制<!----></h1> <!----> <div class="theme-vdoing-content content__default"><p>内存控制正是在海量请求和长时间运行的前提下进行探讨的。在服务器端，资源向来就寸土寸金，要为海量用户服务，就得使一切资源都要高效循环利用。</p> <h3 id="_01-v8-的垃圾回收机制与内存限制"><a href="#_01-v8-的垃圾回收机制与内存限制" class="header-anchor">#</a> 01. V8 的垃圾回收机制与内存限制</h3> <p>JavaScript由垃圾回收机制来进行自动内存管理，</p> <h4 id="v8-的内存限制"><a href="#v8-的内存限制" class="header-anchor">#</a> V8 的内存限制</h4> <p>在Node中通过JavaScript使用内存时就会发现只能使用部分内存（64位系统下约为1.4 GB，32位系统下约为0.7 GB）。
造成这个问题的主要原因在于Node基于V8构建，所以在Node中使用的JavaScript对象基本上都是通过V8自己的方式来进行分配和管理的。V8的这套内存管理机制在浏览器的应用场景下使用起来绰绰有余，足以胜任前端页面中的所有需求。但在Node中，这却限制了开发者随心所欲使用大内存的想法.</p> <h4 id="v8-的对象分配"><a href="#v8-的对象分配" class="header-anchor">#</a> V8 的对象分配</h4> <p>在V8中，所有的JavaScript对象都是通过堆来进行分配的。Node提供了V8中内存使用量的查看方式，执行下面的代码，将得到输出的内存信息</p> <div class="language- extra-class"><pre class="language-text"><code>wsh@wsh ~ %  node
&gt; process.memoryUsage();
{
  rss: 99205120,
  heapTotal: 6049792,
  heapUsed: 4121312,
  external: 1682060,
  arrayBuffers: 9965
}
&gt;
</code></pre></div><p>当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的堆空闲内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过V8的限制为止。</p> <p>V8为何要限制堆的大小?</p> <ul><li>表层原因: 为V8最初为浏览器而设计，不太可能遇到用大量内存的场景</li> <li>深层原因是V8的垃圾回收机制的限制。按官方的说法，以1.5 GB的垃圾回收堆内存为例，V8做一次小的垃圾回收需要50毫秒以上，做一次非增量式的垃圾回收甚至要1秒以上。这是垃圾回收中引起JavaScript线程暂停执行的时间，在这样的时间花销下，应用的性能和响应能力都会直线下降。这样的情况不仅仅后端服务无法接受，前端浏览器也无法接受。因此，在当时的考虑下直接限制堆内存是一个好的选择。</li></ul> <p>调整内存限制的大小</p> <div class="language- extra-class"><pre class="language-text"><code>node --max-old-space-size=1700 test.js // 单位为MB
// 或者
node --max-new-space-size=1024 test.js // 单位为KB
</code></pre></div><h4 id="v8-的垃圾回收机制"><a href="#v8-的垃圾回收机制" class="header-anchor">#</a> V8 的垃圾回收机制</h4> <h5 id="v8主要的垃圾回收算法"><a href="#v8主要的垃圾回收算法" class="header-anchor">#</a> V8主要的垃圾回收算法</h5> <p>V8的垃圾回收策略主要基于分代式垃圾回收机制。</p> <ul><li>V8的内存分代
在V8中，主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。</li></ul> <p>V8的分代示意图：
<img src="/images/node/V8%E7%9A%84%E5%88%86%E4%BB%A3%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p> <p>V8堆的整体大小就是新生代所用内存空间加上老生代的内存空间</p> <ul><li>--max-old-space-size命令行参数可以用于设置老生代内存空间的最大值，</li> <li>--max-new-space-size命令行参数则用于设置新生代内存空间的大小</li></ul> <h6 id="新生代内存"><a href="#新生代内存" class="header-anchor">#</a> 新生代内存</h6> <p>对于新生代内存，它由两个reserved_semispace_size_所构成。按机器位数不同，reserved_semispace_size_在64位系统和32位系统上分别为16 MB和8 MB。所以新生代内存的最大值在64位系统和32位系统上分别为32 MB和16 MB。</p> <p>V8堆内存的最大保留空间可以从下面的代码中看出来，其公式为4 * reserved_semispace_size_ + max_old_generation_size_。
因此，默认情况下，V8堆内存的最大值在64位系统上为1464 MB，32位系统上则为732 MB。这个数值可以解释为何在64位系统下只能使用约1.4 GB内存和在32位系统下只能使用约0.7 GB内存。</p> <ul><li>Scavenge算法
在分代的基础上，新生代中的对象主要通过Scavenge算法进行垃圾回收。在Scavenge的具体实现中，主要采用了<code>Cheney算法</code>.
Cheney算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间称为semispace.</li></ul> <p>在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间。当我们分配对象时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查<code>From空间中的存活对象</code>，这
些存活对象将被复制到<code>To空间</code>中，而非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。简而言之，在垃圾回收的过程中，就是通过将存活对象在两个semispace空间之间进行复制。</p> <p>V8的堆内存示意图
<img src="/images/node/V8%E7%9A%84%E5%A0%86%E5%86%85%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p> <p>Scavenge的缺点是只能使用堆内存中的一半，这是由划分空间和复制机制所决定的。但Scavenge由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的表现。适合应用在新生代中，因为新生代中对象的生命周期较短，恰恰
适合这个算法</p> <p><code>晋升</code>: 当一个对象经过多次复制依然存活时，它将会被认为是生命周期较长的对象。这种较长生命周期的对象随后会被移动到老生代中，采用新的算法进行管理。对象从新生代中移动到老生代中的过程称为晋升。</p> <p>在分代式垃圾回收的前提下，From空间中的存活对象在复制到To空间之前需要进行检查。在一定条件下，需要将存活周期长的对象移动到老生代中，也就是完成对象晋升.
对象晋升的条件主要有两个:</p> <ol><li>一个是对象是否经历过Scavenge回收</li></ol> <p>晋升流程:
<img src="/images/node/%E6%99%8B%E5%8D%87%E6%B5%81%E7%A8%8B.png" alt="">
2. 一个是To空间的内存占用比超过限制。</p> <p>晋升的判断示意图
<img src="/images/node/%E6%99%8B%E5%8D%87%E7%9A%84%E5%88%A4%E6%96%AD%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p> <p>设置25%这个限制值的原因是当这次Scavenge回收完成后，这个To空间将变成From空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配.</p> <h5 id="老生代内存-mark-sweep-标记清除-mark-compact-标记整理"><a href="#老生代内存-mark-sweep-标记清除-mark-compact-标记整理" class="header-anchor">#</a> 老生代内存 (Mark-Sweep(标记清除) &amp; Mark-Compact(标记整理))</h5> <p>Mark-Sweep是标记清除的意思，它分为标记和清除两个阶段
Mark-Sweep在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。
Scavenge中只复制活着的对象，而Mark-Sweep只清理死亡对象。活对象在新生代中只占较小部分，死对象在老生代中只占较小部分。
Mark-Sweep在老生代空间中标记后的示意图：黑色部分标记为死亡的对象
<img src="/images/node/Mark-Sweep%E5%9C%A8%E8%80%81%E7%94%9F%E4%BB%A3%E7%A9%BA%E9%97%B4%E4%B8%AD%E6%A0%87%E8%AE%B0%E5%90%8E%E7%9A%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p> <p>Mark-Sweep最大的问题是在进行一次标记清除回收后，<code>内存空间会出现不连续的状态</code>。这种内存碎片会对后续的内存分配造成问题，因为很可能出现需要分配一个大对象的情况，这时所有的<code>碎片空间</code>都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。
Mark-Compact: 在Mark-Sweep的基础上演变而来的。是为了解决Mark-Sweep的内存碎片问题。它们的差别在于对象在标记为死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。白色格子为存活对象，深色格子为死亡对象，浅色格子为存活对象移动后留下的空洞。</p> <p>完成移动后，就可以直接清除最右边的存活对象后面的内存区域完成回收。</p> <p>完成标记并移动存活对象后的示意图:
<img src="/images/node/Mark-Compact%E5%AE%8C%E6%88%90%E6%A0%87%E8%AE%B0%E5%B9%B6%E7%A7%BB%E5%8A%A8%E5%AD%98%E6%B4%BB%E5%AF%B9%E8%B1%A1%E5%90%8E%E7%9A%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p> <p>3种垃圾回收算法的简单对比：
<img src="/images/node/3%E7%A7%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E7%9A%84%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94.png" alt=""></p> <p>从表中可以看到，在Mark-Sweep和Mark-Compact之间，由于Mark-Compact需要移动对象，所以它的执行速度不可能很快，所以在取舍上，V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时才使用Mark-Compact。</p> <h4 id="增量标记"><a href="#增量标记" class="header-anchor">#</a> 增量标记</h4> <p>为了避免出现JavaScript应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为<code>全停顿</code>。
在V8的分代式垃圾回收中，一次小垃圾回收只收集新生代，由于新生代默认配置得较小，且其中存活对象通常较少，所以即便它是全停顿的影响也不大。</p> <p>但V8的老生代通常配置得较大，且存活对象较多，全堆垃圾回收（full 垃圾回收）的标记、清理、整理等
动作造成的停顿就会比较可怕，需要设法改善。</p> <p><code>增量标记</code>: 为了降低全堆垃圾回收带来的停顿时间,V8先从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记。
也就是拆分为许多小“步进”，每做完一“步进”就让JavaScript应用逻辑执行一小会儿，垃圾回收与应用逻辑交替执行直到标记阶段完成。</p> <p><img src="/images/node/%E5%A2%9E%E9%87%8F%E6%A0%87%E8%AE%B0%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p> <h4 id="查看垃圾回收日志"><a href="#查看垃圾回收日志" class="header-anchor">#</a> 查看垃圾回收日志</h4> <p>查看垃圾回收日志的方式主要是在启动时添加--trace_gc参数。在进行垃圾回收时，将会从标准输出中打印垃圾回收的日志信息。</p> <div class="language- extra-class"><pre class="language-text"><code>node --trace_gc -e &quot;var a = [];for (var i = 0; i &lt; 1000000; i++) a.push(new Array(100));&quot;
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>[71982:0x118008000]       26 ms: Scavenge 2.4 (3.0) -&gt; 2.0 (4.0) MB, 0.7 / 0.0 ms  (average mu = 1.000, current mu = 1.000) allocation failure 
[71982:0x118008000]       33 ms: Scavenge 2.6 (4.3) -&gt; 2.5 (5.0) MB, 0.6 / 0.0 ms  (average mu = 1.000, current mu = 1.000) allocation failure 
[71982:0x118008000]       34 ms: Scavenge 3.2 (7.0) -&gt; 3.2 (7.3) MB, 0.3 / 0.0 ms  (average mu = 1.000, current mu = 1.000) allocation failure 
[71982:0x118008000]       35 ms: Scavenge 4.5 (7.3) -&gt; 4.5 (7.8) MB, 0.4 / 0.0 ms  (average mu = 1.000, current mu = 1.000) allocation failure 
[71982:0x118008000]       36 ms: Scavenge 5.1 (11.8) -&gt; 4.9 (13.0) MB, 0.8 / 0.0 ms  (average mu = 1.000, current mu = 1.000) allocation failure 
[71982:0x118008000]       37 ms: Scavenge 8.3 (13.0) -&gt; 8.6 (13.8) MB, 0.8 / 0.0 ms  (average mu = 1.000, current mu = 1.000) allocation failure 
[71982:0x118008000]       39 ms: Scavenge 8.8 (21.8) -&gt; 8.4 (25.5) MB, 1.2 / 0.0 ms  (average mu = 1.000, current mu = 1.000) allocation failure 
[71982:0x118008000]       50 ms: Scavenge 16.3 (25.7) -&gt; 17.1 (26.5) MB, 3.2 / 0.0 ms  (average mu = 1.000, current mu = 1.000) allocation failure 
[71982:0x118008000]       52 ms: Scavenge 17.1 (42.5) -&gt; 16.1 (49.5) MB, 2.5 / 0.0 ms  (average mu = 1.000, current mu = 1.000) allocation failure 
[71982:0x118008000]       64 ms: Scavenge 32.7 (50.1) -&gt; 34.3 (51.9) MB, 6.8 / 0.0 ms  (average mu = 1.000, current mu = 1.000) allocation failure 
[71982:0x118008000]       69 ms: Scavenge 34.3 (51.9) -&gt; 32.3 (65.9) MB, 4.2 / 0.0 ms  (average mu = 1.000, current mu = 1.000) allocation failure 
[71982:0x118008000]       99 ms: Mark-sweep 86.4 (111.6) -&gt; 85.0 (118.8) MB, 3.0 / 0.0 ms  (+ 8.1 ms in 127 steps since start of marking, biggest step 0.2 ms, walltime since start of marking 23 ms) (average mu = 1.000, current mu = 1.000) finalize incremental marking via stack guard GC in old space requested
[71982:0x118008000]      437 ms: Scavenge 482.6 (517.2) -&gt; 476.3 (511.0) MB, 35.8 / 0.0 ms  (average mu = 1.000, current mu = 1.000) allocation failure 
[71982:0x118008000]      495 ms: Mark-sweep 544.1 (579.1) -&gt; 542.6 (577.6) MB, 6.1 / 0.0 ms  (+ 70.0 ms in 711 steps since start of marking, biggest step 0.4 ms, walltime since start of marking 235 ms) (average mu = 0.808, current mu = 0.808) finalize incremental marking via stack guard GC in old space requested
</code></pre></div><p>V8提供了linux-tick-processor工具用于统计日志信息。该工具可以从Node源码的
deps/v8/tools目录下找到，Windows下的对应命令文件为windows-tick-processor.bat。将该目录添
加到环境变量PATH中，即可直接调用：</p> <p>linux-tick-processor v8.log</p> <h3 id="_02-高效使用内存"><a href="#_02-高效使用内存" class="header-anchor">#</a> 02. 高效使用内存</h3> <p>在V8面前，开发者所要具备的责任是如何让垃圾回收机制更高效地工作。</p> <h4 id="作用域"><a href="#作用域" class="header-anchor">#</a> 作用域</h4> <p>提到如何触发垃圾回收，第一个要介绍的是作用域（scope）。在JavaScript中能形成作用域
的有函数调用、with以及全局作用域.</p> <p>以如下代码为例：</p> <div class="language- extra-class"><pre class="language-text"><code>var foo = function () {
 var local = {};
};
</code></pre></div><p>foo()函数在每次被调用时会创建对应的作用域，函数执行结束后，该作用域将会销毁。同时作用域中声明的局部变量分配在该作用域上，随作用域的销毁而销毁。只被局部变量引用的对象存活周期较短。在这个示例中，由于对象非常小，将会分配在新生代中的From空间中。在作用域释放后，局部变量local失效，其引用的对象将会在下次垃圾回收时被释放。</p> <p>以上就是最基本的内存回收过程。</p> <ol><li>标识符查找
所谓标识符，可以理解为变量名</li></ol> <p>在下面的代码中，执行
bar()函数时，将会遇到local变量：</p> <div class="language- extra-class"><pre class="language-text"><code>var bar = function () {
 console.log(local);
};
</code></pre></div><p>JavaScript在执行时会去查找该变量定义在哪里。它最先查找的是当前作用域，如果在当前作
用域中无法找到该变量的声明，将会向上级的作用域里查找，直到查到为止。</p> <ol start="2"><li>作用域链
在下面的代码中：</li></ol> <div class="language- extra-class"><pre class="language-text"><code>var foo = function () {
  var local = &quot;local var&quot;;
  var bar = function () {
    var local = &quot;another var&quot;;
    var baz = function () {
      console.log(local);
    };
    baz();
  };
  bar();
};
foo();
</code></pre></div><p>变量在作用域中的查找示意图
<img src="/images/node/%E5%8F%98%E9%87%8F%E5%9C%A8%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p> <ol start="3"><li>变量的主动释放
如果变量是全局变量（不通过var声明或定义在global变量上），由于全局作用域需要直到进程退出才能释放，此时将导致引用的对象常驻内存（常驻在老生代中）。如如果需要释放常驻内存的对象，可以通过delete操作来删除引用关系。或者将变量重新赋值，让旧的对象脱离引用关系。在接下来的老生代内存清除和整理的过程中，会被回收释放。
下面为示例代码：</li></ol> <div class="language- extra-class"><pre class="language-text"><code>global.foo = &quot;I am global object&quot;;
console.log(global.foo); // =&gt; &quot;I am global object&quot;
delete global.foo;
// 或者重新赋值
global.foo = undefined; // or null
console.log(global.foo); // =&gt; undefined 
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">提示</p> <p>是在V8中通过delete删除对象的属性有可能干扰V8的优化，所以通过赋值方式解除引用更好。</p></div> <h4 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h4> <p>作用域链上的对象访问只能向上，这样外部无法向内部访问</p> <div class="language- extra-class"><pre class="language-text"><code>var foo = function () {
 var local = &quot;局部变量&quot;;
 (function () {
 console.log(local);
 }());
}; 

输出：
局部变量
</code></pre></div><p>但在下面的代码中，却会得到local未定义的异常：</p> <div class="language- extra-class"><pre class="language-text"><code>var foo = function () {
 (function () {
 var local = &quot;局部变量&quot;;
 }());
 console.log(local);
}; 

输出异常：
console.log(local);
              ^
ReferenceError: local is not defined
at foo (/Users/wsh/github/node-demo/index.js:68:15)
at Object.&lt;anonymous&gt; (/Users/wsh/github/node-demo/index.js:70:1)
</code></pre></div><p>在JavaScript中，<code>实现外部作用域访问内部作用域中变量的方法叫做闭包</code>。这得益于高阶函数的特性：函数可以作为参数或者返回值。示例代码的如下：</p> <div class="language- extra-class"><pre class="language-text"><code>var foo = function () {
  var bar = function () {
    var local = &quot;局部变量&quot;;
    return function () {
      return local;
    };
  };
  var baz = bar();
  console.log(baz());
};
 
</code></pre></div><p>一般而言，在bar()函数执行完成后，局部变量local将会随着作用域的销毁而被回收。注意返回值是一个匿名函数，且这个函数中具备了访问local的条件，虽然在后续的执行中，在外部作用域中还是无法直接访问local，但是若要访问它，只要通过这个中间函
数稍作周转即可。</p> <p>一旦有变量引用这个中间函数，这个中间函数将不会释放，同时也会使原始的作用域不会得到释放，作用域中产生的内存占用也不会得到释放。除非不再有引用，才会逐步释放。</p> <div class="custom-block tip"><p class="custom-block-title">总结</p> <p>在正常的JavaScript执行中，无法立即回收的内存有闭包和全局变量引用这两种情况。由于V8的内存限制，要十分小心此类变量是否无限制地增加，因为它会导致老生代中的对象增多。</p></div> <h3 id="_03-内存指标"><a href="#_03-内存指标" class="header-anchor">#</a> 03. 内存指标</h3> <p>一般而言，应用中存在一些全局性的对象是正常的，而且在正常的使用中，变量都会自动释放回收。但是也会存在一些我们认为会回收但是却没有被回收的对象，这会导致内存占用无限增长。一旦增长达到V8的内存限制，将会得到内存溢出错误，进而导致进程退出。</p> <h4 id="查看内存使用情况"><a href="#查看内存使用情况" class="header-anchor">#</a> 查看内存使用情况</h4> <ol><li>process.memoryUsage()可以查看内存使用情况</li> <li>os模块中的totalmem()和freemem()方法也可以查看内存使用情况</li></ol> <h5 id="查看进程的内存占用"><a href="#查看进程的内存占用" class="header-anchor">#</a> 查看进程的内存占用</h5> <p>调用process.memoryUsage()可以看到Node进程的内存占用情况，示例代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>wsh@wsh ~ % node
&gt; process.memoryUsage()
{
  rss: 118702080,
  heapTotal: 5005312,
  heapUsed: 3128976,
  external: 1672670,
  arrayBuffers: 9911
}
</code></pre></div><ul><li>rss是resident set size的缩写，即进程的常驻内存部分。进程的内存总共有几部分，一部分是rss，其余部分在交换区（swap）或者文件系统（filesystem）中。</li> <li>heapTotal和heapUsed对应的是V8的堆内存信息。heapTotal是堆中总共申请的内存量，heapUsed表示目前堆中使用中的内存量。这3个值的单位都是字节。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>var showMem = function () {
  var mem = process.memoryUsage();
  var format = function (bytes) {
    return (bytes / 1024 / 1024).toFixed(2) + &quot; MB&quot;;
  };
  console.log(
    &quot;Process: heapTotal &quot; +
      format(mem.heapTotal) +
      &quot; heapUsed &quot; +
      format(mem.heapUsed) +
      &quot; rss &quot; +
      format(mem.rss)
  );
  console.log(&quot;-----------------------------------------------------------&quot;);
};
showMem();

var useMem = function () {
  var size = 20 * 1024 * 1024;
  var arr = new Array(size);
  for (var i = 0; i &lt; size; i++) {
    arr[i] = 0;
  }
  return arr;
};
var total = [];
for (var j = 0; j &lt; 15; j++) {
  showMem();
  total.push(useMem());
}
showMem(); 
</code></pre></div><p>输出结果：JavaScript 堆内存不足</p> <div class="language- extra-class"><pre class="language-text"><code>Process: heapTotal 4.27 MB heapUsed 2.59 MB rss 90.94 MB
-----------------------------------------------------------
Process: heapTotal 4.77 MB heapUsed 2.93 MB rss 94.16 MB
-----------------------------------------------------------
Process: heapTotal 164.82 MB heapUsed 162.94 MB rss 749.16 MB
-----------------------------------------------------------
Process: heapTotal 325.82 MB heapUsed 322.71 MB rss 1391.83 MB
-----------------------------------------------------------
Process: heapTotal 488.08 MB heapUsed 482.73 MB rss 2035.33 MB
-----------------------------------------------------------
Process: heapTotal 652.58 MB heapUsed 642.70 MB rss 2654.91 MB
-----------------------------------------------------------
Process: heapTotal 820.59 MB heapUsed 802.70 MB rss 3097.00 MB
-----------------------------------------------------------
Process: heapTotal 996.59 MB heapUsed 962.70 MB rss 3723.53 MB
-----------------------------------------------------------
Process: heapTotal 1156.59 MB heapUsed 1122.70 MB rss 4335.13 MB
-----------------------------------------------------------
Process: heapTotal 1316.60 MB heapUsed 1282.70 MB rss 4932.05 MB
-----------------------------------------------------------
Process: heapTotal 1476.60 MB heapUsed 1442.70 MB rss 5535.61 MB
-----------------------------------------------------------
Process: heapTotal 1636.61 MB heapUsed 1602.70 MB rss 6146.20 MB
-----------------------------------------------------------
Process: heapTotal 1796.61 MB heapUsed 1762.70 MB rss 6786.23 MB
-----------------------------------------------------------
Process: heapTotal 1956.61 MB heapUsed 1922.70 MB rss 7426.31 MB
-----------------------------------------------------------
Process: heapTotal 2115.87 MB heapUsed 2082.05 MB rss 8099.53 MB
-----------------------------------------------------------

&lt;--- Last few GCs ---&gt;

[75211:0x118008000]     1433 ms: Scavenge 1762.6 (1796.6) -&gt; 1762.6 (1796.6) MB, 11.7 / 0.0 ms  (average mu = 1.000, current mu = 1.000) allocation failure 
[75211:0x118008000]     1638 ms: Mark-sweep 1922.6 (1956.6) -&gt; 1921.9 (1955.9) MB, 110.0 / 0.1 ms  (+ 35.4 ms in 10 steps since start of marking, biggest step 6.0 ms, walltime since start of marking 1348 ms) (average mu = 1.000, current mu = 1.000) alloca

&lt;--- JS stacktrace ---&gt;

FATAL ERROR: MarkCompactCollector: young object promotion failed Allocation failed - JavaScript heap out of memory
</code></pre></div><h5 id="查看系统的内存占用"><a href="#查看系统的内存占用" class="header-anchor">#</a> 查看系统的内存占用</h5> <p>os模块中的totalmem()和freemem()这两个方法用于查看操作系统的内存使用情况，它们分别返回系统的总内存和闲置内存，以字节为单位.</p> <div class="language- extra-class"><pre class="language-text"><code>% node
&gt; os.totalmem()
8589934592
&gt; os.freemem() 
110432256
&gt; 
</code></pre></div><p>从输出信息可以看到我的电脑的总内存为8 GB，当前闲置内存大致为1GB。</p> <h4 id="堆外内存"><a href="#堆外内存" class="header-anchor">#</a> 堆外内存</h4> <p>通过process.momoryUsage()的结果可以看到，堆中的内存用量总是小于进程的常驻内存用量，这意味着Node中的内存使用并非都是通过V8进行分配的。我们将那些不是通过V8分配的内存称为<code>堆外内存</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>var useMem = function () {
 var size = 200 * 1024 * 1024;
 var buffer = new Buffer(size);
 for (var i = 0; i &lt; size; i++) {
 buffer[i] = 0;
 }
 return buffer;
}; 
</code></pre></div><p>唯一变化大的是rss的值，原因是Buffer对象不同于其他对象，它不经过V8的内存分配机制，所以也不会有堆内存的大小限制。</p> <div class="custom-block tip"><p class="custom-block-title">总结</p> <p>Node的内存构成主要由通过V8进行分配的部分和Node自行分配的部分。受V8的垃圾回收限制的主要是V8的堆内存</p></div> <h3 id="_04-内存泄漏"><a href="#_04-内存泄漏" class="header-anchor">#</a> 04. 内存泄漏</h3> <div class="custom-block tip"><p class="custom-block-title">内存泄漏实质</p> <p>是应当回收的对象出现意外而没有被回收，变成了常驻在老生代中的对象</p></div> <p>通常，造成内存泄漏的原因有如下几个。</p> <ul><li>缓存。</li> <li>队列消费不及时。</li> <li>作用域未释放。</li></ul> <h4 id="慎将内存当做缓存"><a href="#慎将内存当做缓存" class="header-anchor">#</a> 慎将内存当做缓存</h4> <p>严格意义的缓存有着完善的过期策略，而普通对象的键值对并没有。
如果需要，只要限定缓存对象的大小，加上完善的过期策略以防止内存无限制增长，还是可以一用的。
如下代码虽然利用JavaScript对象十分容易创建一个缓存对象，但是受垃圾回收机制的影响，
只能小量使用：</p> <div class="language- extra-class"><pre class="language-text"><code>var cache = {};
var get = function (key) {
 if (cache[key]) {
 return cache[key];
 } else {
 // get from otherwise
 }
};
var set = function (key, value) {
 cache[key] = value;
};
</code></pre></div><ol><li>缓存限制策略
为了解决缓存中的对象永远无法释放的问题，需要加入一种策略来限制缓存的无限增长。
模块limitablemap:记录键在数组中，一旦超过数量，就以先进先出的方式进行淘汰</li></ol> <div class="language- extra-class"><pre class="language-text"><code>var LimitableMap = function (limit) {
 this.limit = limit || 10;
 this.map = {};
 this.keys = [];
};
var hasOwnProperty = Object.prototype.hasOwnProperty;
LimitableMap.prototype.set = function (key, value) {
 var map = this.map;
 var keys = this.keys;
 if (!hasOwnProperty.call(map, key)) {
 if (keys.length === this.limit) {
 var firstKey = keys.shift();
 delete map[firstKey];
 }
 keys.push(key);
 }
 map[key] = value;
};
LimitableMap.prototype.get = function (key) {
 return this.map[key];
};
module.exports = LimitableMap; 
</code></pre></div><p>由于通过exports导出的函数，可以访问文件模块中的私有变量，这样每个文件模块在编译执行后形成的作用域因为模块缓存的原因，不会被释放。由于模块的缓存机制，模块是常驻老生代的
示例代码如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>(function (exports, require, module, __filename, __dirname) {
 var local = &quot;局部变量&quot;;
 exports.get = function () {
 return local;
 };
}); 
</code></pre></div><ol start="2"><li>缓存的解决方案</li></ol> <p>进程之间无法共享内存。如果在进程内使用缓存，这些缓存不可避免地有重复，对物理内存的使用是一种浪费。</p> <p>如何使用大量缓存，目前比较好的解决方案是采用进程外的缓存，进程自身不存储状态。外部的缓存软件有着良好的缓存过期淘汰策略以及自有的内存管理，不影响Node进程的性能。它的好处多多，在Node中主要可以解决以下两个问题。</p> <ul><li>将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效。</li> <li>进程之间可以共享缓存。</li></ul> <p><a href="https://github.com/mranney/node_redis" target="_blank" rel="noopener noreferrer">Redis<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <a href="https://github.com/3rd-Eden/node-memcached" target="_blank" rel="noopener noreferrer">Memcached<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h4 id="关注队列状态"><a href="#关注队列状态" class="header-anchor">#</a> 关注队列状态</h4> <p>在大多数应用场景下，消费的速度远远大于生产的速度，内存泄漏不易产生。但是一旦消费速度低于生产速度，
将会形成堆积。</p> <p>举个实际的例子，有的应用会收集日志。如果欠缺考虑，也许会采用数据库来记录日志。日志通常会是海量的，数据库构建在文件系统之上，写入效率远远低于文件直接写入，于是会形成数据库写入操作的堆积，而JavaScript中相关的作用域也不会得到释放，内存占用不会回落，从而出现内存泄漏。</p> <p>的解决方案: 任意异步调用都应该包含超时机制，一旦在限定的时间内未完成响应，通过回调函数传递超时异常，使得任意异步调用的回调都具备可控的响应时间，给消费速度一个下限值。</p> <h3 id="_05-内存泄漏排查"><a href="#_05-内存泄漏排查" class="header-anchor">#</a> 05. 内存泄漏排查</h3> <p>在Node中，由于V8的堆内存大小的限制，它对内存泄漏非常敏感。当在线服务的请求量变大时，哪怕是一个字节的泄漏都会导致内存占用过高。
现在已经有许多工具用于定位Node应用的内存泄漏，下面是一些常见的工具。</p> <ul><li>node-heapdump。这是Node核心贡献者之一Ben Noordhuis编写的模块，它允许对V8堆内
存抓取快照，用于事后分析。</li> <li>node-mtrace。由Jimb Esser提供，它使用了GCC的mtrace工具来分析堆的使用。</li> <li>dtrace。在Joyent的SmartOS系统上，有完善的dtrace工具用来分析内存泄漏。</li> <li>node-memwatch。来自Mozilla的Lloyd Hilaiel贡献的模块，采用WTFPL许可发布。</li></ul> <h4 id="node-heapdump"><a href="#node-heapdump" class="header-anchor">#</a> node-heapdump</h4> <div class="language- extra-class"><pre class="language-text"><code>// 1. 安装node-heapdump
npm install heapdump 

// 2. 引入
var heapdump = require('heapdump');
</code></pre></div><p>在Chrome的开发者工具中选中Profiles面板，右击该文件后，从弹出的快捷菜单中选择Load...
选项，打开刚才的快照文件，就可以查看堆内存中的详细信息.</p> <h3 id="_06-大内存应用"><a href="#_06-大内存应用" class="header-anchor">#</a> 06. 大内存应用</h3> <p>在Node提供了<code>stream模块</code>用于处理大文件。stream模块是Node的原生模块，直接引用即可。stream继承自EventEmitter，具备基本的自定义事件功能，同时抽象出标准的事件和方法。它分可读和可写两种。</p> <ul><li>fs的createReadStream()和createWriteStream()方法可以分别用于创建文件的可读流和可写流。</li> <li>process模块中的stdin和stdout则分别是可读流和可写流的示例</li></ul> <p>由于V8的内存限制，我们无法通过fs.readFile()和fs.writeFile()直接进行大文件的操作，而改用fs.createReadStream()和fs.createWriteStream()方法通过流的方式实现对大文件的操作。</p> <div class="language- extra-class"><pre class="language-text"><code>var reader = fs.createReadStream('in.txt');
var writer = fs.createWriteStream('out.txt');
reader.on('data', function (chunk) {
 writer.write(chunk);
});
reader.on('end', function () { 
  writer.end();
}); 
</code></pre></div><p>由于读写模型固定，上述方法有更简洁的方式，具体如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>var reader = fs.createReadStream('in.txt');
var writer = fs.createWriteStream('out.txt');
reader.pipe(writer);
</code></pre></div><p>可读流提供了管道方法pipe()，封装了data事件和写入操作。通过流的方式，上述代码不会受到V8内存限制的影响，有效地提高了程序的健壮性。</p> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p>如果不需要进行字符串层面的操作，则不需要借助V8来处理，可以尝试进行纯粹的Buffer操
作，这不会受到V8堆内存的限制。但是这种大片使用内存的情况依然要小心，即使V8不限制堆
内存的大小，物理内存依然有限制。</p></div></div></div> <!----> <div class="page-edit"><!----> <div class="tags"><a href="/tags/?tag=node" title="标签">#node</a></div> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/ec8dfa/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">异步编程</div></a> <a href="/pages/84c133/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">理解Buffer</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/ec8dfa/" class="prev">异步编程</a></span> <span class="next"><a href="/pages/84c133/">理解Buffer</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/5be7db/"><div>
            浏览器原理
            <!----></div></a> <span class="date">05-31</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/54d1ec/"><div>
            打包原理
            <!----></div></a> <span class="date">05-30</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/dc2646/"><div>
            构建速度和体积优化
            <!----></div></a> <span class="date">05-29</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:1730129114@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/wshuhua" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/my/m/music/playlist?id=7141103351" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2022-2022
    <span>Wsh  | <a href="https://github.com/wshuhua" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.1c80f441.js" defer></script><script src="/assets/js/2.dc8a2400.js" defer></script><script src="/assets/js/29.a96448c6.js" defer></script>
  </body>
</html>
